<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Resonant Sanctuary: The Weaver</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            background-color: #0c0a1e; /* Deep cosmic blue */
        }
        .stat-card {
            background-color: rgba(18, 16, 46, 0.7); /* Dark blue/purple */
            backdrop-filter: blur(10px);
            transition: all 0.2s ease-in-out;
            border: 1px solid rgba(76, 71, 128, 0.5);
        }
        .module-card {
            background-color: #1c1944; /* Muted cosmic blue */
            transition: all 0.2s ease-in-out;
            border: 1px solid rgba(76, 71, 128, 0.5);
        }
        .unit-card {
             background-color: #2a275c;
        }
        .log-panel {
            height: 150px;
            background-color: rgba(10, 8, 28, 0.9);
            border-top: 1px solid rgba(76, 71, 128, 0.5);
        }
        canvas {
            border-radius: 0.75rem;
        }
        .grok-btn.loading, .grok-btn:disabled, button:disabled {
            cursor: not-allowed;
            background-color: #4a5568;
            opacity: 0.7;
        }

        /* TDD Fix: Custom scrollbar for log output */
        #log-output {
            scrollbar-width: thin;
            scrollbar-color: #4c1d95 #1e1b4b;
        }
        #log-output::-webkit-scrollbar {
            width: 8px;
        }
        #log-output::-webkit-scrollbar-track {
            background: #1e1b4b;
            border-radius: 4px;
        }
        #log-output::-webkit-scrollbar-thumb {
            background: #4c1d95;
            border-radius: 4px;
        }
        #log-output::-webkit-scrollbar-thumb:hover {
            background: #5b21b6;
        }

        /* Ensure log entries don't break layout */
        .log-entry {
            word-wrap: break-word;
            line-height: 1.4;
            margin-bottom: 0.25rem;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .log-entry {
            animation: fadeIn 0.5s ease-out;
        }
    </style>
</head>
<body class="text-indigo-100 flex flex-col h-screen">

    <!-- Top Bar -->
    <header class="w-full p-4 bg-[#1c1944] border-b border-indigo-900 shadow-lg z-10">
        <h1 class="text-2xl font-bold text-white">Resonant Sanctuary: The Weaver</h1>
    </header>

    <!-- Main Content -->
    <div class="flex flex-1 overflow-hidden">
        
        <!-- Left Panel: Units & Upgrades -->
        <aside class="w-1/3 max-w-sm p-4 overflow-y-auto bg-[#1c1944] border-r border-indigo-900 flex flex-col">
            <div>
                <h2 class="text-xl font-semibold mb-4 text-white">Create Units</h2>
                <div id="units-panel" class="space-y-4">
                    <!-- Unit creation cards will be injected here -->
                </div>
            </div>
            <div class="mt-6 flex-1">
                <h2 class="text-xl font-semibold mb-4 text-white">Attune Nodes</h2>
                <div id="modules-panel" class="space-y-4">
                    <!-- Module cards will be injected here -->
                </div>
            </div>
             <div class="mt-6 space-y-3">
                 <button id="advisor-btn" class="grok-btn w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg shadow-md transition-colors">
                    üìú Ask Advisor
                </button>
                 <button id="seasonal-vision-btn" class="grok-btn w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-4 rounded-lg shadow-md transition-colors">
                    ‚ú® Get Resonant Vision
                </button>
            </div>
        </aside>

        <!-- Center Panel: Village View & Stats -->
        <main class="flex-1 flex flex-col p-4">
            <!-- Stats Bar -->
            <div id="stats-bar" class="grid grid-cols-2 md:grid-cols-5 gap-4 mb-4">
                <!-- Stat cards will be injected here -->
            </div>

            <!-- Village Canvas -->
            <div class="flex-1 relative">
                 <canvas id="village-canvas" class="w-full h-full"></canvas>
            </div>
        </main>

    </div>

    <!-- Bottom Bar: Log - TDD Fixed Height with Scrolling -->
    <footer id="log-panel" class="w-full border-t border-indigo-900" style="height: 200px; min-height: 200px; max-height: 200px;">
        <div class="p-4 h-full flex flex-col">
            <h3 class="font-semibold text-lg mb-2 text-indigo-200 flex-shrink-0">Aetheric Log</h3>
            <div id="log-output" class="text-sm text-indigo-300 space-y-1 flex-1 overflow-y-auto pr-2"></div>
        </div>
    </footer>
    
    <!-- TDD Test Runner (Hidden) -->
    <div id="test-runner" style="display: none;"></div>

    <!-- TDD API Key Popup -->
    <div id="api-key-popup" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-gray-800 border border-indigo-600 p-6 rounded-lg max-w-md w-full mx-4 shadow-2xl">
            <h3 class="text-xl font-bold text-white mb-4">üîë Configure Grok API Key</h3>
            <p class="text-gray-300 mb-4">To access cosmic wisdom and AI insights, please enter your Grok API key:</p>
            <p class="text-sm text-indigo-300 mb-4">Get your API key from <a href="https://x.ai" target="_blank" class="text-blue-400 hover:text-blue-300 underline">x.ai</a></p>
            <input type="password" id="api-key-input" class="w-full p-3 bg-gray-700 text-white rounded mb-2 border border-gray-600 focus:border-indigo-500 focus:outline-none" placeholder="Enter your Grok API key...">
            <div id="api-key-error" class="text-red-400 text-sm mb-4 hidden"></div>
            <div class="flex gap-3">
                <button id="save-api-key" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white py-2 px-4 rounded transition-colors">
                    üíæ Save Key
                </button>
                <button id="cancel-api-key" class="flex-1 bg-gray-600 hover:bg-gray-700 text-white py-2 px-4 rounded transition-colors">
                    ‚ùå Cancel
                </button>
            </div>
        </div>
    </div>

    <script>
        // --- Canvas & DOM Elements ---
        const canvas = document.getElementById('village-canvas');
        const ctx = canvas.getContext('2d');
        const modulesPanel = document.getElementById('modules-panel');
        const unitsPanel = document.getElementById('units-panel');
        const statsBar = document.getElementById('stats-bar');
        const logOutput = document.getElementById('log-output');
        const seasonalVisionBtn = document.getElementById('seasonal-vision-btn');
        const advisorBtn = document.getElementById('advisor-btn');

        // --- Game State (Incremental Model) - TDD Races Expansion ---
        let gameState = {
            energy: 20,
            energyPerSecond: 0,
            insight: 5,
            insightPerSecond: 0,
            harmony: 50,
            units: {
                dreamers: 1,  // Start with 1 dreamer for immediate insight generation
                weavers: 1,   // Start with 1 weaver for immediate energy generation
                stellarNomads: 0,
                voidWhisperers: 0,
                crystalBeings: 0,
                plasmaDancers: 0,
                quantumSages: 0,
                nebulaShepherds: 0
            },
            unitCosts: {
                dreamers: 15,  // Slightly higher since we start with units
                weavers: 15,
                stellarNomads: 25,
                voidWhisperers: 40,
                crystalBeings: 60,
                plasmaDancers: 80,
                quantumSages: 120,
                nebulaShepherds: 200
            },
            unlockedRaces: ['human'], // Start with humans unlocked
            nodes: {
                sustenance: 0,
                energy: 0,
                cohesion: 0,
                cycling: 0,
            },
            nodeCosts: {
                sustenance: 100,
                energy: 100,
                cohesion: 500,
                cycling: 200,
            },
            villageGrid: [],
            stars: [],
            lastUpdate: Date.now(),
        };

        // --- Game Config - TDD Races System ---
        const racesConfig = {
            human: { name: "Human", description: "The original inhabitants", color: '#8B5CF6', symbol: 'üë§', unlocked: true, tier: 1 },
            stellar: { name: "Stellar Nomads", description: "Wandering star-travelers", color: '#F59E0B', symbol: '‚≠ê', unlockCondition: { energy: 50, insight: 25 }, unlocked: false, tier: 2 },
            void: { name: "Void Whisperers", description: "Mysterious void entities", color: '#1F2937', symbol: 'üåë', unlockCondition: { harmony: 70, energy: 100 }, unlocked: false, tier: 3 },
            crystal: { name: "Crystal Beings", description: "Living crystalline entities", color: '#10B981', symbol: 'üíé', unlockCondition: { energy: 200, insight: 100 }, unlocked: false, tier: 3 },
            plasma: { name: "Plasma Dancers", description: "Pure energy beings", color: '#EF4444', symbol: 'üî•', unlockCondition: { energy: 500, harmony: 80 }, unlocked: false, tier: 4 },
            quantum: { name: "Quantum Sages", description: "Multi-dimensional beings", color: '#8B5CF6', symbol: 'üåÄ', unlockCondition: { insight: 500, harmony: 85 }, unlocked: false, tier: 5 },
            nebula: { name: "Nebula Shepherds", description: "Ancient star-birthers", color: '#A78BFA', symbol: 'üåå', unlockCondition: { energy: 1000, insight: 800, harmony: 95 }, unlocked: false, tier: 5 }
        };

        const unitsConfig = {
            dreamers: { name: "Dreamer", description: "Generates Insight through cosmic meditation.", baseInsight: 0.1, costResource: 'energy', race: 'human', special: 'dreamVision' },
            weavers: { name: "Weaver", description: "Generates Energy by weaving cosmic threads.", baseEnergy: 0.1, costResource: 'insight', race: 'human', special: 'energyWeaving' },
            stellarNomads: { name: "Stellar Nomad", description: "Star-travelers generating Energy and Insight.", baseEnergy: 0.15, baseInsight: 0.05, costResource: 'energy', race: 'stellar', special: 'stellarNavigation' },
            voidWhisperers: { name: "Void Whisperer", description: "Void communers generating Insight and Harmony.", baseInsight: 0.08, baseHarmony: 0.02, costResource: 'insight', race: 'void', special: 'voidCommunion' },
            crystalBeings: { name: "Crystal Being", description: "Living crystals amplifying cosmic energy.", baseEnergy: 0.2, costResource: 'energy', race: 'crystal', special: 'crystalResonance' },
            plasmaDancers: { name: "Plasma Dancer", description: "Pure energy beings dancing through plasma.", baseEnergy: 0.3, costResource: 'insight', race: 'plasma', special: 'plasmaManipulation' },
            quantumSages: { name: "Quantum Sage", description: "Multi-dimensional beings with vast knowledge.", baseInsight: 0.5, costResource: 'energy', race: 'quantum', special: 'quantumEntanglement' },
            nebulaShepherds: { name: "Nebula Shepherd", description: "Ancient beings birthing stars.", baseEnergy: 0.8, baseInsight: 0.3, baseHarmony: 0.1, costResource: 'insight', race: 'nebula', special: 'starBirth' }
        };

        const nodesConfig = {
            sustenance: { name: "Sustenance Node", description: "Boosts Dreamer insight generation.", effectTarget: 'dreamers', multiplier: 1.2, costResource: 'energy' },
            energy: { name: "Energy Node", description: "Boosts Weaver energy generation.", effectTarget: 'weavers', multiplier: 1.2, costResource: 'insight' },
            cohesion: { name: "Cohesion Node", description: "Boosts all production.", effectTarget: 'all', multiplier: 1.1, costResource: 'energy' },
            cycling: { name: "Recycling Node", description: "Reduces the cost of all units and improves Harmony.", effectTarget: 'cost', multiplier: 0.95, harmony: 5, costResource: 'insight' },
        };

        // --- Utility Functions ---
        const formatNumber = (num) => {
            if (num < 1000) return num.toFixed(1);
            if (num < 1e6) return (num / 1e3).toFixed(2) + 'k';
            if (num < 1e9) return (num / 1e6).toFixed(2) + 'M';
            return (num / 1e9).toFixed(2) + 'B';
        };
        const log = (message, type = 'info') => {
            const colors = { info: 'text-indigo-300', success: 'text-teal-300', error: 'text-red-400', warning: 'text-amber-300', grok: 'text-purple-300' };
            const p = document.createElement('p');
            p.innerHTML = `[INFO] ${message}`;
            p.className = `${colors[type]} log-entry`;
            logOutput.prepend(p);
            if (logOutput.children.length > 20) {
                logOutput.lastChild.remove();
            }
        };

        // --- Rendering Functions ---
        const renderStats = () => {
            statsBar.innerHTML = `
                <div class="stat-card p-3 rounded-lg" title="Energy. Used to create Dreamers."><p class="text-sm text-indigo-300">‚ö° Energy</p><p class="text-xl font-bold text-yellow-300">${formatNumber(gameState.energy)}</p><p class="text-xs text-yellow-400">${formatNumber(gameState.energyPerSecond)}/s</p></div>
                <div class="stat-card p-3 rounded-lg" title="Insight. Used to create Weavers."><p class="text-sm text-indigo-300">üîÆ Insight</p><p class="text-xl font-bold text-purple-300">${formatNumber(gameState.insight)}</p><p class="text-xs text-purple-400">${formatNumber(gameState.insightPerSecond)}/s</p></div>
                <div class="stat-card p-3 rounded-lg" title="Dreamers generate Insight."><p class="text-sm text-indigo-300">Î™Ω Dreamer Units</p><p class="text-xl font-bold">${formatNumber(gameState.units.dreamers)}</p></div>
                <div class="stat-card p-3 rounded-lg" title="Weavers generate Energy."><p class="text-sm text-indigo-300">üï∏Ô∏è Weaver Units</p><p class="text-xl font-bold">${formatNumber(gameState.units.weavers)}</p></div>
                <div class="stat-card p-3 rounded-lg" title="Ecological balance."><p class="text-sm text-indigo-300">üåø Harmony</p><p class="text-xl font-bold text-green-400">${gameState.harmony.toFixed(1)}%</p></div>
            `;
        };

        // TDD Fix: Stable button rendering that doesn't recreate buttons
        let unitsInitialized = false;

        // TDD Races: Check for newly unlocked races
        const checkRaceUnlocks = () => {
            let newlyUnlocked = [];

            Object.entries(racesConfig).forEach(([raceKey, race]) => {
                if (!gameState.unlockedRaces.includes(raceKey) && !race.unlocked) {
                    if (!race.unlockCondition) {
                        gameState.unlockedRaces.push(raceKey);
                        race.unlocked = true;
                        newlyUnlocked.push(raceKey);
                    } else {
                        const canUnlock = Object.entries(race.unlockCondition).every(([resource, required]) => {
                            return gameState[resource] >= required;
                        });

                        if (canUnlock) {
                            gameState.unlockedRaces.push(raceKey);
                            race.unlocked = true;
                            newlyUnlocked.push(raceKey);
                            log(`üåü New race discovered: ${race.name}! ${race.description}`, 'success');
                        }
                    }
                }
            });

            return newlyUnlocked;
        };

        const renderUnits = () => {
            // Only create buttons once, then update their states
            if (!unitsInitialized) {
                createUnitButtons();
                unitsInitialized = true;
            }
            updateUnitButtonStates();
        };

        const createUnitButtons = () => {
            unitsPanel.innerHTML = '';
            for (const key in unitsConfig) {
                const unit = unitsConfig[key];
                const card = document.createElement('div');
                card.className = "unit-card p-4 rounded-lg border border-indigo-800";
                card.innerHTML = `
                    <h3 class="font-bold text-lg text-white">${unit.name}</h3>
                    <p class="text-sm text-indigo-200">${unit.description}</p>
                    <button class="unit-btn w-full mt-2 py-2 px-3 text-sm font-semibold rounded-md transition-colors"
                            data-unit="${key}">
                        Create ${unit.name}
                    </button>
                `;

                // Add stable event listener
                const button = card.querySelector('.unit-btn');
                button.addEventListener('click', () => {
                    if (!button.disabled) {
                        createUnit(key);
                    }
                });

                unitsPanel.appendChild(card);
            }
        };

        const updateUnitButtonStates = () => {
            for (const key in unitsConfig) {
                const unit = unitsConfig[key];
                const cost = gameState.unitCosts[key];
                const canAfford = gameState[unit.costResource] >= cost;

                const button = unitsPanel.querySelector(`[data-unit="${key}"]`);
                if (button) {
                    button.disabled = !canAfford;
                    button.textContent = `Create (Cost: ${formatNumber(cost)} ${unit.costResource})`;

                    // Update visual state without recreating
                    button.className = `unit-btn w-full mt-2 py-2 px-3 text-sm font-semibold rounded-md transition-colors ${
                        canAfford ? 'bg-green-600 hover:bg-green-700 text-white' : 'bg-gray-600 text-gray-400'
                    }`;
                }
            }
        };

        // TDD Fix: Stable node button rendering
        let nodesInitialized = false;

        const renderNodes = () => {
            // Only create buttons once, then update their states
            if (!nodesInitialized) {
                createNodeButtons();
                nodesInitialized = true;
            }
            updateNodeButtonStates();
        };

        const createNodeButtons = () => {
            modulesPanel.innerHTML = '';
            for (const key in nodesConfig) {
                const node = nodesConfig[key];
                const card = document.createElement('div');
                card.className = "module-card p-4 rounded-lg";
                card.innerHTML = `
                    <h3 class="font-bold text-lg text-white">
                        ${node.name} <span class="text-sm font-normal text-indigo-300 level-display" data-node="${key}">(Lvl 0)</span>
                    </h3>
                    <p class="text-sm text-indigo-200">${node.description}</p>
                    <button class="node-btn w-full mt-2 py-2 px-3 text-sm font-semibold rounded-md transition-colors"
                            data-node="${key}">
                        Attune ${node.name}
                    </button>
                `;

                // Add stable event listener
                const button = card.querySelector('.node-btn');
                button.addEventListener('click', () => {
                    if (!button.disabled) {
                        upgradeNode(key);
                    }
                });

                modulesPanel.appendChild(card);
            }
        };

        const updateNodeButtonStates = () => {
            for (const key in nodesConfig) {
                const node = nodesConfig[key];
                const cost = gameState.nodeCosts[key];
                const level = gameState.nodes[key];
                const canAfford = gameState[node.costResource] >= cost;

                // Update level display
                const levelDisplay = modulesPanel.querySelector(`[data-node="${key}"].level-display`);
                if (levelDisplay) {
                    levelDisplay.textContent = `(Lvl ${level})`;
                }

                // Update button
                const button = modulesPanel.querySelector(`button[data-node="${key}"]`);
                if (button) {
                    button.disabled = !canAfford;
                    button.textContent = `Attune (Cost: ${formatNumber(cost)} ${node.costResource})`;

                    // Update visual state without recreating
                    button.className = `node-btn w-full mt-2 py-2 px-3 text-sm font-semibold rounded-md transition-colors ${
                        canAfford ? 'bg-teal-600 hover:bg-teal-700 text-white' : 'bg-gray-600 text-gray-400'
                    }`;
                }
            }
        };

        const renderUI = () => {
            renderStats();
            renderUnits();
            renderNodes();
        }
        
        // --- Enhanced Drawing System with Movement ---
        let animationTime = 0;
        let particles = [];

        // TDD Task 1: Drag and Drop System
        let dragState = {
            isDragging: false,
            draggedUnit: null,
            dragOffsetX: 0,
            dragOffsetY: 0,
            hoveredUnit: null
        };

        let movementTrails = {};

        // TDD Task 2: Enhanced Visual Effects System
        let particlePool = {
            active: [],
            inactive: [],
            maxParticles: 200
        };

        let lightSources = [];
        let energyFlows = [];
        let screenEffects = {
            bloom: { enabled: true, intensity: 0.3 },
            vignette: { enabled: true, intensity: 0.2 }
        };

        const drawSanctuary = () => {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            animationTime += 0.016; // ~60fps

            // Enhanced Background with nebula effect
            drawBackground();

            // Enhanced Stars with twinkling
            drawStars();

            // Floating particles for magical atmosphere
            updateAndDrawParticles();

            // Energy/Insight flow lines
            drawEnergyFlows();

            // TDD Task 1: Update unit movement and draw enhanced sprites
            updateUnitMovement(0.016);
            updateMovementTrails();

            gameState.villageGrid.sort((a, b) => a.y - b.y);
            gameState.villageGrid.forEach(item => {
                const isHovered = dragState.hoveredUnit === item;
                const isDragged = dragState.draggedUnit === item;

                if (item.type === 'dome') drawEnhancedDome(item.x, item.y, item.size, item, isHovered, isDragged);
                else if (item.type === 'crystal_tree') drawEnhancedCrystalTree(item.x, item.y, item.size, item, isHovered, isDragged);
                else if (item.type === 'garden') drawEnhancedGarden(item.x, item.y, item.size, item, isHovered, isDragged);
                else drawMovableUnit(item, isHovered, isDragged);
            });

            // Draw movement trails
            drawMovementTrails();

            // Ambient light effects
            drawAmbientEffects();
        };

        const drawBackground = () => {
            // Multi-layer gradient background
            const gradient1 = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient1.addColorStop(0, '#0a0820');
            gradient1.addColorStop(0.3, '#1a1040');
            gradient1.addColorStop(0.7, '#2a1860');
            gradient1.addColorStop(1, '#1c1944');
            ctx.fillStyle = gradient1;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Nebula clouds
            for (let i = 0; i < 3; i++) {
                const x = (canvas.width * 0.2) + (i * canvas.width * 0.3);
                const y = canvas.height * 0.3 + Math.sin(animationTime * 0.5 + i) * 20;
                const radius = 150 + Math.sin(animationTime * 0.3 + i) * 30;

                const nebulaGradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                nebulaGradient.addColorStop(0, `rgba(138, 43, 226, ${0.1 + Math.sin(animationTime + i) * 0.05})`);
                nebulaGradient.addColorStop(0.5, `rgba(75, 0, 130, ${0.05 + Math.sin(animationTime * 0.7 + i) * 0.03})`);
                nebulaGradient.addColorStop(1, 'rgba(75, 0, 130, 0)');

                ctx.fillStyle = nebulaGradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        };

        const drawStars = () => {
            // Initialize enhanced stars
            if (gameState.stars.length === 0) {
                for (let i = 0; i < 150; i++) {
                    gameState.stars.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        radius: Math.random() * 2 + 0.5,
                        alpha: 0.3 + Math.random() * 0.7,
                        twinkleSpeed: 0.5 + Math.random() * 2,
                        color: Math.random() > 0.8 ? 'rgba(200, 150, 255, ' : 'rgba(255, 255, 255, '
                    });
                }
            }

            gameState.stars.forEach(star => {
                const twinkle = 0.7 + Math.sin(animationTime * star.twinkleSpeed + star.x) * 0.3;
                const alpha = star.alpha * twinkle;

                // Star glow
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius * 2, 0, Math.PI * 2);
                ctx.fillStyle = star.color + (alpha * 0.2) + ')';
                ctx.fill();

                // Star core
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                ctx.fillStyle = star.color + alpha + ')';
                ctx.fill();
            });
        };

        const updateAndDrawParticles = () => {
            // Add new particles occasionally
            if (Math.random() < 0.3) {
                particles.push({
                    x: Math.random() * canvas.width,
                    y: canvas.height + 10,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: -Math.random() * 2 - 0.5,
                    life: 1.0,
                    decay: 0.005 + Math.random() * 0.01,
                    size: Math.random() * 3 + 1,
                    color: Math.random() > 0.5 ? 'rgba(167, 139, 250, ' : 'rgba(196, 181, 253, '
                });
            }

            // Update and draw particles
            particles = particles.filter(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life -= particle.decay;

                if (particle.life > 0) {
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size * particle.life, 0, Math.PI * 2);
                    ctx.fillStyle = particle.color + (particle.life * 0.6) + ')';
                    ctx.fill();
                    return true;
                }
                return false;
            });
        };

        // TDD Task 1: Enhanced sprite system with movement capabilities
        let spriteIdCounter = 0;

        const addSprite = (type, count = 1) => {
            for (let i = 0; i < count; i++) {
                const x = Math.random() * (canvas.width - 100) + 50;
                const y = Math.random() * (canvas.height - 100) + 50;
                const size = type === 'dome' ? 20 : type === 'crystal_tree' ? 25 : 15;

                // Determine if unit is movable based on type
                const movable = ['dreamer', 'weaver', 'stellarNomads', 'voidWhisperers',
                               'crystalBeings', 'plasmaDancers', 'quantumSages', 'nebulaShepherds'].includes(type);

                const sprite = {
                    type: type,
                    x: x,
                    y: y,
                    size: size,
                    movable: movable,
                    id: `${type}_${spriteIdCounter++}`,
                    animationOffset: Math.random() * Math.PI * 2,
                    pulseSpeed: 0.5 + Math.random() * 1.5,
                    // Movement properties for movable units
                    targetX: x,
                    targetY: y,
                    vx: 0,
                    vy: 0,
                    wanderCenter: { x: x, y: y },
                    wanderPhase: Math.random() * Math.PI * 2,
                    wanderRadius: 30 + Math.random() * 20
                };

                gameState.villageGrid.push(sprite);
            }
        };

        const drawEnhancedDome = (x, y, size, sprite, isHovered, isDragged) => {
            ctx.save();

            // Visual feedback for interaction states
            let scale = 1.0;
            let alpha = 1.0;
            let glowIntensity = 0.8;

            if (isDragged) {
                scale = 1.2;
                alpha = 0.9;
                glowIntensity = 1.2;
            } else if (isHovered) {
                scale = 1.1;
                glowIntensity = 1.0;
            }

            ctx.globalAlpha = alpha;
            ctx.translate(x, y);
            ctx.scale(scale, scale);

            const pulse = Math.sin(animationTime * (sprite.pulseSpeed || 1) + (sprite.animationOffset || 0)) * 0.15 + 1;
            const currentSize = size * pulse;

            // Layer 1: Outer energy field with orange/yellow theme
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            ctx.shadowColor = '#FBBF24';
            ctx.shadowBlur = 25 * glowIntensity;
            ctx.beginPath();
            ctx.arc(0, 0, currentSize * 1.8, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(251, 191, 36, 0.2)';
            ctx.fill();
            ctx.restore();

            // Layer 2: Main dome with enhanced orange gradient
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize);
            gradient.addColorStop(0, 'rgba(255, 215, 77, 1.0)');
            gradient.addColorStop(0.6, 'rgba(245, 158, 11, 0.9)');
            gradient.addColorStop(1, 'rgba(217, 119, 6, 0.7)');

            ctx.shadowColor = '#FBBF24';
            ctx.shadowBlur = 15 * glowIntensity;
            ctx.beginPath();
            ctx.arc(0, 0, currentSize, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();

            // Layer 3: Inner highlight
            ctx.save();
            ctx.globalCompositeOperation = 'overlay';
            const highlightGradient = ctx.createRadialGradient(-currentSize * 0.3, -currentSize * 0.3, 0, 0, 0, currentSize * 0.8);
            highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
            highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.beginPath();
            ctx.arc(0, 0, currentSize * 0.7, 0, Math.PI * 2);
            ctx.fillStyle = highlightGradient;
            ctx.fill();
            ctx.restore();

            // Layer 4: Energy orbs floating around dome
            for (let i = 0; i < 3; i++) {
                const angle = animationTime * 0.5 + (i * Math.PI * 2 / 3) + (sprite.animationOffset || 0);
                const orbX = Math.cos(angle) * (currentSize + 15);
                const orbY = Math.sin(angle) * (currentSize + 15);

                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                ctx.shadowColor = '#FBBF24';
                ctx.shadowBlur = 8;
                ctx.beginPath();
                ctx.arc(orbX, orbY, 3, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 215, 77, 0.8)';
                ctx.fill();
                ctx.restore();
            }

            ctx.shadowBlur = 0;
            ctx.restore();
        };

        const drawEnhancedCrystalTree = (x, y, size, sprite) => {
            const pulse = Math.sin(animationTime * sprite.pulseSpeed + sprite.animationOffset) * 0.15 + 1;
            const currentSize = size * pulse;

            // Crystal base/roots
            ctx.beginPath();
            ctx.ellipse(x, y, currentSize * 0.8, currentSize * 0.3, 0, 0, Math.PI * 2);
            const baseGradient = ctx.createRadialGradient(x, y, 0, x, y, currentSize * 0.8);
            baseGradient.addColorStop(0, `rgba(139, 92, 246, ${0.6 * pulse})`);
            baseGradient.addColorStop(1, `rgba(79, 70, 229, ${0.3 * pulse})`);
            ctx.fillStyle = baseGradient;
            ctx.fill();

            // Main crystal trunk with facets
            const trunkHeight = currentSize * 2;
            const trunkWidth = currentSize * 0.6;

            // Multiple crystal facets
            for (let i = 0; i < 6; i++) {
                const angle = (i * Math.PI) / 3;
                const facetX = x + Math.cos(angle) * (trunkWidth * 0.3);
                const facetY = y - trunkHeight * 0.5;

                ctx.beginPath();
                ctx.moveTo(facetX, y);
                ctx.lineTo(facetX + Math.cos(angle) * (trunkWidth * 0.2), facetY);
                ctx.lineTo(x, y - trunkHeight);
                ctx.lineTo(facetX - Math.cos(angle) * (trunkWidth * 0.2), facetY);
                ctx.closePath();

                const facetGradient = ctx.createLinearGradient(facetX, y, x, y - trunkHeight);
                const brightness = 0.5 + Math.sin(animationTime + angle) * 0.3;
                facetGradient.addColorStop(0, `rgba(139, 92, 246, ${brightness * pulse})`);
                facetGradient.addColorStop(0.5, `rgba(167, 139, 250, ${(brightness + 0.2) * pulse})`);
                facetGradient.addColorStop(1, `rgba(196, 181, 253, ${(brightness + 0.4) * pulse})`);

                ctx.fillStyle = facetGradient;
                ctx.fill();

                // Crystal edges with glow
                ctx.strokeStyle = `rgba(255, 255, 255, ${0.8 * pulse})`;
                ctx.lineWidth = 1;
                ctx.shadowColor = 'rgba(167, 139, 250, 0.8)';
                ctx.shadowBlur = 5;
                ctx.stroke();
                ctx.shadowBlur = 0;
            }

            // Crystal tip with intense glow
            ctx.beginPath();
            ctx.arc(x, y - trunkHeight, currentSize * 0.2, 0, Math.PI * 2);
            const tipGradient = ctx.createRadialGradient(x, y - trunkHeight, 0, x, y - trunkHeight, currentSize * 0.2);
            tipGradient.addColorStop(0, `rgba(255, 255, 255, ${0.9 * pulse})`);
            tipGradient.addColorStop(1, `rgba(196, 181, 253, ${0.6 * pulse})`);
            ctx.fillStyle = tipGradient;
            ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
            ctx.shadowBlur = 15;
            ctx.fill();
            ctx.shadowBlur = 0;

            // Energy wisps rising from crystal
            for (let i = 0; i < 2; i++) {
                const wispY = y - trunkHeight - 20 - (animationTime * 20 + i * 50) % 100;
                const wispX = x + Math.sin(animationTime + i) * 10;

                if (wispY > y - trunkHeight - 120) {
                    ctx.beginPath();
                    ctx.arc(wispX, wispY, 2, 0, Math.PI * 2);
                    const wispAlpha = 1 - ((y - trunkHeight - 20 - wispY) / 100);
                    ctx.fillStyle = `rgba(196, 181, 253, ${wispAlpha * 0.8})`;
                    ctx.fill();
                }
            }
        };
        
        const drawEnhancedGarden = (x, y, size, sprite) => {
            const pulse = Math.sin(animationTime * sprite.pulseSpeed + sprite.animationOffset) * 0.1 + 1;

            // Garden base with organic shape
            ctx.beginPath();
            for (let i = 0; i <= 16; i++) {
                const angle = (i / 16) * Math.PI * 2;
                const radius = size * (0.8 + Math.sin(angle * 3 + animationTime) * 0.2) * pulse;
                const px = x + Math.cos(angle) * radius;
                const py = y + Math.sin(angle) * radius * 0.6;

                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();

            const gardenGradient = ctx.createRadialGradient(x, y, 0, x, y, size);
            gardenGradient.addColorStop(0, `rgba(34, 197, 94, ${0.3 * pulse})`);
            gardenGradient.addColorStop(0.5, `rgba(22, 163, 74, ${0.2 * pulse})`);
            gardenGradient.addColorStop(1, `rgba(21, 128, 61, ${0.1 * pulse})`);
            ctx.fillStyle = gardenGradient;
            ctx.fill();

            // Magical flowers with different types
            const flowerTypes = [
                { color: '#fde047', glow: '#facc15', size: 4 }, // Golden
                { color: '#a78bfa', glow: '#8b5cf6', size: 3 }, // Purple
                { color: '#f472b6', glow: '#ec4899', size: 3.5 }, // Pink
                { color: '#34d399', glow: '#10b981', size: 3 }  // Emerald
            ];

            // Static flower positions based on sprite properties
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2 + sprite.animationOffset;
                const distance = (size * 0.6) + Math.sin(animationTime * 0.5 + i) * (size * 0.2);
                const flowerX = x + Math.cos(angle) * distance;
                const flowerY = y + Math.sin(angle) * distance * 0.6;

                const flowerType = flowerTypes[i % flowerTypes.length];
                const flowerPulse = Math.sin(animationTime * 2 + i) * 0.3 + 1;

                // Flower glow
                ctx.beginPath();
                ctx.arc(flowerX, flowerY, flowerType.size * flowerPulse * 1.5, 0, Math.PI * 2);
                ctx.fillStyle = flowerType.glow + '40'; // 25% opacity
                ctx.fill();

                // Flower petals
                for (let p = 0; p < 5; p++) {
                    const petalAngle = (p / 5) * Math.PI * 2 + animationTime * 0.1;
                    const petalX = flowerX + Math.cos(petalAngle) * flowerType.size * 0.8;
                    const petalY = flowerY + Math.sin(petalAngle) * flowerType.size * 0.8;

                    ctx.beginPath();
                    ctx.arc(petalX, petalY, flowerType.size * 0.6 * flowerPulse, 0, Math.PI * 2);
                    ctx.fillStyle = flowerType.color;
                    ctx.shadowColor = flowerType.glow;
                    ctx.shadowBlur = 8;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }

                // Flower center
                ctx.beginPath();
                ctx.arc(flowerX, flowerY, flowerType.size * 0.3, 0, Math.PI * 2);
                ctx.fillStyle = '#fbbf24';
                ctx.shadowColor = '#f59e0b';
                ctx.shadowBlur = 5;
                ctx.fill();
                ctx.shadowBlur = 0;
            }

            // Floating pollen particles
            for (let i = 0; i < 3; i++) {
                const pollenX = x + Math.sin(animationTime * 0.8 + i) * size * 0.8;
                const pollenY = y + Math.cos(animationTime * 0.6 + i) * size * 0.4 - 10;

                ctx.beginPath();
                ctx.arc(pollenX, pollenY, 1.5, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(251, 191, 36, ${0.6 + Math.sin(animationTime * 2 + i) * 0.4})`;
                ctx.fill();
            }
        };

        const drawEnergyFlows = () => {
            // Draw energy connections between structures
            const domes = gameState.villageGrid.filter(item => item.type === 'dome');
            const crystals = gameState.villageGrid.filter(item => item.type === 'crystal_tree');

            // Energy flows from crystals to domes (insight to energy conversion)
            crystals.forEach(crystal => {
                domes.forEach(dome => {
                    const distance = Math.sqrt((dome.x - crystal.x) ** 2 + (dome.y - crystal.y) ** 2);
                    if (distance < 200) { // Only connect nearby structures
                        drawEnergyBeam(crystal.x, crystal.y - crystal.size, dome.x, dome.y, 'insight');
                    }
                });
            });
        };

        const drawEnergyBeam = (x1, y1, x2, y2, type) => {
            const flowSpeed = animationTime * 3;
            const color = type === 'insight' ? 'rgba(167, 139, 250, ' : 'rgba(34, 197, 94, ';

            // Main beam
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.strokeStyle = color + '0.3)';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Animated energy particles along the beam
            const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
            const steps = Math.floor(distance / 20);

            for (let i = 0; i < steps; i++) {
                const progress = (i / steps + flowSpeed * 0.1) % 1;
                const x = x1 + (x2 - x1) * progress;
                const y = y1 + (y2 - y1) * progress;

                ctx.beginPath();
                ctx.arc(x, y, 2, 0, Math.PI * 2);
                ctx.fillStyle = color + (0.8 * (1 - progress)) + ')';
                ctx.shadowColor = color + '0.8)';
                ctx.shadowBlur = 5;
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        };

        const drawAmbientEffects = () => {
            // Ambient magical aura around the entire sanctuary
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const maxRadius = Math.max(canvas.width, canvas.height) * 0.6;

            const auraGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, maxRadius);
            auraGradient.addColorStop(0, 'rgba(167, 139, 250, 0)');
            auraGradient.addColorStop(0.7, `rgba(167, 139, 250, ${0.05 + Math.sin(animationTime * 0.5) * 0.02})`);
            auraGradient.addColorStop(1, 'rgba(75, 0, 130, 0)');

            ctx.fillStyle = auraGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Floating light orbs
            for (let i = 0; i < 5; i++) {
                const orbX = centerX + Math.sin(animationTime * 0.3 + i) * (canvas.width * 0.3);
                const orbY = centerY + Math.cos(animationTime * 0.2 + i) * (canvas.height * 0.2);
                const orbSize = 3 + Math.sin(animationTime + i) * 1;

                ctx.beginPath();
                ctx.arc(orbX, orbY, orbSize, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(196, 181, 253, ${0.4 + Math.sin(animationTime * 2 + i) * 0.2})`;
                ctx.shadowColor = 'rgba(196, 181, 253, 0.8)';
                ctx.shadowBlur = 10;
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        };

        // --- TDD API Key Management ---
        const getApiKey = () => {
            return localStorage.getItem('grok_api_key') || '';
        };

        const saveApiKey = (key) => {
            if (key && key.trim() && key.length >= 10) {
                localStorage.setItem('grok_api_key', key.trim());
                return true;
            }
            return false;
        };

        const showApiKeyPopup = () => {
            const popup = document.getElementById('api-key-popup');
            const input = document.getElementById('api-key-input');
            const error = document.getElementById('api-key-error');

            popup.classList.remove('hidden');
            input.focus();
            error.classList.add('hidden');
            error.textContent = '';
        };

        const hideApiKeyPopup = () => {
            const popup = document.getElementById('api-key-popup');
            const input = document.getElementById('api-key-input');

            popup.classList.add('hidden');
            input.value = '';
        };

        const showApiKeyError = (message) => {
            const error = document.getElementById('api-key-error');
            error.textContent = message;
            error.classList.remove('hidden');
        };

        // --- TDD Task 1: Unit Movement and Drag-and-Drop System ---

        const updateUnitMovement = (deltaTime) => {
            gameState.villageGrid.forEach(unit => {
                if (!unit.movable) return;

                // Auto-wandering for dreamers
                if (unit.type === 'dreamer' && !dragState.isDragging) {
                    updateWandering(unit, animationTime);
                }

                // Smooth movement towards target
                const dx = unit.targetX - unit.x;
                const dy = unit.targetY - unit.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 1) {
                    const speed = 50; // pixels per second
                    const moveDistance = speed * deltaTime;
                    const ratio = Math.min(moveDistance / distance, 1);

                    unit.x += dx * ratio;
                    unit.y += dy * ratio;
                    unit.vx = dx * ratio / deltaTime;
                    unit.vy = dy * ratio / deltaTime;
                } else {
                    unit.vx = 0;
                    unit.vy = 0;
                }
            });
        };

        const updateWandering = (unit, time) => {
            const wanderSpeed = 0.3;
            const wanderRadius = unit.wanderRadius || 30;

            unit.targetX = unit.wanderCenter.x + Math.sin(time * wanderSpeed + unit.wanderPhase) * wanderRadius;
            unit.targetY = unit.wanderCenter.y + Math.cos(time * wanderSpeed + unit.wanderPhase) * wanderRadius;

            // Keep within canvas bounds
            unit.targetX = Math.max(50, Math.min(canvas.width - 50, unit.targetX));
            unit.targetY = Math.max(50, Math.min(canvas.height - 50, unit.targetY));
        };

        const getUnitAtPosition = (x, y) => {
            for (let i = gameState.villageGrid.length - 1; i >= 0; i--) {
                const unit = gameState.villageGrid[i];
                const dx = x - unit.x;
                const dy = y - unit.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance <= unit.size) {
                    return unit;
                }
            }
            return null;
        };

        const getCanvasCoordinates = (event) => {
            const rect = canvas.getBoundingClientRect();
            return {
                x: event.clientX - rect.left,
                y: event.clientY - rect.top
            };
        };

        const updateMovementTrails = () => {
            gameState.villageGrid.forEach(unit => {
                if (!unit.movable || (Math.abs(unit.vx) < 1 && Math.abs(unit.vy) < 1)) return;

                const trailKey = unit.id;
                if (!movementTrails[trailKey]) {
                    movementTrails[trailKey] = [];
                }

                movementTrails[trailKey].push({
                    x: unit.x,
                    y: unit.y,
                    timestamp: Date.now(),
                    alpha: 1.0
                });

                // Keep only recent trail points
                const maxAge = 1500;
                const now = Date.now();
                movementTrails[trailKey] = movementTrails[trailKey].filter(point =>
                    now - point.timestamp < maxAge
                );

                // Update alpha based on age
                movementTrails[trailKey].forEach(point => {
                    const age = now - point.timestamp;
                    point.alpha = Math.max(0, 1 - (age / maxAge));
                });
            });
        };

        const drawMovementTrails = () => {
            Object.values(movementTrails).forEach(trail => {
                if (trail.length < 2) return;

                ctx.save();
                ctx.strokeStyle = 'rgba(138, 92, 246, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();

                for (let i = 0; i < trail.length; i++) {
                    const point = trail[i];
                    ctx.globalAlpha = point.alpha * 0.5;

                    if (i === 0) {
                        ctx.moveTo(point.x, point.y);
                    } else {
                        ctx.lineTo(point.x, point.y);
                    }
                }

                ctx.stroke();
                ctx.restore();
            });
        };

        const drawMovableUnit = (unit, isHovered, isDragged) => {
            ctx.save();

            // Visual feedback for interaction states
            let scale = 1.0;
            let alpha = 1.0;
            let glowIntensity = 0.8;

            if (isDragged) {
                scale = 1.2;
                alpha = 0.9;
                glowIntensity = 1.2;
            } else if (isHovered) {
                scale = 1.1;
                glowIntensity = 1.0;
            }

            ctx.globalAlpha = alpha;
            ctx.translate(unit.x, unit.y);
            ctx.scale(scale, scale);

            // Get unit color and create variations
            let baseColor, glowColor;
            if (unit.type === 'dreamer') {
                baseColor = '#8B5CF6';
                glowColor = '#A78BFA';
            } else if (unit.type === 'weaver') {
                baseColor = '#10B981';
                glowColor = '#34D399';
            } else if (unit.type === 'stellarNomads') {
                baseColor = '#F59E0B';
                glowColor = '#FBBF24';
            } else {
                baseColor = '#F59E0B';
                glowColor = '#FBBF24';
            }

            const pulse = 1 + Math.sin(animationTime * 2 + (unit.animationOffset || 0)) * 0.15;
            const currentSize = unit.size * pulse;

            // Layer 1: Outer glow (same quality for all units)
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            ctx.shadowColor = glowColor;
            ctx.shadowBlur = 25 * glowIntensity;
            ctx.beginPath();
            ctx.arc(0, 0, currentSize * 1.8, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(${parseInt(glowColor.slice(1,3), 16)}, ${parseInt(glowColor.slice(3,5), 16)}, ${parseInt(glowColor.slice(5,7), 16)}, 0.2)`;
            ctx.fill();
            ctx.restore();

            // Layer 2: Main body with radial gradient
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize);
            const r = parseInt(baseColor.slice(1,3), 16);
            const g = parseInt(baseColor.slice(3,5), 16);
            const b = parseInt(baseColor.slice(5,7), 16);

            gradient.addColorStop(0, `rgba(${Math.min(255, r + 40)}, ${Math.min(255, g + 40)}, ${Math.min(255, b + 40)}, 1.0)`);
            gradient.addColorStop(0.6, `rgba(${r}, ${g}, ${b}, 0.9)`);
            gradient.addColorStop(1, `rgba(${Math.max(0, r - 20)}, ${Math.max(0, g - 20)}, ${Math.max(0, b - 20)}, 0.7)`);

            ctx.shadowColor = glowColor;
            ctx.shadowBlur = 15 * glowIntensity;
            ctx.beginPath();
            ctx.arc(0, 0, currentSize, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();

            // Layer 3: Inner highlight
            ctx.save();
            ctx.globalCompositeOperation = 'overlay';
            const highlightGradient = ctx.createRadialGradient(-currentSize * 0.3, -currentSize * 0.3, 0, 0, 0, currentSize * 0.8);
            highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
            highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.beginPath();
            ctx.arc(0, 0, currentSize * 0.7, 0, Math.PI * 2);
            ctx.fillStyle = highlightGradient;
            ctx.fill();
            ctx.restore();

            // Layer 4: Sparkle effects for all units
            if (Math.random() < 0.05) {
                for (let i = 0; i < 3; i++) {
                    const sparkleX = (Math.random() - 0.5) * currentSize * 1.5;
                    const sparkleY = (Math.random() - 0.5) * currentSize * 1.5;
                    const sparkleSize = Math.random() * 2 + 1;

                    ctx.save();
                    ctx.globalCompositeOperation = 'screen';
                    ctx.shadowColor = glowColor;
                    ctx.shadowBlur = 8;
                    ctx.beginPath();
                    ctx.arc(sparkleX, sparkleY, sparkleSize, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.fill();
                    ctx.restore();
                }
            }

            ctx.shadowBlur = 0;
            ctx.restore();
        };

        // --- Grok API Integration with Popup ---
        async function callGrok(prompt, button, systemPrompt = "") {
            if (button) {
                button.disabled = true;
                button.classList.add('loading');
                button.innerHTML = 'AI is thinking...';
            }

            try {
                const apiKey = getApiKey();
                if (!apiKey) {
                    showApiKeyPopup();
                    throw new Error("API key required - popup shown");
                }

                const apiUrl = "https://api.x.ai/v1/chat/completions";
                const messages = [];

                if (systemPrompt) {
                    messages.push({ role: "system", content: systemPrompt });
                }
                messages.push({ role: "user", content: prompt });

                const payload = {
                    messages: messages,
                    model: "grok-beta",
                    stream: false,
                    temperature: 0.8
                };

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    throw new Error(`Grok API call failed: ${response.status} ${response.statusText}`);
                }

                const result = await response.json();
                return result.choices?.[0]?.message?.content || "The cosmic winds carry no clear message...";

            } catch (error) {
                console.error("Grok API Error:", error);
                if (error.message.includes("API key")) {
                    return "The Grok API key must be configured to access cosmic wisdom. Set your API key in the code.";
                }
                return "The aetheric connection is disrupted. The cosmic network seems unreachable.";
            } finally {
                if (button) {
                    button.disabled = false;
                    button.classList.remove('loading');
                    if(button.id === 'seasonal-vision-btn') button.innerHTML = '‚ú® Get Resonant Vision';
                    if(button.id === 'advisor-btn') button.innerHTML = 'üìú Ask Advisor';
                }
            }
        }
        async function getSeasonalVision() {
            const systemPrompt = "You are a mystical storyteller for Resonant Sanctuary: The Weaver, a cosmic incremental game. Create poetic, ethereal visions about the sanctuary's future or cosmic events. Use mystical language and keep responses to 2-3 sentences.";

            const prompt = `Current sanctuary state: Energy production ${gameState.energyPerSecond.toFixed(1)}/s, Insight production ${gameState.insightPerSecond.toFixed(1)}/s. The sanctuary houses ${gameState.units.dreamers} dreamers and ${gameState.units.weavers} weavers, with ${gameState.harmony.toFixed(1)}% harmony. Provide a mystical seasonal vision or cosmic forecast.`;

            const story = await callGrok(prompt, seasonalVisionBtn, systemPrompt);
            log(`‚ú® ${story}`, 'grok');
        }

        async function getAdvisorInsight() {
            const systemPrompt = "You are the Cosmic Advisor for Resonant Sanctuary: The Weaver. Provide brief, mystical advice using cosmic language. Always start responses with 'The sanctuary whispers...' and keep under 30 words. Focus on actionable game advice.";

            const prompt = `Current stats: Energy: ${formatNumber(gameState.energy)}, Insight: ${formatNumber(gameState.insight)}, Energy/s: ${formatNumber(gameState.energyPerSecond)}, Insight/s: ${formatNumber(gameState.insightPerSecond)}, Harmony: ${gameState.harmony.toFixed(1)}%. What should the player focus on next?`;

            const advice = await callGrok(prompt, advisorBtn, systemPrompt);
            log(`üìú ${advice}`, 'grok');
        }

        // --- Game Logic ---
        window.createUnit = (key) => {
            const unitConf = unitsConfig[key];
            const cost = gameState.unitCosts[key];
            if (gameState[unitConf.costResource] >= cost) {
                gameState[unitConf.costResource] -= cost;
                gameState.units[key]++;
                gameState.unitCosts[key] *= 1.15;
                if (key === 'dreamers') addSprite('crystal_tree');
                if (key === 'weavers') addSprite('dome');
                log(`A new ${unitConf.name} joins the sanctuary.`, 'success');

                // TDD Task 1: Add movable sprite for the new unit
                addSprite(key, 1);

                // TDD Fix: Don't immediately re-render UI, let game loop handle it
            }
        };

        window.upgradeNode = (key) => {
            const nodeConf = nodesConfig[key];
            const cost = gameState.nodeCosts[key];
            if (gameState[nodeConf.costResource] >= cost) {
                gameState[nodeConf.costResource] -= cost;
                gameState.nodes[key]++;
                gameState.nodeCosts[key] *= 2.5;
                if (nodeConf.harmony) {
                    gameState.harmony = Math.min(100, gameState.harmony + nodeConf.harmony);
                }
                if (key === 'sustenance') addSprite('garden');
                log(`Attuned the ${nodeConf.name}. Its resonance grows stronger.`, 'success');
                // TDD Fix: Don't immediately re-render UI, let game loop handle it
            }
        };
        
        const updateGameState = (delta) => {
            // Calculate production per second
            let energyPerSecond = gameState.units.weavers * unitsConfig.weavers.baseEnergy;
            let insightPerSecond = gameState.units.dreamers * unitsConfig.dreamers.baseInsight;

            // Apply node bonuses
            let costMultiplier = 1;
            energyPerSecond *= Math.pow(nodesConfig.energy.multiplier, gameState.nodes.energy);
            insightPerSecond *= Math.pow(nodesConfig.sustenance.multiplier, gameState.nodes.sustenance);
            const cohesionBonus = Math.pow(nodesConfig.cohesion.multiplier, gameState.nodes.cohesion);
            energyPerSecond *= cohesionBonus;
            insightPerSecond *= cohesionBonus;
            costMultiplier *= Math.pow(nodesConfig.cycling.multiplier, gameState.nodes.cycling);

            // Update unit costs based on multiplier (visual only, actual cost is in gameState)
            // This is a simplification; a more robust model would adjust the base cost.

            gameState.energyPerSecond = energyPerSecond;
            gameState.insightPerSecond = insightPerSecond;

            // Add resources
            gameState.energy += energyPerSecond * delta;
            gameState.insight += insightPerSecond * delta;
        };

        let lastUIUpdate = 0;
        const gameLoop = () => {
            const now = Date.now();
            const delta = (now - gameState.lastUpdate) / 1000; // Time in seconds

            updateGameState(delta);

            // TDD Fix: Update UI less frequently to prevent button blinking
            if (now - lastUIUpdate > 500) { // Increased from 100ms to 500ms
                renderUI();
                lastUIUpdate = now;
            }
            drawSanctuary();

            gameState.lastUpdate = now;
            requestAnimationFrame(gameLoop);
        };

        // --- TDD Test Suite ---
        const runTests = () => {
            console.log("--- Running TDD Test Suite ---");

            // Test 1: Initial game state
            const initialState = { ...gameState };
            console.assert(initialState.energy === 10, "Test 1.1 Failed: Initial energy should be 10.");
            console.assert(initialState.insight === 0, "Test 1.2 Failed: Initial insight should be 0.");
            console.assert(initialState.harmony === 50, "Test 1.3 Failed: Initial harmony should be 50.");

            // Test 1.4: Initial energy is displayed in the UI
            renderUI();
            const energyText = document.querySelector('#stats-bar .stat-card:nth-child(1) .text-xl').textContent;
            console.assert(parseFloat(energyText) === 10.0, "Test 1.4 Failed: Initial energy displayed should be 10.0.");

            // Test 2: Composting upgrade increases harmony
            const initialHarmony = initialState.harmony;
            gameState.insight = 200; // Ensure we can afford the upgrade
            upgradeNode('cycling');
            console.assert(gameState.harmony > initialHarmony, "Test 2.1 Failed: Composting upgrade should increase harmony.");

            // Test 3: Creating a unit deducts resources
            const initialEnergy = gameState.energy;
            createUnit('dreamers');
            console.assert(gameState.energy < initialEnergy, "Test 3.1 Failed: Creating a dreamer should deduct energy.");

            console.log("--- TDD Test Suite Finished ---");
        };

        // --- Initialization ---
        const init = () => {
            log("Welcome, Weaver. The sanctuary awakens with your first Dreamer and Weaver.", "success");
            log("üîë Grok API integration ready - key will be requested when needed", "info");

            // Initialize sprites
            addSprite('dome', 1);
            addSprite('crystal_tree', 1);

            // Initialize event listeners
            advisorBtn.addEventListener('click', getAdvisorInsight);
            seasonalVisionBtn.addEventListener('click', getSeasonalVision);

            // TDD API Key Popup Event Listeners
            const saveKeyBtn = document.getElementById('save-api-key');
            const cancelKeyBtn = document.getElementById('cancel-api-key');
            const apiKeyInput = document.getElementById('api-key-input');

            saveKeyBtn.addEventListener('click', () => {
                const key = apiKeyInput.value.trim();

                if (!key) {
                    showApiKeyError('Please enter an API key');
                    return;
                }

                if (key.length < 10) {
                    showApiKeyError('API key seems too short. Please check your key.');
                    return;
                }

                if (key.includes(' ')) {
                    showApiKeyError('API key should not contain spaces');
                    return;
                }

                if (saveApiKey(key)) {
                    hideApiKeyPopup();
                    log('üîë Grok API key saved successfully! You can now access cosmic wisdom.', 'success');
                } else {
                    showApiKeyError('Failed to save API key. Please try again.');
                }
            });

            cancelKeyBtn.addEventListener('click', () => {
                hideApiKeyPopup();
            });

            // Handle Enter key in API key input
            apiKeyInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    saveKeyBtn.click();
                }
            });

            // Handle Escape key to close popup
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    const popup = document.getElementById('api-key-popup');
                    if (!popup.classList.contains('hidden')) {
                        hideApiKeyPopup();
                    }
                }
            });

            // TDD Task 1: Mouse event listeners for drag-and-drop
            canvas.addEventListener('mousedown', (e) => {
                const coords = getCanvasCoordinates(e);
                const unit = getUnitAtPosition(coords.x, coords.y);

                if (unit && unit.movable) {
                    dragState.isDragging = true;
                    dragState.draggedUnit = unit;
                    dragState.dragOffsetX = coords.x - unit.x;
                    dragState.dragOffsetY = coords.y - unit.y;

                    // Stop auto-wandering while dragging
                    unit.wanderCenter = { x: unit.x, y: unit.y };

                    canvas.style.cursor = 'grabbing';
                }
            });

            canvas.addEventListener('mousemove', (e) => {
                const coords = getCanvasCoordinates(e);

                if (dragState.isDragging && dragState.draggedUnit) {
                    // Update dragged unit position
                    dragState.draggedUnit.targetX = coords.x - dragState.dragOffsetX;
                    dragState.draggedUnit.targetY = coords.y - dragState.dragOffsetY;

                    // Keep within canvas bounds
                    dragState.draggedUnit.targetX = Math.max(50, Math.min(canvas.width - 50, dragState.draggedUnit.targetX));
                    dragState.draggedUnit.targetY = Math.max(50, Math.min(canvas.height - 50, dragState.draggedUnit.targetY));
                } else {
                    // Update hover state
                    const unit = getUnitAtPosition(coords.x, coords.y);
                    dragState.hoveredUnit = unit;

                    if (unit && unit.movable) {
                        canvas.style.cursor = 'grab';
                    } else {
                        canvas.style.cursor = 'default';
                    }
                }
            });

            canvas.addEventListener('mouseup', (e) => {
                if (dragState.isDragging && dragState.draggedUnit) {
                    // Update wander center to new position
                    dragState.draggedUnit.wanderCenter = {
                        x: dragState.draggedUnit.x,
                        y: dragState.draggedUnit.y
                    };

                    log(`Moved ${dragState.draggedUnit.type} to new location`, 'info');
                }

                dragState.isDragging = false;
                dragState.draggedUnit = null;
                dragState.dragOffsetX = 0;
                dragState.dragOffsetY = 0;
                canvas.style.cursor = 'default';
            });

            canvas.addEventListener('mouseleave', (e) => {
                dragState.hoveredUnit = null;
                canvas.style.cursor = 'default';
            });

            runTests(); // Run TDD tests on startup
            gameLoop();
        };

        init();
    </script>
</body>
</html>
