<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Resonant Sanctuary: The Weaver</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            background-color: #0c0a1e; /* Deep cosmic blue */
        }
        .stat-card {
            background-color: rgba(18, 16, 46, 0.7); /* Dark blue/purple */
            backdrop-filter: blur(10px);
            transition: all 0.2s ease-in-out;
            border: 1px solid rgba(76, 71, 128, 0.5);
        }
        .module-card {
            background-color: #1c1944; /* Muted cosmic blue */
            transition: all 0.2s ease-in-out;
            border: 1px solid rgba(76, 71, 128, 0.5);
        }
        .unit-card {
             background-color: #2a275c;
        }
        .log-panel {
            height: 150px;
            background-color: rgba(10, 8, 28, 0.9);
            border-top: 1px solid rgba(76, 71, 128, 0.5);
        }
        canvas {
            border-radius: 0.75rem;
        }
        .grok-btn.loading, .grok-btn:disabled, button:disabled {
            cursor: not-allowed;
            background-color: #4a5568;
            opacity: 0.7;
        }

        /* TDD Fix: Custom scrollbar for log output */
        #log-output {
            scrollbar-width: thin;
            scrollbar-color: #4c1d95 #1e1b4b;
        }
        #log-output::-webkit-scrollbar {
            width: 8px;
        }
        #log-output::-webkit-scrollbar-track {
            background: #1e1b4b;
            border-radius: 4px;
        }
        #log-output::-webkit-scrollbar-thumb {
            background: #4c1d95;
            border-radius: 4px;
        }
        #log-output::-webkit-scrollbar-thumb:hover {
            background: #5b21b6;
        }

        /* Ensure log entries don't break layout */
        .log-entry {
            word-wrap: break-word;
            line-height: 1.4;
            margin-bottom: 0.25rem;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .log-entry {
            animation: fadeIn 0.5s ease-out;
        }

        /* Improved UI Styles */
        .tab-btn {
            color: #9CA3AF;
            background: transparent;
            border: none;
            cursor: pointer;
        }
        .tab-btn.active {
            color: #FFFFFF;
            background: #4F46E5;
        }
        .tab-btn:hover:not(.active) {
            color: #E5E7EB;
            background: #374151;
        }
        .tab-content {
            animation: fadeIn 0.2s ease-in-out;
        }

        /* Compact Stats */
        .stat-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }
        .stat-card {
            background: linear-gradient(135deg, rgba(79, 70, 229, 0.15), rgba(99, 102, 241, 0.05));
            border: 1px solid rgba(99, 102, 241, 0.3);
            border-radius: 6px;
            padding: 6px 8px;
            text-align: center;
            transition: all 0.2s ease;
            cursor: pointer;
        }
        .stat-card:hover {
            border-color: rgba(99, 102, 241, 0.5);
            transform: translateY(-1px);
            background: linear-gradient(135deg, rgba(79, 70, 229, 0.2), rgba(99, 102, 241, 0.1));
        }
        .stat-value {
            font-size: 1.1rem;
            font-weight: bold;
            color: #FFFFFF;
            line-height: 1;
        }
        .stat-label {
            font-size: 0.7rem;
            color: #A78BFA;
            margin-top: 2px;
            line-height: 1;
        }
        .stat-rate {
            font-size: 0.6rem;
            color: #10B981;
            margin-top: 1px;
            line-height: 1;
        }

        /* Resource change animations */
        .resource-increase {
            animation: resourcePulse 0.5s ease-out;
        }
        @keyframes resourcePulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); color: #10B981; }
            100% { transform: scale(1); }
        }

        /* Tooltip styles */
        .tooltip {
            position: relative;
        }
        .tooltip:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
            white-space: nowrap;
            z-index: 1000;
            pointer-events: none;
        }
    </style>
</head>
<body class="text-indigo-100 flex flex-col h-screen">

    <!-- Top Bar -->
    <header class="w-full p-4 bg-[#1c1944] border-b border-indigo-900 shadow-lg z-10">
        <h1 class="text-2xl font-bold text-white">Resonant Sanctuary: The Weaver</h1>
    </header>

    <!-- Main Content -->
    <div class="flex flex-1 overflow-hidden">
        
        <!-- Improved Left Panel: Tabbed Interface -->
        <aside class="w-80 p-3 bg-[#1c1944] border-r border-indigo-900 flex flex-col">
            <!-- Tab Navigation -->
            <div class="flex mb-3 bg-indigo-900/30 rounded-lg p-1">
                <button id="tab-units" class="tab-btn flex-1 py-2 px-3 text-sm font-medium rounded-md transition-all active" onclick="switchTab('units')" title="Units (Hotkey: 1)">
                    ‚ö° Units
                </button>
                <button id="tab-upgrades" class="tab-btn flex-1 py-2 px-3 text-sm font-medium rounded-md transition-all" onclick="switchTab('upgrades')" title="Upgrades (Hotkey: 2)">
                    üîÆ Upgrades
                </button>
                <button id="tab-beings" class="tab-btn flex-1 py-2 px-3 text-sm font-medium rounded-md transition-all" onclick="switchTab('beings')" title="Intelligent Beings (Hotkey: 3)">
                    üß† Beings
                </button>
                <button id="tab-ai" class="tab-btn flex-1 py-2 px-3 text-sm font-medium rounded-md transition-all" onclick="switchTab('ai')" title="Conversational AI (Hotkey: 4)">
                    üí¨ AI
                </button>
            </div>

            <!-- Tab Content -->
            <div class="flex-1 overflow-y-auto">
                <!-- Units Tab -->
                <div id="content-units" class="tab-content">
                    <div id="units-panel" class="space-y-2">
                        <!-- Unit creation cards will be injected here -->
                    </div>
                </div>

                <!-- Upgrades Tab -->
                <div id="content-upgrades" class="tab-content hidden">
                    <div id="modules-panel" class="space-y-2">
                        <!-- Module cards will be injected here -->
                    </div>
                </div>

                <!-- Intelligent Beings Tab -->
                <div id="content-beings" class="tab-content hidden">
                    <div class="space-y-2">
                        <button onclick="spawnIntelligentCreature('cosmicSage')"
                                class="w-full p-2 rounded bg-purple-600 hover:bg-purple-700 text-white text-sm transition-colors">
                            üßô‚Äç‚ôÇÔ∏è Cosmic Sage <span class="float-right text-xs opacity-75">Teaches</span>
                        </button>

                        <button onclick="spawnIntelligentCreature('voidExplorer')"
                                class="w-full p-2 rounded bg-gray-600 hover:bg-gray-700 text-white text-sm transition-colors">
                            üåå Void Explorer <span class="float-right text-xs opacity-75">Explores</span>
                        </button>

                        <button onclick="spawnIntelligentCreature('harmonyKeeper')"
                                class="w-full p-2 rounded bg-green-600 hover:bg-green-700 text-white text-sm transition-colors">
                            ‚ú® Harmony Keeper <span class="float-right text-xs opacity-75">Heals</span>
                        </button>

                        <div class="text-xs text-indigo-300 mt-2 p-2 bg-indigo-900/20 rounded">
                            <strong>Active:</strong> <span id="creature-count">0</span>
                        </div>
                    </div>
                </div>

                <!-- Conversational AI Tab -->
                <div id="content-ai" class="tab-content hidden">
                    <div class="space-y-2">
                        <button onclick="spawnConversationalUnit('philosopherDreamer')"
                                class="w-full p-2 rounded bg-indigo-600 hover:bg-indigo-700 text-white text-sm transition-colors">
                            üßô‚Äç‚ôÇÔ∏è Philosopher <span class="float-right text-xs opacity-75">Wisdom</span>
                        </button>

                        <button onclick="spawnConversationalUnit('artisticWeaver')"
                                class="w-full p-2 rounded bg-pink-600 hover:bg-pink-700 text-white text-sm transition-colors">
                            üé® Artist <span class="float-right text-xs opacity-75">Beauty</span>
                        </button>

                        <button onclick="spawnConversationalUnit('curiousExplorer')"
                                class="w-full p-2 rounded bg-emerald-600 hover:bg-emerald-700 text-white text-sm transition-colors">
                            üîç Explorer <span class="float-right text-xs opacity-75">Discovery</span>
                        </button>

                        <div class="text-xs text-purple-300 mt-2 p-2 bg-purple-900/20 rounded">
                            <strong>Conversational:</strong> <span id="conversational-count">0</span><br>
                            <em>Click beings to chat</em>
                        </div>

                        <hr class="border-indigo-700 my-3">

                        <button id="advisor-btn" class="grok-btn w-full bg-blue-600 hover:bg-blue-700 text-white text-sm py-2 px-3 rounded transition-colors">
                            üìú Ask Advisor
                        </button>
                        <button id="seasonal-vision-btn" class="grok-btn w-full bg-purple-600 hover:bg-purple-700 text-white text-sm py-2 px-3 rounded transition-colors">
                            ‚ú® Get Vision
                        </button>
                    </div>
                </div>
            </div>
        </aside>

        <!-- Center Panel: Village View & Compact Stats -->
        <main class="flex-1 flex flex-col p-3">
            <!-- Compact Stats Bar -->
            <div id="stats-bar" class="mb-3">
                <div class="stat-grid">
                    <div class="stat-card tooltip" data-tooltip="Energy - Used to create Dreamers (Hotkey: D)">
                        <div class="stat-value" id="energy">20</div>
                        <div class="stat-label">Energy</div>
                        <div class="stat-rate">+<span id="energy-rate">0.0</span>/s</div>
                    </div>
                    <div class="stat-card tooltip" data-tooltip="Insight - Used to create Weavers (Hotkey: W)">
                        <div class="stat-value" id="insight">5</div>
                        <div class="stat-label">Insight</div>
                        <div class="stat-rate">+<span id="insight-rate">0.0</span>/s</div>
                    </div>
                    <div class="stat-card tooltip" data-tooltip="Harmony - Affects all production efficiency">
                        <div class="stat-value" id="harmony">75</div>
                        <div class="stat-label">Harmony</div>
                        <div class="stat-rate">Stable</div>
                    </div>
                    <div class="stat-card tooltip" data-tooltip="Inspiration - Generated by unit interactions">
                        <div class="stat-value" id="inspiration">0</div>
                        <div class="stat-label">Inspiration</div>
                        <div class="stat-rate">+<span id="inspiration-rate">0.0</span>/s</div>
                    </div>
                    <div class="stat-card tooltip" data-tooltip="Wisdom - Generated by philosophical beings">
                        <div class="stat-value" id="wisdom">0</div>
                        <div class="stat-label">Wisdom</div>
                        <div class="stat-rate">+<span id="wisdom-rate">0.0</span>/s</div>
                    </div>
                    <div class="stat-card tooltip" data-tooltip="Total active units in your sanctuary">
                        <div class="stat-value" id="total-units">0</div>
                        <div class="stat-label">Total Units</div>
                        <div class="stat-rate">Active</div>
                    </div>
                </div>
            </div>

            <!-- Village Canvas -->
            <div class="flex-1 relative">
                 <canvas id="village-canvas" class="w-full h-full"></canvas>
            </div>
        </main>

    </div>

    <!-- Bottom Bar: Log & Help - TDD Fixed Height with Scrolling -->
    <footer id="log-panel" class="w-full border-t border-indigo-900" style="height: 200px; min-height: 200px; max-height: 200px;">
        <div class="p-3 h-full flex">
            <!-- Log Section -->
            <div class="flex-1 flex flex-col mr-3">
                <h3 class="font-semibold text-base mb-2 text-indigo-200 flex-shrink-0">Aetheric Log</h3>
                <div id="log-output" class="text-sm text-indigo-300 space-y-1 flex-1 overflow-y-auto pr-2"></div>
            </div>

            <!-- Help Section -->
            <div class="w-64 flex flex-col border-l border-indigo-700 pl-3">
                <h3 class="font-semibold text-base mb-2 text-indigo-200 flex-shrink-0">Quick Help</h3>
                <div class="text-xs text-indigo-300 space-y-1 overflow-y-auto">
                    <div class="mb-2">
                        <div class="text-indigo-200 font-medium">Tabs:</div>
                        <div>1-4: Switch tabs</div>
                    </div>
                    <div class="mb-2">
                        <div class="text-indigo-200 font-medium">Units:</div>
                        <div>D: Create Dreamer</div>
                        <div>W: Create Weaver</div>
                    </div>
                    <div class="mb-2">
                        <div class="text-indigo-200 font-medium">Beings:</div>
                        <div>S: Summon Sage</div>
                        <div>E: Void Explorer</div>
                        <div>H: Harmony Keeper</div>
                    </div>
                    <div class="mb-2">
                        <div class="text-indigo-200 font-medium">Other:</div>
                        <div>ESC: Close dialogs</div>
                        <div>Click beings to chat</div>
                    </div>
                </div>
            </div>
        </div>
    </footer>
    
    <!-- TDD Test Runner (Hidden) -->
    <div id="test-runner" style="display: none;"></div>

    <!-- TDD API Key Popup -->
    <div id="api-key-popup" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-gray-800 border border-indigo-600 p-6 rounded-lg max-w-md w-full mx-4 shadow-2xl">
            <h3 class="text-xl font-bold text-white mb-4">üîë Configure Grok API Key</h3>
            <p class="text-gray-300 mb-4">To access cosmic wisdom and AI insights, please enter your Grok API key:</p>
            <p class="text-sm text-indigo-300 mb-4">Get your API key from <a href="https://x.ai" target="_blank" class="text-blue-400 hover:text-blue-300 underline">x.ai</a></p>
            <input type="password" id="api-key-input" class="w-full p-3 bg-gray-700 text-white rounded mb-2 border border-gray-600 focus:border-indigo-500 focus:outline-none" placeholder="Enter your Grok API key...">
            <div id="api-key-error" class="text-red-400 text-sm mb-4 hidden"></div>
            <div class="flex gap-3">
                <button id="save-api-key" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white py-2 px-4 rounded transition-colors">
                    üíæ Save Key
                </button>
                <button id="cancel-api-key" class="flex-1 bg-gray-600 hover:bg-gray-700 text-white py-2 px-4 rounded transition-colors">
                    ‚ùå Cancel
                </button>
            </div>
        </div>
    </div>

    <script>
        // --- Canvas & DOM Elements ---
        const canvas = document.getElementById('village-canvas');
        const ctx = canvas.getContext('2d');
        const modulesPanel = document.getElementById('modules-panel');
        const unitsPanel = document.getElementById('units-panel');
        const statsBar = document.getElementById('stats-bar');
        const logOutput = document.getElementById('log-output');
        const seasonalVisionBtn = document.getElementById('seasonal-vision-btn');
        const advisorBtn = document.getElementById('advisor-btn');

        // --- Game State (Incremental Model) - TDD Races Expansion ---
        let gameState = {
            energy: 20,
            energyPerSecond: 0,
            insight: 5,
            insightPerSecond: 0,
            harmony: 50,
            inspiration: 0,
            inspirationPerSecond: 0,
            wisdom: 0,
            wisdomPerSecond: 0,
            units: {
                dreamers: 1,  // Start with 1 dreamer for immediate insight generation
                weavers: 1,   // Start with 1 weaver for immediate energy generation
                stellarNomads: 0,
                voidWhisperers: 0,
                crystalBeings: 0,
                plasmaDancers: 0,
                quantumSages: 0,
                nebulaShepherds: 0
            },
            unitCosts: {
                dreamers: 15,  // Slightly higher since we start with units
                weavers: 15,
                stellarNomads: 25,
                voidWhisperers: 40,
                crystalBeings: 60,
                plasmaDancers: 80,
                quantumSages: 120,
                nebulaShepherds: 200
            },
            unlockedRaces: ['human'], // Start with humans unlocked
            nodes: {
                sustenance: 0,
                energy: 0,
                cohesion: 0,
                cycling: 0,
            },
            nodeCosts: {
                sustenance: 100,
                energy: 100,
                cohesion: 500,
                cycling: 200,
            },
            villageGrid: [],
            stars: [],
            intelligentCreatures: [], // TDD: Intelligent creatures with AI behaviors
            conversationalUnits: [], // TDD: Conversational AI units with LLM dialogue
            activeInteractions: [], // TDD: Unit-to-unit interactions
            synergyEffects: [], // TDD: Active synergy bonuses
            inspiration: 0, // TDD: New resource type
            wisdom: 0, // TDD: New resource type
            lastUpdate: Date.now(),
        };

        // --- Game Config - TDD Races System ---
        const racesConfig = {
            human: { name: "Human", description: "The original inhabitants", color: '#8B5CF6', symbol: 'üë§', unlocked: true, tier: 1 },
            stellar: { name: "Stellar Nomads", description: "Wandering star-travelers", color: '#F59E0B', symbol: '‚≠ê', unlockCondition: { energy: 50, insight: 25 }, unlocked: false, tier: 2 },
            void: { name: "Void Whisperers", description: "Mysterious void entities", color: '#1F2937', symbol: 'üåë', unlockCondition: { harmony: 70, energy: 100 }, unlocked: false, tier: 3 },
            crystal: { name: "Crystal Beings", description: "Living crystalline entities", color: '#10B981', symbol: 'üíé', unlockCondition: { energy: 200, insight: 100 }, unlocked: false, tier: 3 },
            plasma: { name: "Plasma Dancers", description: "Pure energy beings", color: '#EF4444', symbol: 'üî•', unlockCondition: { energy: 500, harmony: 80 }, unlocked: false, tier: 4 },
            quantum: { name: "Quantum Sages", description: "Multi-dimensional beings", color: '#8B5CF6', symbol: 'üåÄ', unlockCondition: { insight: 500, harmony: 85 }, unlocked: false, tier: 5 },
            nebula: { name: "Nebula Shepherds", description: "Ancient star-birthers", color: '#A78BFA', symbol: 'üåå', unlockCondition: { energy: 1000, insight: 800, harmony: 95 }, unlocked: false, tier: 5 }
        };

        const unitsConfig = {
            dreamers: { name: "Dreamer", description: "Generates Insight through cosmic meditation.", baseInsight: 0.1, costResource: 'energy', race: 'human', special: 'dreamVision' },
            weavers: { name: "Weaver", description: "Generates Energy by weaving cosmic threads.", baseEnergy: 0.1, costResource: 'insight', race: 'human', special: 'energyWeaving' },
            stellarNomads: { name: "Stellar Nomad", description: "Star-travelers generating Energy and Insight.", baseEnergy: 0.15, baseInsight: 0.05, costResource: 'energy', race: 'stellar', special: 'stellarNavigation' },
            voidWhisperers: { name: "Void Whisperer", description: "Void communers generating Insight and Harmony.", baseInsight: 0.08, baseHarmony: 0.02, costResource: 'insight', race: 'void', special: 'voidCommunion' },
            crystalBeings: { name: "Crystal Being", description: "Living crystals amplifying cosmic energy.", baseEnergy: 0.2, costResource: 'energy', race: 'crystal', special: 'crystalResonance' },
            plasmaDancers: { name: "Plasma Dancer", description: "Pure energy beings dancing through plasma.", baseEnergy: 0.3, costResource: 'insight', race: 'plasma', special: 'plasmaManipulation' },
            quantumSages: { name: "Quantum Sage", description: "Multi-dimensional beings with vast knowledge.", baseInsight: 0.5, costResource: 'energy', race: 'quantum', special: 'quantumEntanglement' },
            nebulaShepherds: { name: "Nebula Shepherd", description: "Ancient beings birthing stars.", baseEnergy: 0.8, baseInsight: 0.3, baseHarmony: 0.1, costResource: 'insight', race: 'nebula', special: 'starBirth' }
        };

        const nodesConfig = {
            sustenance: { name: "Sustenance Node", description: "Boosts Dreamer insight generation.", effectTarget: 'dreamers', multiplier: 1.2, costResource: 'energy' },
            energy: { name: "Energy Node", description: "Boosts Weaver energy generation.", effectTarget: 'weavers', multiplier: 1.2, costResource: 'insight' },
            cohesion: { name: "Cohesion Node", description: "Boosts all production.", effectTarget: 'all', multiplier: 1.1, costResource: 'energy' },
            cycling: { name: "Recycling Node", description: "Reduces the cost of all units and improves Harmony.", effectTarget: 'cost', multiplier: 0.95, harmony: 5, costResource: 'insight' },
        };

        // --- Utility Functions ---
        const formatNumber = (num) => {
            if (num < 1000) return num.toFixed(1);
            if (num < 1e6) return (num / 1e3).toFixed(2) + 'k';
            if (num < 1e9) return (num / 1e6).toFixed(2) + 'M';
            return (num / 1e9).toFixed(2) + 'B';
        };
        const log = (message, type = 'info') => {
            const colors = { info: 'text-indigo-300', success: 'text-teal-300', error: 'text-red-400', warning: 'text-amber-300', grok: 'text-purple-300' };
            const p = document.createElement('p');
            p.innerHTML = `[INFO] ${message}`;
            p.className = `${colors[type]} log-entry`;
            logOutput.prepend(p);
            if (logOutput.children.length > 20) {
                logOutput.lastChild.remove();
            }
        };

        // --- Rendering Functions ---
        // Store previous values for change detection
        let previousValues = {
            energy: 20,
            insight: 5,
            harmony: 50,
            inspiration: 0,
            wisdom: 0
        };

        const renderStats = () => {
            // Update individual stat elements instead of replacing entire innerHTML
            const energyEl = document.getElementById('energy');
            const insightEl = document.getElementById('insight');
            const harmonyEl = document.getElementById('harmony');
            const inspirationEl = document.getElementById('inspiration');
            const wisdomEl = document.getElementById('wisdom');
            const energyRateEl = document.getElementById('energy-rate');
            const insightRateEl = document.getElementById('insight-rate');
            const inspirationRateEl = document.getElementById('inspiration-rate');
            const wisdomRateEl = document.getElementById('wisdom-rate');
            const totalUnitsEl = document.getElementById('total-units');

            // Check for increases and add visual feedback
            const checkAndUpdate = (element, newValue, resourceName) => {
                if (element) {
                    const oldValue = previousValues[resourceName];
                    element.textContent = formatNumber(newValue);

                    if (newValue > oldValue && oldValue > 0) {
                        element.classList.add('resource-increase');
                        setTimeout(() => element.classList.remove('resource-increase'), 500);
                    }
                    previousValues[resourceName] = newValue;
                }
            };

            checkAndUpdate(energyEl, gameState.energy, 'energy');
            checkAndUpdate(insightEl, gameState.insight, 'insight');
            checkAndUpdate(inspirationEl, gameState.inspiration, 'inspiration');
            checkAndUpdate(wisdomEl, gameState.wisdom, 'wisdom');

            // Handle harmony separately (no formatting, just fixed decimal)
            if (harmonyEl) {
                const oldHarmony = previousValues.harmony;
                harmonyEl.textContent = gameState.harmony.toFixed(1);

                if (gameState.harmony > oldHarmony && oldHarmony > 0) {
                    harmonyEl.classList.add('resource-increase');
                    setTimeout(() => harmonyEl.classList.remove('resource-increase'), 500);
                }
                previousValues.harmony = gameState.harmony;
            }

            if (energyRateEl) energyRateEl.textContent = gameState.energyPerSecond.toFixed(1);
            if (insightRateEl) insightRateEl.textContent = gameState.insightPerSecond.toFixed(1);
            if (inspirationRateEl) inspirationRateEl.textContent = (gameState.inspirationPerSecond || 0).toFixed(1);
            if (wisdomRateEl) wisdomRateEl.textContent = (gameState.wisdomPerSecond || 0).toFixed(1);

            // Calculate total units
            if (totalUnitsEl) {
                const totalUnits = Object.values(gameState.units).reduce((sum, count) => sum + count, 0) +
                                 gameState.intelligentCreatures.length +
                                 gameState.conversationalUnits.length;
                totalUnitsEl.textContent = totalUnits;
            }
        };

        // TDD Fix: Stable button rendering that doesn't recreate buttons
        let unitsInitialized = false;

        // TDD Races: Check for newly unlocked races
        const checkRaceUnlocks = () => {
            let newlyUnlocked = [];

            Object.entries(racesConfig).forEach(([raceKey, race]) => {
                if (!gameState.unlockedRaces.includes(raceKey) && !race.unlocked) {
                    if (!race.unlockCondition) {
                        gameState.unlockedRaces.push(raceKey);
                        race.unlocked = true;
                        newlyUnlocked.push(raceKey);
                    } else {
                        const canUnlock = Object.entries(race.unlockCondition).every(([resource, required]) => {
                            return gameState[resource] >= required;
                        });

                        if (canUnlock) {
                            gameState.unlockedRaces.push(raceKey);
                            race.unlocked = true;
                            newlyUnlocked.push(raceKey);
                            log(`üåü New race discovered: ${race.name}! ${race.description}`, 'success');
                        }
                    }
                }
            });

            return newlyUnlocked;
        };

        const renderUnits = () => {
            // Only create buttons once, then update their states
            if (!unitsInitialized) {
                createUnitButtons();
                unitsInitialized = true;
            }
            updateUnitButtonStates();
        };

        const createUnitButtons = () => {
            unitsPanel.innerHTML = '';
            for (const key in unitsConfig) {
                const unit = unitsConfig[key];
                const card = document.createElement('div');
                card.className = "unit-card p-4 rounded-lg border border-indigo-800";
                card.innerHTML = `
                    <h3 class="font-bold text-lg text-white">${unit.name}</h3>
                    <p class="text-sm text-indigo-200">${unit.description}</p>
                    <button class="unit-btn w-full mt-2 py-2 px-3 text-sm font-semibold rounded-md transition-colors"
                            data-unit="${key}">
                        Create ${unit.name}
                    </button>
                `;

                // Add stable event listener
                const button = card.querySelector('.unit-btn');
                button.addEventListener('click', () => {
                    if (!button.disabled) {
                        createUnit(key);
                    }
                });

                unitsPanel.appendChild(card);
            }
        };

        const updateUnitButtonStates = () => {
            for (const key in unitsConfig) {
                const unit = unitsConfig[key];
                const cost = gameState.unitCosts[key];
                const canAfford = gameState[unit.costResource] >= cost;

                const button = unitsPanel.querySelector(`[data-unit="${key}"]`);
                if (button) {
                    button.disabled = !canAfford;
                    button.textContent = `Create (Cost: ${formatNumber(cost)} ${unit.costResource})`;

                    // Update visual state without recreating
                    button.className = `unit-btn w-full mt-2 py-2 px-3 text-sm font-semibold rounded-md transition-colors ${
                        canAfford ? 'bg-green-600 hover:bg-green-700 text-white' : 'bg-gray-600 text-gray-400'
                    }`;
                }
            }
        };

        // TDD Fix: Stable node button rendering
        let nodesInitialized = false;

        const renderNodes = () => {
            // Only create buttons once, then update their states
            if (!nodesInitialized) {
                createNodeButtons();
                nodesInitialized = true;
            }
            updateNodeButtonStates();
        };

        const createNodeButtons = () => {
            modulesPanel.innerHTML = '';
            for (const key in nodesConfig) {
                const node = nodesConfig[key];
                const card = document.createElement('div');
                card.className = "module-card p-4 rounded-lg";
                card.innerHTML = `
                    <h3 class="font-bold text-lg text-white">
                        ${node.name} <span class="text-sm font-normal text-indigo-300 level-display" data-node="${key}">(Lvl 0)</span>
                    </h3>
                    <p class="text-sm text-indigo-200">${node.description}</p>
                    <button class="node-btn w-full mt-2 py-2 px-3 text-sm font-semibold rounded-md transition-colors"
                            data-node="${key}">
                        Attune ${node.name}
                    </button>
                `;

                // Add stable event listener
                const button = card.querySelector('.node-btn');
                button.addEventListener('click', () => {
                    if (!button.disabled) {
                        upgradeNode(key);
                    }
                });

                modulesPanel.appendChild(card);
            }
        };

        const updateNodeButtonStates = () => {
            for (const key in nodesConfig) {
                const node = nodesConfig[key];
                const cost = gameState.nodeCosts[key];
                const level = gameState.nodes[key];
                const canAfford = gameState[node.costResource] >= cost;

                // Update level display
                const levelDisplay = modulesPanel.querySelector(`[data-node="${key}"].level-display`);
                if (levelDisplay) {
                    levelDisplay.textContent = `(Lvl ${level})`;
                }

                // Update button
                const button = modulesPanel.querySelector(`button[data-node="${key}"]`);
                if (button) {
                    button.disabled = !canAfford;
                    button.textContent = `Attune (Cost: ${formatNumber(cost)} ${node.costResource})`;

                    // Update visual state without recreating
                    button.className = `node-btn w-full mt-2 py-2 px-3 text-sm font-semibold rounded-md transition-colors ${
                        canAfford ? 'bg-teal-600 hover:bg-teal-700 text-white' : 'bg-gray-600 text-gray-400'
                    }`;
                }
            }
        };

        const renderUI = () => {
            renderStats();
            renderUnits();
            renderNodes();
        }
        
        // --- Enhanced Drawing System with Movement ---
        let animationTime = 0;
        let particles = [];

        // TDD Task 1: Drag and Drop System
        let dragState = {
            isDragging: false,
            draggedUnit: null,
            dragOffsetX: 0,
            dragOffsetY: 0,
            hoveredUnit: null
        };

        let movementTrails = {};

        // TDD Task 2: Enhanced Visual Effects System
        let particlePool = {
            active: [],
            inactive: [],
            maxParticles: 200
        };

        let lightSources = [];
        let energyFlows = [];
        let screenEffects = {
            bloom: { enabled: true, intensity: 0.3 },
            vignette: { enabled: true, intensity: 0.2 }
        };

        const drawSanctuary = () => {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            animationTime += 0.016; // ~60fps

            // Enhanced Background with nebula effect
            drawBackground();

            // Enhanced Stars with twinkling
            drawStars();

            // Floating particles for magical atmosphere
            updateAndDrawParticles();

            // Energy/Insight flow lines
            drawEnergyFlows();

            // TDD Task 1: Update unit movement and draw enhanced sprites
            updateUnitMovement(0.016);
            updateMovementTrails();

            // TDD: Update intelligent creatures
            updateIntelligentCreatures(0.016);

            // TDD: Update conversational AI units
            updateConversationalUnits(0.016);

            // TDD: Update unit interactions and synergies (placeholder for now)
            // updateUnitInteractions(0.016);

            gameState.villageGrid.sort((a, b) => a.y - b.y);
            gameState.villageGrid.forEach(item => {
                const isHovered = dragState.hoveredUnit === item;
                const isDragged = dragState.draggedUnit === item;

                if (item.type === 'dome') drawEnhancedDome(item.x, item.y, item.size, item, isHovered, isDragged);
                else if (item.type === 'crystal_tree') drawEnhancedCrystalTree(item.x, item.y, item.size, item, isHovered, isDragged);
                else if (item.type === 'garden') drawEnhancedGarden(item.x, item.y, item.size, item, isHovered, isDragged);
                else drawMovableUnit(item, isHovered, isDragged);
            });

            // Draw movement trails
            drawMovementTrails();

            // TDD: Draw intelligent creatures
            drawIntelligentCreatures();

            // TDD: Draw conversational AI units
            drawConversationalUnits();

            // Ambient light effects
            drawAmbientEffects();
        };

        const drawBackground = () => {
            // Multi-layer gradient background
            const gradient1 = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient1.addColorStop(0, '#0a0820');
            gradient1.addColorStop(0.3, '#1a1040');
            gradient1.addColorStop(0.7, '#2a1860');
            gradient1.addColorStop(1, '#1c1944');
            ctx.fillStyle = gradient1;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Nebula clouds
            for (let i = 0; i < 3; i++) {
                const x = (canvas.width * 0.2) + (i * canvas.width * 0.3);
                const y = canvas.height * 0.3 + Math.sin(animationTime * 0.5 + i) * 20;
                const radius = 150 + Math.sin(animationTime * 0.3 + i) * 30;

                const nebulaGradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                nebulaGradient.addColorStop(0, `rgba(138, 43, 226, ${0.1 + Math.sin(animationTime + i) * 0.05})`);
                nebulaGradient.addColorStop(0.5, `rgba(75, 0, 130, ${0.05 + Math.sin(animationTime * 0.7 + i) * 0.03})`);
                nebulaGradient.addColorStop(1, 'rgba(75, 0, 130, 0)');

                ctx.fillStyle = nebulaGradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        };

        const drawStars = () => {
            // Initialize enhanced stars
            if (gameState.stars.length === 0) {
                for (let i = 0; i < 150; i++) {
                    gameState.stars.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        radius: Math.random() * 2 + 0.5,
                        alpha: 0.3 + Math.random() * 0.7,
                        twinkleSpeed: 0.5 + Math.random() * 2,
                        color: Math.random() > 0.8 ? 'rgba(200, 150, 255, ' : 'rgba(255, 255, 255, '
                    });
                }
            }

            gameState.stars.forEach(star => {
                const twinkle = 0.7 + Math.sin(animationTime * star.twinkleSpeed + star.x) * 0.3;
                const alpha = star.alpha * twinkle;

                // Star glow
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius * 2, 0, Math.PI * 2);
                ctx.fillStyle = star.color + (alpha * 0.2) + ')';
                ctx.fill();

                // Star core
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                ctx.fillStyle = star.color + alpha + ')';
                ctx.fill();
            });
        };

        const updateAndDrawParticles = () => {
            // Add new particles occasionally
            if (Math.random() < 0.3) {
                particles.push({
                    x: Math.random() * canvas.width,
                    y: canvas.height + 10,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: -Math.random() * 2 - 0.5,
                    life: 1.0,
                    decay: 0.005 + Math.random() * 0.01,
                    size: Math.random() * 3 + 1,
                    color: Math.random() > 0.5 ? 'rgba(167, 139, 250, ' : 'rgba(196, 181, 253, '
                });
            }

            // Update and draw particles
            particles = particles.filter(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life -= particle.decay;

                if (particle.life > 0) {
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size * particle.life, 0, Math.PI * 2);
                    ctx.fillStyle = particle.color + (particle.life * 0.6) + ')';
                    ctx.fill();
                    return true;
                }
                return false;
            });
        };

        // TDD Task 1: Enhanced sprite system with movement capabilities
        let spriteIdCounter = 0;

        const addSprite = (type, count = 1) => {
            for (let i = 0; i < count; i++) {
                const x = Math.random() * (canvas.width - 100) + 50;
                const y = Math.random() * (canvas.height - 100) + 50;
                const size = type === 'dome' ? 20 : type === 'crystal_tree' ? 25 : 15;

                // Determine if unit is movable based on type
                const movable = ['dreamer', 'weaver', 'stellarNomads', 'voidWhisperers',
                               'crystalBeings', 'plasmaDancers', 'quantumSages', 'nebulaShepherds'].includes(type);

                const sprite = {
                    type: type,
                    x: x,
                    y: y,
                    size: size,
                    movable: movable,
                    id: `${type}_${spriteIdCounter++}`,
                    animationOffset: Math.random() * Math.PI * 2,
                    pulseSpeed: 0.5 + Math.random() * 1.5,
                    // Movement properties for movable units
                    targetX: x,
                    targetY: y,
                    vx: 0,
                    vy: 0,
                    wanderCenter: { x: x, y: y },
                    wanderPhase: Math.random() * Math.PI * 2,
                    wanderRadius: 30 + Math.random() * 20
                };

                gameState.villageGrid.push(sprite);
            }
        };

        const drawEnhancedDome = (x, y, size, sprite, isHovered, isDragged) => {
            ctx.save();

            // Visual feedback for interaction states
            let scale = 1.0;
            let alpha = 1.0;
            let glowIntensity = 0.8;

            if (isDragged) {
                scale = 1.2;
                alpha = 0.9;
                glowIntensity = 1.2;
            } else if (isHovered) {
                scale = 1.1;
                glowIntensity = 1.0;
            }

            ctx.globalAlpha = alpha;
            ctx.translate(x, y);
            ctx.scale(scale, scale);

            const pulse = Math.sin(animationTime * (sprite.pulseSpeed || 1) + (sprite.animationOffset || 0)) * 0.15 + 1;
            const currentSize = size * pulse;

            // Layer 1: Outer energy field with orange/yellow theme
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            ctx.shadowColor = '#FBBF24';
            ctx.shadowBlur = 25 * glowIntensity;
            ctx.beginPath();
            ctx.arc(0, 0, currentSize * 1.8, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(251, 191, 36, 0.2)';
            ctx.fill();
            ctx.restore();

            // Layer 2: Main dome with enhanced orange gradient
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize);
            gradient.addColorStop(0, 'rgba(255, 215, 77, 1.0)');
            gradient.addColorStop(0.6, 'rgba(245, 158, 11, 0.9)');
            gradient.addColorStop(1, 'rgba(217, 119, 6, 0.7)');

            ctx.shadowColor = '#FBBF24';
            ctx.shadowBlur = 15 * glowIntensity;
            ctx.beginPath();
            ctx.arc(0, 0, currentSize, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();

            // Layer 3: Inner highlight
            ctx.save();
            ctx.globalCompositeOperation = 'overlay';
            const highlightGradient = ctx.createRadialGradient(-currentSize * 0.3, -currentSize * 0.3, 0, 0, 0, currentSize * 0.8);
            highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
            highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.beginPath();
            ctx.arc(0, 0, currentSize * 0.7, 0, Math.PI * 2);
            ctx.fillStyle = highlightGradient;
            ctx.fill();
            ctx.restore();

            // Layer 4: Energy orbs floating around dome
            for (let i = 0; i < 3; i++) {
                const angle = animationTime * 0.5 + (i * Math.PI * 2 / 3) + (sprite.animationOffset || 0);
                const orbX = Math.cos(angle) * (currentSize + 15);
                const orbY = Math.sin(angle) * (currentSize + 15);

                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                ctx.shadowColor = '#FBBF24';
                ctx.shadowBlur = 8;
                ctx.beginPath();
                ctx.arc(orbX, orbY, 3, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 215, 77, 0.8)';
                ctx.fill();
                ctx.restore();
            }

            ctx.shadowBlur = 0;
            ctx.restore();
        };

        const drawEnhancedCrystalTree = (x, y, size, sprite) => {
            const pulse = Math.sin(animationTime * sprite.pulseSpeed + sprite.animationOffset) * 0.15 + 1;
            const currentSize = size * pulse;

            // Crystal base/roots
            ctx.beginPath();
            ctx.ellipse(x, y, currentSize * 0.8, currentSize * 0.3, 0, 0, Math.PI * 2);
            const baseGradient = ctx.createRadialGradient(x, y, 0, x, y, currentSize * 0.8);
            baseGradient.addColorStop(0, `rgba(139, 92, 246, ${0.6 * pulse})`);
            baseGradient.addColorStop(1, `rgba(79, 70, 229, ${0.3 * pulse})`);
            ctx.fillStyle = baseGradient;
            ctx.fill();

            // Main crystal trunk with facets
            const trunkHeight = currentSize * 2;
            const trunkWidth = currentSize * 0.6;

            // Multiple crystal facets
            for (let i = 0; i < 6; i++) {
                const angle = (i * Math.PI) / 3;
                const facetX = x + Math.cos(angle) * (trunkWidth * 0.3);
                const facetY = y - trunkHeight * 0.5;

                ctx.beginPath();
                ctx.moveTo(facetX, y);
                ctx.lineTo(facetX + Math.cos(angle) * (trunkWidth * 0.2), facetY);
                ctx.lineTo(x, y - trunkHeight);
                ctx.lineTo(facetX - Math.cos(angle) * (trunkWidth * 0.2), facetY);
                ctx.closePath();

                const facetGradient = ctx.createLinearGradient(facetX, y, x, y - trunkHeight);
                const brightness = 0.5 + Math.sin(animationTime + angle) * 0.3;
                facetGradient.addColorStop(0, `rgba(139, 92, 246, ${brightness * pulse})`);
                facetGradient.addColorStop(0.5, `rgba(167, 139, 250, ${(brightness + 0.2) * pulse})`);
                facetGradient.addColorStop(1, `rgba(196, 181, 253, ${(brightness + 0.4) * pulse})`);

                ctx.fillStyle = facetGradient;
                ctx.fill();

                // Crystal edges with glow
                ctx.strokeStyle = `rgba(255, 255, 255, ${0.8 * pulse})`;
                ctx.lineWidth = 1;
                ctx.shadowColor = 'rgba(167, 139, 250, 0.8)';
                ctx.shadowBlur = 5;
                ctx.stroke();
                ctx.shadowBlur = 0;
            }

            // Crystal tip with intense glow
            ctx.beginPath();
            ctx.arc(x, y - trunkHeight, currentSize * 0.2, 0, Math.PI * 2);
            const tipGradient = ctx.createRadialGradient(x, y - trunkHeight, 0, x, y - trunkHeight, currentSize * 0.2);
            tipGradient.addColorStop(0, `rgba(255, 255, 255, ${0.9 * pulse})`);
            tipGradient.addColorStop(1, `rgba(196, 181, 253, ${0.6 * pulse})`);
            ctx.fillStyle = tipGradient;
            ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
            ctx.shadowBlur = 15;
            ctx.fill();
            ctx.shadowBlur = 0;

            // Energy wisps rising from crystal
            for (let i = 0; i < 2; i++) {
                const wispY = y - trunkHeight - 20 - (animationTime * 20 + i * 50) % 100;
                const wispX = x + Math.sin(animationTime + i) * 10;

                if (wispY > y - trunkHeight - 120) {
                    ctx.beginPath();
                    ctx.arc(wispX, wispY, 2, 0, Math.PI * 2);
                    const wispAlpha = 1 - ((y - trunkHeight - 20 - wispY) / 100);
                    ctx.fillStyle = `rgba(196, 181, 253, ${wispAlpha * 0.8})`;
                    ctx.fill();
                }
            }
        };
        
        const drawEnhancedGarden = (x, y, size, sprite) => {
            const pulse = Math.sin(animationTime * sprite.pulseSpeed + sprite.animationOffset) * 0.1 + 1;

            // Garden base with organic shape
            ctx.beginPath();
            for (let i = 0; i <= 16; i++) {
                const angle = (i / 16) * Math.PI * 2;
                const radius = size * (0.8 + Math.sin(angle * 3 + animationTime) * 0.2) * pulse;
                const px = x + Math.cos(angle) * radius;
                const py = y + Math.sin(angle) * radius * 0.6;

                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();

            const gardenGradient = ctx.createRadialGradient(x, y, 0, x, y, size);
            gardenGradient.addColorStop(0, `rgba(34, 197, 94, ${0.3 * pulse})`);
            gardenGradient.addColorStop(0.5, `rgba(22, 163, 74, ${0.2 * pulse})`);
            gardenGradient.addColorStop(1, `rgba(21, 128, 61, ${0.1 * pulse})`);
            ctx.fillStyle = gardenGradient;
            ctx.fill();

            // Magical flowers with different types
            const flowerTypes = [
                { color: '#fde047', glow: '#facc15', size: 4 }, // Golden
                { color: '#a78bfa', glow: '#8b5cf6', size: 3 }, // Purple
                { color: '#f472b6', glow: '#ec4899', size: 3.5 }, // Pink
                { color: '#34d399', glow: '#10b981', size: 3 }  // Emerald
            ];

            // Static flower positions based on sprite properties
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2 + sprite.animationOffset;
                const distance = (size * 0.6) + Math.sin(animationTime * 0.5 + i) * (size * 0.2);
                const flowerX = x + Math.cos(angle) * distance;
                const flowerY = y + Math.sin(angle) * distance * 0.6;

                const flowerType = flowerTypes[i % flowerTypes.length];
                const flowerPulse = Math.sin(animationTime * 2 + i) * 0.3 + 1;

                // Flower glow
                ctx.beginPath();
                ctx.arc(flowerX, flowerY, flowerType.size * flowerPulse * 1.5, 0, Math.PI * 2);
                ctx.fillStyle = flowerType.glow + '40'; // 25% opacity
                ctx.fill();

                // Flower petals
                for (let p = 0; p < 5; p++) {
                    const petalAngle = (p / 5) * Math.PI * 2 + animationTime * 0.1;
                    const petalX = flowerX + Math.cos(petalAngle) * flowerType.size * 0.8;
                    const petalY = flowerY + Math.sin(petalAngle) * flowerType.size * 0.8;

                    ctx.beginPath();
                    ctx.arc(petalX, petalY, flowerType.size * 0.6 * flowerPulse, 0, Math.PI * 2);
                    ctx.fillStyle = flowerType.color;
                    ctx.shadowColor = flowerType.glow;
                    ctx.shadowBlur = 8;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }

                // Flower center
                ctx.beginPath();
                ctx.arc(flowerX, flowerY, flowerType.size * 0.3, 0, Math.PI * 2);
                ctx.fillStyle = '#fbbf24';
                ctx.shadowColor = '#f59e0b';
                ctx.shadowBlur = 5;
                ctx.fill();
                ctx.shadowBlur = 0;
            }

            // Floating pollen particles
            for (let i = 0; i < 3; i++) {
                const pollenX = x + Math.sin(animationTime * 0.8 + i) * size * 0.8;
                const pollenY = y + Math.cos(animationTime * 0.6 + i) * size * 0.4 - 10;

                ctx.beginPath();
                ctx.arc(pollenX, pollenY, 1.5, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(251, 191, 36, ${0.6 + Math.sin(animationTime * 2 + i) * 0.4})`;
                ctx.fill();
            }
        };

        const drawEnergyFlows = () => {
            // Draw energy connections between structures
            const domes = gameState.villageGrid.filter(item => item.type === 'dome');
            const crystals = gameState.villageGrid.filter(item => item.type === 'crystal_tree');

            // Energy flows from crystals to domes (insight to energy conversion)
            crystals.forEach(crystal => {
                domes.forEach(dome => {
                    const distance = Math.sqrt((dome.x - crystal.x) ** 2 + (dome.y - crystal.y) ** 2);
                    if (distance < 200) { // Only connect nearby structures
                        drawEnergyBeam(crystal.x, crystal.y - crystal.size, dome.x, dome.y, 'insight');
                    }
                });
            });
        };

        const drawEnergyBeam = (x1, y1, x2, y2, type) => {
            const flowSpeed = animationTime * 3;
            const color = type === 'insight' ? 'rgba(167, 139, 250, ' : 'rgba(34, 197, 94, ';

            // Main beam
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.strokeStyle = color + '0.3)';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Animated energy particles along the beam
            const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
            const steps = Math.floor(distance / 20);

            for (let i = 0; i < steps; i++) {
                const progress = (i / steps + flowSpeed * 0.1) % 1;
                const x = x1 + (x2 - x1) * progress;
                const y = y1 + (y2 - y1) * progress;

                ctx.beginPath();
                ctx.arc(x, y, 2, 0, Math.PI * 2);
                ctx.fillStyle = color + (0.8 * (1 - progress)) + ')';
                ctx.shadowColor = color + '0.8)';
                ctx.shadowBlur = 5;
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        };

        const drawAmbientEffects = () => {
            // Ambient magical aura around the entire sanctuary
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const maxRadius = Math.max(canvas.width, canvas.height) * 0.6;

            const auraGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, maxRadius);
            auraGradient.addColorStop(0, 'rgba(167, 139, 250, 0)');
            auraGradient.addColorStop(0.7, `rgba(167, 139, 250, ${0.05 + Math.sin(animationTime * 0.5) * 0.02})`);
            auraGradient.addColorStop(1, 'rgba(75, 0, 130, 0)');

            ctx.fillStyle = auraGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Floating light orbs
            for (let i = 0; i < 5; i++) {
                const orbX = centerX + Math.sin(animationTime * 0.3 + i) * (canvas.width * 0.3);
                const orbY = centerY + Math.cos(animationTime * 0.2 + i) * (canvas.height * 0.2);
                const orbSize = 3 + Math.sin(animationTime + i) * 1;

                ctx.beginPath();
                ctx.arc(orbX, orbY, orbSize, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(196, 181, 253, ${0.4 + Math.sin(animationTime * 2 + i) * 0.2})`;
                ctx.shadowColor = 'rgba(196, 181, 253, 0.8)';
                ctx.shadowBlur = 10;
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        };

        // --- TDD API Key Management ---
        const getApiKey = () => {
            return localStorage.getItem('grok_api_key') || '';
        };

        const saveApiKey = (key) => {
            if (key && key.trim() && key.length >= 10) {
                localStorage.setItem('grok_api_key', key.trim());
                return true;
            }
            return false;
        };

        const showApiKeyPopup = () => {
            const popup = document.getElementById('api-key-popup');
            const input = document.getElementById('api-key-input');
            const error = document.getElementById('api-key-error');

            popup.classList.remove('hidden');
            input.focus();
            error.classList.add('hidden');
            error.textContent = '';
        };

        const hideApiKeyPopup = () => {
            const popup = document.getElementById('api-key-popup');
            const input = document.getElementById('api-key-input');

            popup.classList.add('hidden');
            input.value = '';
        };

        const showApiKeyError = (message) => {
            const error = document.getElementById('api-key-error');
            error.textContent = message;
            error.classList.remove('hidden');
        };

        // --- TDD Task 1: Unit Movement and Drag-and-Drop System ---

        const updateUnitMovement = (deltaTime) => {
            gameState.villageGrid.forEach(unit => {
                if (!unit.movable) return;

                // Auto-wandering for dreamers
                if (unit.type === 'dreamer' && !dragState.isDragging) {
                    updateWandering(unit, animationTime);
                }

                // Smooth movement towards target
                const dx = unit.targetX - unit.x;
                const dy = unit.targetY - unit.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 1) {
                    const speed = 50; // pixels per second
                    const moveDistance = speed * deltaTime;
                    const ratio = Math.min(moveDistance / distance, 1);

                    unit.x += dx * ratio;
                    unit.y += dy * ratio;
                    unit.vx = dx * ratio / deltaTime;
                    unit.vy = dy * ratio / deltaTime;
                } else {
                    unit.vx = 0;
                    unit.vy = 0;
                }
            });
        };

        const updateWandering = (unit, time) => {
            const wanderSpeed = 0.3;
            const wanderRadius = unit.wanderRadius || 30;

            unit.targetX = unit.wanderCenter.x + Math.sin(time * wanderSpeed + unit.wanderPhase) * wanderRadius;
            unit.targetY = unit.wanderCenter.y + Math.cos(time * wanderSpeed + unit.wanderPhase) * wanderRadius;

            // Keep within canvas bounds
            unit.targetX = Math.max(50, Math.min(canvas.width - 50, unit.targetX));
            unit.targetY = Math.max(50, Math.min(canvas.height - 50, unit.targetY));
        };

        const getUnitAtPosition = (x, y) => {
            for (let i = gameState.villageGrid.length - 1; i >= 0; i--) {
                const unit = gameState.villageGrid[i];
                const dx = x - unit.x;
                const dy = y - unit.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance <= unit.size) {
                    return unit;
                }
            }
            return null;
        };

        const getConversationalUnitAtPosition = (x, y) => {
            for (let i = gameState.conversationalUnits.length - 1; i >= 0; i--) {
                const unit = gameState.conversationalUnits[i];
                const dx = x - unit.x;
                const dy = y - unit.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance <= unit.size) {
                    return unit;
                }
            }
            return null;
        };

        const getCanvasCoordinates = (event) => {
            const rect = canvas.getBoundingClientRect();
            return {
                x: event.clientX - rect.left,
                y: event.clientY - rect.top
            };
        };

        const updateMovementTrails = () => {
            gameState.villageGrid.forEach(unit => {
                if (!unit.movable || (Math.abs(unit.vx) < 1 && Math.abs(unit.vy) < 1)) return;

                const trailKey = unit.id;
                if (!movementTrails[trailKey]) {
                    movementTrails[trailKey] = [];
                }

                movementTrails[trailKey].push({
                    x: unit.x,
                    y: unit.y,
                    timestamp: Date.now(),
                    alpha: 1.0
                });

                // Keep only recent trail points
                const maxAge = 1500;
                const now = Date.now();
                movementTrails[trailKey] = movementTrails[trailKey].filter(point =>
                    now - point.timestamp < maxAge
                );

                // Update alpha based on age
                movementTrails[trailKey].forEach(point => {
                    const age = now - point.timestamp;
                    point.alpha = Math.max(0, 1 - (age / maxAge));
                });
            });
        };

        const drawMovementTrails = () => {
            Object.values(movementTrails).forEach(trail => {
                if (trail.length < 2) return;

                ctx.save();
                ctx.strokeStyle = 'rgba(138, 92, 246, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();

                for (let i = 0; i < trail.length; i++) {
                    const point = trail[i];
                    ctx.globalAlpha = point.alpha * 0.5;

                    if (i === 0) {
                        ctx.moveTo(point.x, point.y);
                    } else {
                        ctx.lineTo(point.x, point.y);
                    }
                }

                ctx.stroke();
                ctx.restore();
            });
        };

        // TDD: Distinct visual designs for each unit type
        const drawMovableUnit = (unit, isHovered, isDragged) => {
            ctx.save();

            // Visual feedback for interaction states
            let scale = 1.0;
            let alpha = 1.0;
            let glowIntensity = 0.8;

            if (isDragged) {
                scale = 1.2;
                alpha = 0.9;
                glowIntensity = 1.2;
            } else if (isHovered) {
                scale = 1.1;
                glowIntensity = 1.0;
            }

            ctx.globalAlpha = alpha;
            ctx.translate(unit.x, unit.y);
            ctx.scale(scale, scale);

            // Draw unit based on type with distinct designs
            if (unit.type === 'dreamer') {
                drawDreamerUnit(unit, glowIntensity);
            } else if (unit.type === 'weaver') {
                drawWeaverUnit(unit, glowIntensity);
            } else if (unit.type === 'stellarNomads') {
                drawStellarNomadUnit(unit, glowIntensity);
            } else if (unit.type === 'voidWhisperers') {
                drawVoidWhispererUnit(unit, glowIntensity);
            } else if (unit.type === 'crystalBeings') {
                drawCrystalBeingUnit(unit, glowIntensity);
            } else if (unit.type === 'plasmaDancers') {
                drawPlasmaDancerUnit(unit, glowIntensity);
            } else {
                // Default fallback
                drawDefaultUnit(unit, glowIntensity);
            }

            ctx.shadowBlur = 0;
            ctx.restore();
        };

        const drawDreamerUnit = (unit, glowIntensity) => {
            const pulse = 1 + Math.sin(animationTime * 2 + (unit.animationOffset || 0)) * 0.15;
            const currentSize = unit.size * pulse;
            const floatOffset = Math.sin(animationTime * 0.5 + (unit.animationOffset || 0)) * 3;

            ctx.save();
            ctx.translate(0, floatOffset);

            // Outer aura
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            ctx.shadowColor = '#A78BFA';
            ctx.shadowBlur = 30 * glowIntensity;
            ctx.beginPath();
            ctx.arc(0, 0, currentSize * 2, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(167, 139, 250, 0.15)';
            ctx.fill();
            ctx.restore();

            // Main orb with gradient
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize);
            gradient.addColorStop(0, 'rgba(196, 181, 253, 1.0)');
            gradient.addColorStop(0.6, 'rgba(139, 92, 246, 0.9)');
            gradient.addColorStop(1, 'rgba(109, 40, 217, 0.7)');

            ctx.shadowColor = '#A78BFA';
            ctx.shadowBlur = 20 * glowIntensity;
            ctx.beginPath();
            ctx.arc(0, 0, currentSize, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();

            // Inner core
            ctx.save();
            ctx.globalCompositeOperation = 'overlay';
            ctx.beginPath();
            ctx.arc(-currentSize * 0.2, -currentSize * 0.2, currentSize * 0.4, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.fill();
            ctx.restore();

            // Energy wisps
            for (let i = 0; i < 3; i++) {
                const angle = animationTime * 0.3 + (i * Math.PI * 2 / 3);
                const radius = currentSize * 1.5;
                const wispX = Math.cos(angle) * radius;
                const wispY = Math.sin(angle) * radius;

                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                ctx.strokeStyle = 'rgba(196, 181, 253, 0.6)';
                ctx.lineWidth = 2;
                ctx.shadowColor = '#A78BFA';
                ctx.shadowBlur = 10;

                ctx.beginPath();
                ctx.moveTo(0, 0);
                const cp1x = wispX * 0.3;
                const cp1y = wispY * 0.3 + Math.sin(animationTime * 2 + i) * 10;
                const cp2x = wispX * 0.7;
                const cp2y = wispY * 0.7 + Math.cos(animationTime * 2 + i) * 8;
                ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, wispX, wispY);
                ctx.stroke();
                ctx.restore();
            }

            ctx.restore();
        };

        const drawWeaverUnit = (unit, glowIntensity) => {
            const pulse = 1 + Math.sin(animationTime * 1.5 + (unit.animationOffset || 0)) * 0.1;
            const currentSize = unit.size * pulse;

            // Hexagonal crystal base
            ctx.save();
            ctx.shadowColor = '#34D399';
            ctx.shadowBlur = 20 * glowIntensity;

            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize);
            gradient.addColorStop(0, 'rgba(110, 231, 183, 1.0)');
            gradient.addColorStop(0.6, 'rgba(16, 185, 129, 0.9)');
            gradient.addColorStop(1, 'rgba(5, 150, 105, 0.7)');

            // Draw hexagon
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = (i * Math.PI * 2) / 6;
                const x = Math.cos(angle) * currentSize;
                const y = Math.sin(angle) * currentSize;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fillStyle = gradient;
            ctx.fill();

            // Hexagon outline
            ctx.strokeStyle = 'rgba(110, 231, 183, 0.8)';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.restore();

            // Energy threads
            for (let i = 0; i < 6; i++) {
                const angle1 = (i * Math.PI * 2) / 6;
                const angle2 = ((i + 2) * Math.PI * 2) / 6;
                const weaveOffset = Math.sin(animationTime * 1.0 + i) * 0.3;

                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                ctx.strokeStyle = `rgba(110, 231, 183, ${0.4 + weaveOffset})`;
                ctx.lineWidth = 1.5;
                ctx.shadowColor = '#34D399';
                ctx.shadowBlur = 8;

                const x1 = Math.cos(angle1) * currentSize * 0.8;
                const y1 = Math.sin(angle1) * currentSize * 0.8;
                const x2 = Math.cos(angle2) * currentSize * 0.8;
                const y2 = Math.sin(angle2) * currentSize * 0.8;

                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
                ctx.restore();
            }

            // Central gem
            ctx.save();
            ctx.globalCompositeOperation = 'overlay';
            ctx.beginPath();
            for (let i = 0; i < 4; i++) {
                const angle = (i * Math.PI * 2) / 4 + Math.PI / 4;
                const x = Math.cos(angle) * currentSize * 0.3;
                const y = Math.sin(angle) * currentSize * 0.3;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.fill();
            ctx.restore();
        };

        const drawStellarNomadUnit = (unit, glowIntensity) => {
            const pulse = 1 + Math.sin(animationTime * 3 + (unit.animationOffset || 0)) * 0.2;
            const currentSize = unit.size * pulse;
            const rotation = animationTime * 0.5;

            ctx.save();
            ctx.rotate(rotation);

            // Stellar corona (8-pointed star)
            ctx.save();
            ctx.shadowColor = '#FBBF24';
            ctx.shadowBlur = 25 * glowIntensity;

            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize * 1.5);
            gradient.addColorStop(0, 'rgba(252, 211, 77, 1.0)');
            gradient.addColorStop(0.6, 'rgba(245, 158, 11, 0.8)');
            gradient.addColorStop(1, 'rgba(217, 119, 6, 0.4)');

            // Draw 8-pointed star
            ctx.beginPath();
            for (let i = 0; i < 16; i++) {
                const angle = (i * Math.PI * 2) / 16;
                const radius = i % 2 === 0 ? currentSize * 1.5 : currentSize * 0.8;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.restore();

            // Plasma core
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize * 0.8);
            coreGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
            coreGradient.addColorStop(0.5, 'rgba(252, 211, 77, 0.7)');
            coreGradient.addColorStop(1, 'rgba(245, 158, 11, 0.3)');

            ctx.beginPath();
            ctx.arc(0, 0, currentSize * 0.8, 0, Math.PI * 2);
            ctx.fillStyle = coreGradient;
            ctx.fill();
            ctx.restore();

            // Solar flares
            for (let i = 0; i < 4; i++) {
                const flareAngle = (i * Math.PI * 2) / 4 + animationTime * 0.2;
                const flareIntensity = 0.5 + Math.sin(animationTime * 4 + i) * 0.3;
                const flareLength = currentSize * (1.5 + flareIntensity * 0.5);

                ctx.save();
                ctx.rotate(flareAngle);
                ctx.globalCompositeOperation = 'screen';
                ctx.strokeStyle = `rgba(252, 211, 77, ${flareIntensity})`;
                ctx.lineWidth = 3;
                ctx.shadowColor = '#FBBF24';
                ctx.shadowBlur = 15;

                // Draw flame-like wisp
                ctx.beginPath();
                ctx.moveTo(currentSize, 0);
                const cp1x = currentSize + flareLength * 0.3;
                const cp1y = Math.sin(animationTime * 3 + i) * 8;
                const cp2x = currentSize + flareLength * 0.7;
                const cp2y = Math.cos(animationTime * 2 + i) * 12;
                const endX = currentSize + flareLength;
                const endY = Math.sin(animationTime * 4 + i) * 5;

                ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, endX, endY);
                ctx.stroke();
                ctx.restore();
            }

            ctx.restore();
        };

        const drawVoidWhispererUnit = (unit, glowIntensity) => {
            const pulse = 1 + Math.sin(animationTime * 1.5 + (unit.animationOffset || 0)) * 0.15;
            const currentSize = unit.size * pulse;
            const warpIntensity = Math.sin(animationTime * 1.5) * 0.15;

            // Void distortion effect
            ctx.save();
            ctx.globalCompositeOperation = 'multiply';
            ctx.shadowColor = '#581C87';
            ctx.shadowBlur = 30 * glowIntensity;

            // Irregular distorted circle
            ctx.beginPath();
            for (let i = 0; i <= 32; i++) {
                const angle = (i * Math.PI * 2) / 32;
                const distortion = 1 + Math.sin(angle * 3 + animationTime * 2) * warpIntensity;
                const radius = currentSize * distortion;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();

            const voidGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize);
            voidGradient.addColorStop(0, 'rgba(76, 29, 149, 0.9)');
            voidGradient.addColorStop(0.6, 'rgba(88, 28, 135, 0.7)');
            voidGradient.addColorStop(1, 'rgba(107, 33, 168, 0.3)');

            ctx.fillStyle = voidGradient;
            ctx.fill();
            ctx.restore();

            // Shadow tendrils
            for (let i = 0; i < 5; i++) {
                const baseAngle = (i * Math.PI * 2) / 5;
                const writheOffset = Math.sin(animationTime * 2 + i) * 0.5;
                const tentacleLength = currentSize * (1.5 + writheOffset);

                ctx.save();
                ctx.rotate(baseAngle);
                ctx.globalCompositeOperation = 'multiply';
                ctx.strokeStyle = `rgba(76, 29, 149, ${0.6 + writheOffset * 0.3})`;
                ctx.lineWidth = 3;
                ctx.shadowColor = '#581C87';
                ctx.shadowBlur = 12;

                // Draw writhing tentacle
                ctx.beginPath();
                ctx.moveTo(currentSize * 0.8, 0);

                const segments = 6;
                for (let j = 1; j <= segments; j++) {
                    const t = j / segments;
                    const segmentX = currentSize * 0.8 + tentacleLength * t;
                    const writhe = Math.sin(t * Math.PI * 2 + animationTime * 2 + i) * 8;
                    const segmentY = writhe;

                    if (j === 1) {
                        ctx.lineTo(segmentX, segmentY);
                    } else {
                        const prevT = (j - 1) / segments;
                        const prevX = currentSize * 0.8 + tentacleLength * prevT;
                        const prevWrithe = Math.sin(prevT * Math.PI * 2 + animationTime * 2 + i) * 8;

                        const cp1x = prevX + (segmentX - prevX) * 0.5;
                        const cp1y = prevWrithe;
                        const cp2x = segmentX - (segmentX - prevX) * 0.5;
                        const cp2y = segmentY;

                        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, segmentX, segmentY);
                    }
                }
                ctx.stroke();
                ctx.restore();
            }

            // Dark absorption core
            ctx.save();
            ctx.globalCompositeOperation = 'multiply';
            ctx.beginPath();
            ctx.arc(0, 0, currentSize * 0.5, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fill();
            ctx.restore();
        };

        const drawCrystalBeingUnit = (unit, glowIntensity) => {
            const pulse = 1 + Math.sin(animationTime * 2.5 + (unit.animationOffset || 0)) * 0.12;
            const currentSize = unit.size * pulse;
            const refraction = animationTime * 3;

            // Crystal facets
            ctx.save();
            ctx.shadowColor = '#06B6D4';
            ctx.shadowBlur = 20 * glowIntensity;

            // Main crystal body (octagon)
            const facets = 8;
            for (let layer = 0; layer < 3; layer++) {
                const layerSize = currentSize * (1 - layer * 0.2);
                const layerAlpha = 0.8 - layer * 0.2;

                ctx.save();
                ctx.rotate(refraction + layer * 0.1);

                const crystalGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, layerSize);
                crystalGradient.addColorStop(0, `rgba(165, 243, 252, ${layerAlpha})`);
                crystalGradient.addColorStop(0.6, `rgba(6, 182, 212, ${layerAlpha * 0.8})`);
                crystalGradient.addColorStop(1, `rgba(8, 145, 178, ${layerAlpha * 0.6})`);

                ctx.beginPath();
                for (let i = 0; i < facets; i++) {
                    const angle = (i * Math.PI * 2) / facets;
                    const x = Math.cos(angle) * layerSize;
                    const y = Math.sin(angle) * layerSize;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fillStyle = crystalGradient;
                ctx.fill();

                // Facet edges
                ctx.strokeStyle = `rgba(165, 243, 252, ${layerAlpha * 0.6})`;
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.restore();
            }
            ctx.restore();

            // Refraction highlights
            for (let i = 0; i < 3; i++) {
                const highlightAngle = refraction + (i * Math.PI * 2) / 3;
                const highlightX = Math.cos(highlightAngle) * currentSize * 0.6;
                const highlightY = Math.sin(highlightAngle) * currentSize * 0.6;

                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                ctx.beginPath();
                ctx.arc(highlightX, highlightY, 3, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.shadowColor = '#06B6D4';
                ctx.shadowBlur = 8;
                ctx.fill();
                ctx.restore();
            }
        };

        const drawPlasmaDancerUnit = (unit, glowIntensity) => {
            const pulse = 1 + Math.sin(animationTime * 4 + (unit.animationOffset || 0)) * 0.25;
            const currentSize = unit.size * pulse;
            const flow = animationTime * 2;

            // Plasma wisps flowing around center
            for (let i = 0; i < 6; i++) {
                const wispAngle = flow + (i * Math.PI * 2) / 6;
                const wispRadius = currentSize * (1.2 + Math.sin(flow + i) * 0.3);
                const wispX = Math.cos(wispAngle) * wispRadius;
                const wispY = Math.sin(wispAngle) * wispRadius;

                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                ctx.strokeStyle = `rgba(236, 72, 153, ${0.6 + Math.sin(flow * 2 + i) * 0.3})`;
                ctx.lineWidth = 4;
                ctx.shadowColor = '#EC4899';
                ctx.shadowBlur = 15;

                // Draw flowing wisp
                ctx.beginPath();
                ctx.moveTo(0, 0);
                const cp1x = wispX * 0.3;
                const cp1y = wispY * 0.3 + Math.sin(flow * 3 + i) * 15;
                const cp2x = wispX * 0.7;
                const cp2y = wispY * 0.7 + Math.cos(flow * 2 + i) * 10;
                ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, wispX, wispY);
                ctx.stroke();
                ctx.restore();
            }

            // Central plasma core
            ctx.save();
            ctx.shadowColor = '#EC4899';
            ctx.shadowBlur = 25 * glowIntensity;

            const plasmaGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize * 0.8);
            plasmaGradient.addColorStop(0, 'rgba(251, 207, 232, 1.0)');
            plasmaGradient.addColorStop(0.5, 'rgba(236, 72, 153, 0.8)');
            plasmaGradient.addColorStop(1, 'rgba(190, 24, 93, 0.4)');

            // Irregular plasma shape
            ctx.beginPath();
            for (let i = 0; i <= 16; i++) {
                const angle = (i * Math.PI * 2) / 16;
                const variation = 1 + Math.sin(angle * 4 + flow) * 0.2;
                const radius = currentSize * 0.8 * variation;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fillStyle = plasmaGradient;
            ctx.fill();
            ctx.restore();
        };

        const drawDefaultUnit = (unit, glowIntensity) => {
            // Fallback design for unknown unit types
            const pulse = 1 + Math.sin(animationTime * 2 + (unit.animationOffset || 0)) * 0.15;
            const currentSize = unit.size * pulse;

            ctx.save();
            ctx.shadowColor = '#6B7280';
            ctx.shadowBlur = 15 * glowIntensity;

            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize);
            gradient.addColorStop(0, 'rgba(156, 163, 175, 1.0)');
            gradient.addColorStop(0.6, 'rgba(107, 114, 128, 0.9)');
            gradient.addColorStop(1, 'rgba(75, 85, 99, 0.7)');

            ctx.beginPath();
            ctx.arc(0, 0, currentSize, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.restore();
        };

        // --- TDD: Intelligent Creatures System ---

        let creatureIdCounter = 0;

        const createIntelligentCreature = (type, x, y) => {
            const creature = {
                id: `creature_${creatureIdCounter++}`,
                type: type,
                x: x,
                y: y,
                size: 30,
                intelligence: 100,
                memory: [],
                goals: [],
                currentGoal: null,
                personality: {
                    curiosity: Math.random(),
                    sociability: Math.random(),
                    productivity: Math.random(),
                    exploration: Math.random()
                },
                state: 'idle',
                energy: 100,
                lastDecision: 0,
                decisionCooldown: 3000, // 3 seconds between decisions
                perceptionRadius: 120,
                movementSpeed: 25,
                targetX: x,
                targetY: y,
                vx: 0,
                vy: 0,
                animationOffset: Math.random() * Math.PI * 2,
                relationships: new Map()
            };

            // Initialize based on creature type
            if (type === 'cosmicSage') {
                creature.specialAbilities = ['insight_generation', 'knowledge_sharing', 'meditation'];
                creature.preferredActivities = ['study', 'teach', 'contemplate'];
                creature.color = '#9333EA';
                creature.glowColor = '#A855F7';
            } else if (type === 'voidExplorer') {
                creature.specialAbilities = ['void_navigation', 'resource_discovery', 'pathfinding'];
                creature.preferredActivities = ['explore', 'scout', 'gather'];
                creature.color = '#1F2937';
                creature.glowColor = '#4B5563';
            } else if (type === 'harmonyKeeper') {
                creature.specialAbilities = ['harmony_restoration', 'conflict_resolution', 'healing'];
                creature.preferredActivities = ['mediate', 'heal', 'organize'];
                creature.color = '#059669';
                creature.glowColor = '#10B981';
            }

            return creature;
        };

        const spawnIntelligentCreature = (type) => {
            const x = Math.random() * (canvas.width - 200) + 100;
            const y = Math.random() * (canvas.height - 200) + 100;
            const creature = createIntelligentCreature(type, x, y);
            gameState.intelligentCreatures.push(creature);
            log(`A ${type} has awakened in the sanctuary!`, 'success');
            return creature;
        };

        const perceiveEnvironment = (creature) => {
            const perception = {
                nearbyUnits: [],
                nearbyResources: [],
                nearbyCreatures: [],
                threats: [],
                opportunities: [],
                environmentalFactors: {}
            };

            // Find nearby entities within perception radius
            gameState.villageGrid.forEach(entity => {
                const distance = Math.sqrt(
                    Math.pow(entity.x - creature.x, 2) +
                    Math.pow(entity.y - creature.y, 2)
                );

                if (distance <= creature.perceptionRadius) {
                    if (entity.movable) {
                        perception.nearbyUnits.push({
                            entity: entity,
                            distance: distance,
                            relationship: 'neutral'
                        });
                    } else {
                        perception.nearbyResources.push({
                            entity: entity,
                            distance: distance,
                            type: entity.type
                        });
                    }
                }
            });

            // Find other intelligent creatures
            gameState.intelligentCreatures.forEach(otherCreature => {
                if (otherCreature.id !== creature.id) {
                    const distance = Math.sqrt(
                        Math.pow(otherCreature.x - creature.x, 2) +
                        Math.pow(otherCreature.y - creature.y, 2)
                    );

                    if (distance <= creature.perceptionRadius) {
                        perception.nearbyCreatures.push({
                            creature: otherCreature,
                            distance: distance,
                            relationship: creature.relationships.get(otherCreature.id) || 'neutral'
                        });
                    }
                }
            });

            // Analyze environmental factors
            perception.environmentalFactors = {
                crowding: perception.nearbyUnits.length + perception.nearbyCreatures.length,
                resourceAvailability: perception.nearbyResources.length,
                harmonyLevel: gameState.harmony || 50,
                energyLevel: gameState.energy || 0,
                insightLevel: gameState.insight || 0
            };

            return perception;
        };

        const makeDecision = (creature, perception, currentTime) => {
            // Don't make decisions too frequently
            if (currentTime - creature.lastDecision < creature.decisionCooldown) {
                return creature.currentGoal;
            }

            const possibleGoals = [];

            // Generate goals based on creature type and personality
            if (creature.type === 'cosmicSage') {
                if (perception.nearbyUnits.length > 0 && creature.personality.sociability > 0.5) {
                    possibleGoals.push({
                        type: 'teach',
                        priority: creature.personality.sociability * 10,
                        target: perception.nearbyUnits[0].entity,
                        duration: 8000
                    });
                }

                if (perception.environmentalFactors.harmonyLevel < 70) {
                    possibleGoals.push({
                        type: 'meditate',
                        priority: (100 - perception.environmentalFactors.harmonyLevel) / 8,
                        target: null,
                        duration: 10000
                    });
                }

                if (perception.nearbyCreatures.length > 0 && creature.personality.sociability > 0.6) {
                    possibleGoals.push({
                        type: 'communicate',
                        priority: creature.personality.sociability * 8,
                        target: perception.nearbyCreatures[0].creature,
                        duration: 5000
                    });
                }
            }

            if (creature.type === 'voidExplorer') {
                if (creature.personality.exploration > 0.5) {
                    possibleGoals.push({
                        type: 'explore',
                        priority: creature.personality.exploration * 9,
                        target: {
                            x: Math.random() * (canvas.width - 100) + 50,
                            y: Math.random() * (canvas.height - 100) + 50
                        },
                        duration: 12000
                    });
                }

                if (perception.nearbyResources.length > 0) {
                    possibleGoals.push({
                        type: 'investigate',
                        priority: creature.personality.curiosity * 8,
                        target: perception.nearbyResources[0].entity,
                        duration: 6000
                    });
                }
            }

            if (creature.type === 'harmonyKeeper') {
                if (perception.environmentalFactors.harmonyLevel < 80) {
                    possibleGoals.push({
                        type: 'restore_harmony',
                        priority: (100 - perception.environmentalFactors.harmonyLevel) / 6,
                        target: null,
                        duration: 8000
                    });
                }

                if (perception.nearbyUnits.length > 2) {
                    possibleGoals.push({
                        type: 'organize',
                        priority: perception.nearbyUnits.length * 2,
                        target: perception.nearbyUnits,
                        duration: 10000
                    });
                }
            }

            // Add idle goal as fallback
            possibleGoals.push({
                type: 'idle',
                priority: 1,
                target: null,
                duration: 5000
            });

            // Select highest priority goal
            possibleGoals.sort((a, b) => b.priority - a.priority);
            creature.currentGoal = possibleGoals[0];
            creature.lastDecision = currentTime;
            creature.state = creature.currentGoal.type;

            return creature.currentGoal;
        };

        const updateMemory = (creature, event) => {
            const memoryEntry = {
                timestamp: Date.now(),
                type: event.type,
                location: { x: creature.x, y: creature.y },
                data: event.data,
                importance: event.importance || 1
            };

            creature.memory.push(memoryEntry);

            // Keep memory size manageable
            const maxMemorySize = 30;
            if (creature.memory.length > maxMemorySize) {
                // Remove least important old memories
                creature.memory.sort((a, b) => {
                    const ageA = Date.now() - a.timestamp;
                    const ageB = Date.now() - b.timestamp;
                    const scoreA = a.importance - (ageA / 20000);
                    const scoreB = b.importance - (ageB / 20000);
                    return scoreB - scoreA;
                });
                creature.memory = creature.memory.slice(0, maxMemorySize);
            }
        };

        const executeBehavior = (creature, goal, deltaTime) => {
            if (!goal) return;

            switch (goal.type) {
                case 'teach':
                    if (goal.target && goal.target.movable) {
                        const distance = Math.sqrt(
                            Math.pow(goal.target.x - creature.x, 2) +
                            Math.pow(goal.target.y - creature.y, 2)
                        );

                        if (distance > 60) {
                            // Move closer to target
                            creature.targetX = goal.target.x;
                            creature.targetY = goal.target.y;
                        } else {
                            // Teaching effect
                            if (!goal.target.teachingBoost || Date.now() - goal.target.teachingBoost.timestamp > 30000) {
                                goal.target.teachingBoost = {
                                    multiplier: 1.3,
                                    duration: 30000,
                                    timestamp: Date.now()
                                };

                                updateMemory(creature, {
                                    type: 'teaching_completed',
                                    data: { targetId: goal.target.id },
                                    importance: 3
                                });

                                creature.intelligence = Math.min(200, creature.intelligence + 1);
                            }
                        }
                    }
                    break;

                case 'meditate':
                    // Stay still and generate harmony
                    creature.targetX = creature.x;
                    creature.targetY = creature.y;

                    if (Math.random() < 0.02) { // 2% chance per frame
                        gameState.harmony = Math.min(100, gameState.harmony + 0.5);
                        gameState.insight = Math.min(gameState.insight + 0.2, gameState.insight + 0.2);
                    }
                    break;

                case 'explore':
                    if (goal.target) {
                        creature.targetX = goal.target.x;
                        creature.targetY = goal.target.y;

                        const distance = Math.sqrt(
                            Math.pow(goal.target.x - creature.x, 2) +
                            Math.pow(goal.target.y - creature.y, 2)
                        );

                        if (distance < 20) {
                            // Reached exploration target
                            updateMemory(creature, {
                                type: 'area_explored',
                                data: { location: { x: creature.x, y: creature.y } },
                                importance: 2
                            });

                            // Small chance to discover resources
                            if (Math.random() < 0.1) {
                                gameState.energy += 5;
                                log(`${creature.type} discovered energy while exploring!`, 'info');
                            }
                        }
                    }
                    break;

                case 'investigate':
                    if (goal.target) {
                        const distance = Math.sqrt(
                            Math.pow(goal.target.x - creature.x, 2) +
                            Math.pow(goal.target.y - creature.y, 2)
                        );

                        if (distance > 40) {
                            creature.targetX = goal.target.x;
                            creature.targetY = goal.target.y;
                        } else {
                            // Investigation complete
                            updateMemory(creature, {
                                type: 'resource_investigated',
                                data: { resourceType: goal.target.type, location: { x: goal.target.x, y: goal.target.y } },
                                importance: 4
                            });
                        }
                    }
                    break;

                case 'restore_harmony':
                    // Harmony restoration effect
                    if (Math.random() < 0.03) { // 3% chance per frame
                        gameState.harmony = Math.min(100, gameState.harmony + 1);

                        // Boost nearby units
                        gameState.villageGrid.forEach(entity => {
                            if (entity.movable) {
                                const distance = Math.sqrt(
                                    Math.pow(entity.x - creature.x, 2) +
                                    Math.pow(entity.y - creature.y, 2)
                                );

                                if (distance <= 80) {
                                    entity.harmonyBoost = {
                                        multiplier: 1.15,
                                        duration: 20000,
                                        timestamp: Date.now()
                                    };
                                }
                            }
                        });
                    }
                    break;

                case 'communicate':
                    if (goal.target) {
                        const distance = Math.sqrt(
                            Math.pow(goal.target.x - creature.x, 2) +
                            Math.pow(goal.target.y - creature.y, 2)
                        );

                        if (distance <= 70) {
                            // Share knowledge
                            const recentMemories = creature.memory.slice(-2);
                            recentMemories.forEach(memory => {
                                if (!goal.target.memory.some(m =>
                                    m.type === memory.type &&
                                    Math.abs(m.timestamp - memory.timestamp) < 2000
                                )) {
                                    goal.target.memory.push({
                                        ...memory,
                                        source: creature.id,
                                        shared: true
                                    });
                                }
                            });

                            // Improve relationship
                            creature.relationships.set(goal.target.id, 'friendly');
                            goal.target.relationships.set(creature.id, 'friendly');

                            // Both gain intelligence
                            creature.intelligence = Math.min(200, creature.intelligence + 0.5);
                            goal.target.intelligence = Math.min(200, goal.target.intelligence + 0.5);
                        }
                    }
                    break;

                case 'idle':
                default:
                    // Gentle wandering
                    const wanderRadius = 40;
                    creature.targetX = creature.x + (Math.random() - 0.5) * wanderRadius;
                    creature.targetY = creature.y + (Math.random() - 0.5) * wanderRadius;

                    // Keep within bounds
                    creature.targetX = Math.max(50, Math.min(canvas.width - 50, creature.targetX));
                    creature.targetY = Math.max(50, Math.min(canvas.height - 50, creature.targetY));
                    break;
            }
        };

        const updateIntelligentCreatures = (deltaTime) => {
            const currentTime = Date.now();

            gameState.intelligentCreatures.forEach(creature => {
                // Perception and decision making
                const perception = perceiveEnvironment(creature);
                const goal = makeDecision(creature, perception, currentTime);

                // Execute current behavior
                executeBehavior(creature, goal, deltaTime);

                // Update movement
                const dx = creature.targetX - creature.x;
                const dy = creature.targetY - creature.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 2) {
                    const speed = creature.movementSpeed;
                    const moveDistance = speed * deltaTime;
                    const ratio = Math.min(moveDistance / distance, 1);

                    creature.x += dx * ratio;
                    creature.y += dy * ratio;
                    creature.vx = dx * ratio / deltaTime;
                    creature.vy = dy * ratio / deltaTime;
                } else {
                    creature.vx = 0;
                    creature.vy = 0;
                }

                // Update goal duration
                if (goal && goal.startTime) {
                    if (currentTime - goal.startTime > goal.duration) {
                        creature.currentGoal = null;
                        creature.state = 'idle';
                    }
                } else if (goal) {
                    goal.startTime = currentTime;
                }
            });
        };

        const drawIntelligentCreatures = () => {
            gameState.intelligentCreatures.forEach(creature => {
                drawIntelligentCreature(creature);
            });
        };

        const drawIntelligentCreature = (creature) => {
            ctx.save();
            ctx.translate(creature.x, creature.y);

            const pulse = 1 + Math.sin(animationTime * 1.5 + creature.animationOffset) * 0.1;
            const currentSize = creature.size * pulse;

            // Intelligence aura - larger and more complex than regular units
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            ctx.shadowColor = creature.glowColor;
            ctx.shadowBlur = 35;

            const auraGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize * 2.5);
            const r = parseInt(creature.glowColor.slice(1,3), 16);
            const g = parseInt(creature.glowColor.slice(3,5), 16);
            const b = parseInt(creature.glowColor.slice(5,7), 16);

            auraGradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.3)`);
            auraGradient.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, 0.15)`);
            auraGradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);

            ctx.beginPath();
            ctx.arc(0, 0, currentSize * 2.5, 0, Math.PI * 2);
            ctx.fillStyle = auraGradient;
            ctx.fill();
            ctx.restore();

            // Main creature body - distinctive shape based on type
            if (creature.type === 'cosmicSage') {
                drawCosmicSage(creature, currentSize);
            } else if (creature.type === 'voidExplorer') {
                drawVoidExplorer(creature, currentSize);
            } else if (creature.type === 'harmonyKeeper') {
                drawHarmonyKeeper(creature, currentSize);
            }

            // Intelligence indicator - neural network pattern
            if (creature.intelligence > 100) {
                drawIntelligenceIndicator(creature, currentSize);
            }

            // State indicator
            drawStateIndicator(creature, currentSize);

            ctx.restore();
        };

        const drawCosmicSage = (creature, size) => {
            // Multi-layered mandala design
            ctx.save();
            ctx.shadowColor = creature.glowColor;
            ctx.shadowBlur = 25;

            // Outer ring with rotating symbols
            const rotation = animationTime * 0.3;
            for (let i = 0; i < 8; i++) {
                const angle = (i * Math.PI * 2 / 8) + rotation;
                const symbolX = Math.cos(angle) * size * 1.5;
                const symbolY = Math.sin(angle) * size * 1.5;

                ctx.save();
                ctx.translate(symbolX, symbolY);
                ctx.rotate(angle + Math.PI / 2);
                ctx.fillStyle = creature.glowColor;
                ctx.font = '12px serif';
                ctx.textAlign = 'center';
                ctx.fillText('‚óä', 0, 4);
                ctx.restore();
            }

            // Main body - complex geometric pattern
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
            const r = parseInt(creature.color.slice(1,3), 16);
            const g = parseInt(creature.color.slice(3,5), 16);
            const b = parseInt(creature.color.slice(5,7), 16);

            gradient.addColorStop(0, `rgba(${Math.min(255, r + 50)}, ${Math.min(255, g + 50)}, ${Math.min(255, b + 50)}, 1.0)`);
            gradient.addColorStop(0.6, `rgba(${r}, ${g}, ${b}, 0.9)`);
            gradient.addColorStop(1, `rgba(${Math.max(0, r - 30)}, ${Math.max(0, g - 30)}, ${Math.max(0, b - 30)}, 0.7)`);

            // Draw complex star pattern
            ctx.beginPath();
            for (let i = 0; i < 12; i++) {
                const angle = (i * Math.PI * 2) / 12;
                const radius = i % 2 === 0 ? size : size * 0.6;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fillStyle = gradient;
            ctx.fill();

            // Inner wisdom eye
            ctx.beginPath();
            ctx.arc(0, 0, size * 0.3, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.fill();

            ctx.beginPath();
            ctx.arc(0, 0, size * 0.15, 0, Math.PI * 2);
            ctx.fillStyle = creature.color;
            ctx.fill();

            ctx.restore();
        };

        const drawVoidExplorer = (creature, size) => {
            // Shifting, ethereal form
            ctx.save();
            ctx.shadowColor = creature.glowColor;
            ctx.shadowBlur = 20;

            const shift = Math.sin(animationTime * 2) * 0.2;

            // Main body - irregular, shifting shape
            ctx.beginPath();
            for (let i = 0; i <= 16; i++) {
                const angle = (i * Math.PI * 2) / 16;
                const variation = 1 + Math.sin(angle * 3 + animationTime * 1.5) * shift;
                const radius = size * variation;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();

            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
            const r = parseInt(creature.color.slice(1,3), 16);
            const g = parseInt(creature.color.slice(3,5), 16);
            const b = parseInt(creature.color.slice(5,7), 16);

            gradient.addColorStop(0, `rgba(${r + 40}, ${g + 40}, ${b + 40}, 0.8)`);
            gradient.addColorStop(0.7, `rgba(${r}, ${g}, ${b}, 0.6)`);
            gradient.addColorStop(1, `rgba(${r - 20}, ${g - 20}, ${b - 20}, 0.3)`);

            ctx.fillStyle = gradient;
            ctx.fill();

            // Void tendrils
            for (let i = 0; i < 4; i++) {
                const tendrilAngle = (i * Math.PI * 2 / 4) + animationTime * 0.5;
                const tendrilLength = size * (1.2 + Math.sin(animationTime * 2 + i) * 0.3);

                ctx.save();
                ctx.rotate(tendrilAngle);
                ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.6)`;
                ctx.lineWidth = 3;
                ctx.shadowBlur = 10;

                ctx.beginPath();
                ctx.moveTo(size * 0.7, 0);

                const segments = 5;
                for (let j = 1; j <= segments; j++) {
                    const t = j / segments;
                    const segmentX = size * 0.7 + tendrilLength * t;
                    const wave = Math.sin(t * Math.PI * 2 + animationTime * 3 + i) * 8;
                    const segmentY = wave;

                    if (j === 1) {
                        ctx.lineTo(segmentX, segmentY);
                    } else {
                        const prevT = (j - 1) / segments;
                        const prevX = size * 0.7 + tendrilLength * prevT;
                        const prevWave = Math.sin(prevT * Math.PI * 2 + animationTime * 3 + i) * 8;

                        const cp1x = prevX + (segmentX - prevX) * 0.5;
                        const cp1y = prevWave;
                        const cp2x = segmentX - (segmentX - prevX) * 0.5;
                        const cp2y = segmentY;

                        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, segmentX, segmentY);
                    }
                }
                ctx.stroke();
                ctx.restore();
            }

            ctx.restore();
        };

        const drawHarmonyKeeper = (creature, size) => {
            // Flowing, organic form with healing energy
            ctx.save();
            ctx.shadowColor = creature.glowColor;
            ctx.shadowBlur = 30;

            // Main body - organic, flowing shape
            const flow = animationTime * 1.2;
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
            const r = parseInt(creature.color.slice(1,3), 16);
            const g = parseInt(creature.color.slice(3,5), 16);
            const b = parseInt(creature.color.slice(5,7), 16);

            gradient.addColorStop(0, `rgba(${Math.min(255, r + 60)}, ${Math.min(255, g + 60)}, ${Math.min(255, b + 60)}, 1.0)`);
            gradient.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, 0.9)`);
            gradient.addColorStop(1, `rgba(${Math.max(0, r - 20)}, ${Math.max(0, g - 20)}, ${Math.max(0, b - 20)}, 0.6)`);

            // Draw flowing petals
            for (let i = 0; i < 6; i++) {
                const petalAngle = (i * Math.PI * 2 / 6) + flow * 0.2;
                const petalSize = size * (0.8 + Math.sin(flow + i) * 0.2);

                ctx.save();
                ctx.rotate(petalAngle);
                ctx.beginPath();
                ctx.ellipse(petalSize * 0.5, 0, petalSize * 0.6, petalSize * 0.3, 0, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
                ctx.restore();
            }

            // Central harmony core
            ctx.beginPath();
            ctx.arc(0, 0, size * 0.4, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(${Math.min(255, r + 80)}, ${Math.min(255, g + 80)}, ${Math.min(255, b + 80)}, 0.9)`;
            ctx.fill();

            // Healing energy waves
            for (let i = 0; i < 3; i++) {
                const waveRadius = size * (1.5 + i * 0.5) + Math.sin(flow * 2 - i) * 10;
                const waveAlpha = 0.3 - i * 0.1;

                ctx.beginPath();
                ctx.arc(0, 0, waveRadius, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${waveAlpha})`;
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            ctx.restore();
        };

        const drawIntelligenceIndicator = (creature, size) => {
            // Neural network pattern for high intelligence
            if (creature.intelligence <= 100) return;

            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            ctx.strokeStyle = `rgba(255, 255, 255, 0.4)`;
            ctx.lineWidth = 1;

            const nodes = 6;
            const nodePositions = [];

            // Create node positions
            for (let i = 0; i < nodes; i++) {
                const angle = (i * Math.PI * 2) / nodes;
                const radius = size * 0.8;
                nodePositions.push({
                    x: Math.cos(angle) * radius,
                    y: Math.sin(angle) * radius
                });
            }

            // Draw connections
            for (let i = 0; i < nodes; i++) {
                for (let j = i + 1; j < nodes; j++) {
                    if (Math.random() < 0.6) { // 60% chance of connection
                        ctx.beginPath();
                        ctx.moveTo(nodePositions[i].x, nodePositions[i].y);
                        ctx.lineTo(nodePositions[j].x, nodePositions[j].y);
                        ctx.stroke();
                    }
                }
            }

            // Draw nodes
            nodePositions.forEach(pos => {
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 2, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.fill();
            });

            ctx.restore();
        };

        const drawStateIndicator = (creature, size) => {
            // Small indicator showing current state
            ctx.save();
            ctx.translate(0, -size * 1.3);

            let stateColor = '#FFFFFF';
            let stateSymbol = '‚óè';

            switch (creature.state) {
                case 'teach':
                    stateColor = '#F59E0B';
                    stateSymbol = 'üìö';
                    break;
                case 'meditate':
                    stateColor = '#8B5CF6';
                    stateSymbol = 'üßò';
                    break;
                case 'explore':
                    stateColor = '#10B981';
                    stateSymbol = 'üîç';
                    break;
                case 'investigate':
                    stateColor = '#06B6D4';
                    stateSymbol = 'üî¨';
                    break;
                case 'restore_harmony':
                    stateColor = '#059669';
                    stateSymbol = '‚ú®';
                    break;
                case 'communicate':
                    stateColor = '#EC4899';
                    stateSymbol = 'üí¨';
                    break;
            }

            if (creature.state !== 'idle') {
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillStyle = stateColor;
                ctx.shadowColor = stateColor;
                ctx.shadowBlur = 5;
                ctx.fillText(stateSymbol, 0, 5);
            }

            ctx.restore();
        };

        // --- TDD: Conversational AI Units System ---

        let conversationalUnitIdCounter = 0;

        const createConversationalUnit = (type, x, y) => {
            const unit = {
                id: `conv_${conversationalUnitIdCounter++}`,
                type: type,
                x: x,
                y: y,
                size: 25,
                conversational: true,
                personality: {
                    traits: [],
                    mood: 'neutral',
                    creativity: 0.3 + Math.random() * 0.7,
                    empathy: 0.3 + Math.random() * 0.7,
                    curiosity: 0.3 + Math.random() * 0.7,
                    wisdom: 0.3 + Math.random() * 0.7
                },
                dialogue: {
                    currentTopic: null,
                    conversationHistory: [],
                    lastSpoke: 0,
                    speakingCooldown: 8000,
                    preferredTopics: [],
                    memories: [],
                    relationships: new Map(),
                    currentThought: null,
                    thoughtBubbleVisible: false
                },
                needs: {
                    current: [],
                    fulfilled: [],
                    priority: 'low'
                },
                creativity: {
                    ideas: [],
                    projects: [],
                    inspirationLevel: 30 + Math.random() * 40
                },
                specialOffers: [],
                state: 'idle',
                playerRelationship: 0.1,
                animationOffset: Math.random() * Math.PI * 2,
                thoughtTimer: 0,
                nextThoughtTime: 5000 + Math.random() * 10000
            };

            // Initialize based on unit type
            if (type === 'philosopherDreamer') {
                unit.personality.traits = ['contemplative', 'wise', 'patient', 'deep-thinking'];
                unit.dialogue.preferredTopics = ['existence', 'dreams', 'cosmic_mysteries', 'consciousness'];
                unit.specialOffers = ['dream_interpretation', 'philosophical_guidance', 'meditation_session'];
                unit.color = '#6366F1';
                unit.glowColor = '#8B5CF6';
            } else if (type === 'artisticWeaver') {
                unit.personality.traits = ['creative', 'expressive', 'passionate', 'imaginative'];
                unit.dialogue.preferredTopics = ['art', 'beauty', 'creation', 'inspiration'];
                unit.specialOffers = ['custom_artwork', 'creative_collaboration', 'aesthetic_enhancement'];
                unit.color = '#EC4899';
                unit.glowColor = '#F472B6';
            } else if (type === 'curiousExplorer') {
                unit.personality.traits = ['inquisitive', 'adventurous', 'energetic', 'observant'];
                unit.dialogue.preferredTopics = ['discoveries', 'mysteries', 'exploration', 'unknown'];
                unit.specialOffers = ['guided_exploration', 'mystery_solving', 'treasure_hunting'];
                unit.color = '#10B981';
                unit.glowColor = '#34D399';
            }

            return unit;
        };

        const spawnConversationalUnit = (type) => {
            const x = Math.random() * (canvas.width - 200) + 100;
            const y = Math.random() * (canvas.height - 200) + 100;
            const unit = createConversationalUnit(type, x, y);
            gameState.conversationalUnits.push(unit);
            log(`A ${type} awakens and begins to contemplate the sanctuary...`, 'success');
            return unit;
        };

        const generateThought = (unit) => {
            const thoughts = {
                philosopherDreamer: [
                    "What dreams shape reality in this cosmic sanctuary?",
                    "I sense the interconnectedness of all beings here...",
                    "The harmony flows like a river of consciousness.",
                    "Perhaps existence itself is but a shared dream?",
                    "I wonder what wisdom the stars whisper tonight..."
                ],
                artisticWeaver: [
                    "The colors of energy here inspire new creations!",
                    "I could weave beauty from these cosmic threads...",
                    "Art is the language the universe speaks to itself.",
                    "What masterpiece shall we create together?",
                    "Beauty exists in every particle of this sanctuary."
                ],
                curiousExplorer: [
                    "What mysteries lie hidden in the sanctuary's depths?",
                    "I sense something fascinating just beyond perception...",
                    "Every corner holds a new discovery waiting!",
                    "The unknown calls to me with irresistible allure.",
                    "Adventure and wonder await those who seek!"
                ]
            };

            const typeThoughts = thoughts[unit.type] || ["I contemplate the mysteries of existence..."];
            return typeThoughts[Math.floor(Math.random() * typeThoughts.length)];
        };

        const updateConversationalUnits = (deltaTime) => {
            const currentTime = Date.now();

            gameState.conversationalUnits.forEach(unit => {
                // Update thought timer
                unit.thoughtTimer += deltaTime * 1000;

                // Generate new thoughts periodically
                if (unit.thoughtTimer >= unit.nextThoughtTime) {
                    unit.dialogue.currentThought = generateThought(unit);
                    unit.dialogue.thoughtBubbleVisible = true;
                    unit.thoughtTimer = 0;
                    unit.nextThoughtTime = 8000 + Math.random() * 15000; // 8-23 seconds

                    // Hide thought bubble after a while
                    setTimeout(() => {
                        unit.dialogue.thoughtBubbleVisible = false;
                    }, 4000);
                }

                // Update needs based on game state
                updateUnitNeeds(unit);

                // Generate creative ideas periodically
                if (Math.random() < 0.001 && unit.creativity.inspirationLevel > 60) { // 0.1% chance per frame
                    generateCreativeIdea(unit);
                }

                // Gentle movement
                if (Math.random() < 0.005) { // 0.5% chance per frame to move
                    const moveRadius = 30;
                    unit.targetX = unit.x + (Math.random() - 0.5) * moveRadius;
                    unit.targetY = unit.y + (Math.random() - 0.5) * moveRadius;

                    // Keep within bounds
                    unit.targetX = Math.max(50, Math.min(canvas.width - 50, unit.targetX));
                    unit.targetY = Math.max(50, Math.min(canvas.height - 50, unit.targetY));
                }

                // Simple movement towards target
                if (unit.targetX && unit.targetY) {
                    const dx = unit.targetX - unit.x;
                    const dy = unit.targetY - unit.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance > 2) {
                        const speed = 15; // Slow, contemplative movement
                        const moveDistance = speed * deltaTime;
                        const ratio = Math.min(moveDistance / distance, 1);

                        unit.x += dx * ratio;
                        unit.y += dy * ratio;
                    }
                }
            });
        };

        const updateUnitNeeds = (unit) => {
            unit.needs.current = [];

            // Generate needs based on game state
            if (gameState.harmony < 50) {
                unit.needs.current.push({
                    type: 'harmony_restoration',
                    urgency: 'high',
                    description: 'The sanctuary feels discordant. I need to help restore balance.'
                });
            }

            if (gameState.energy < 30) {
                unit.needs.current.push({
                    type: 'energy_boost',
                    urgency: 'medium',
                    description: 'The energy flows are weak. We need to revitalize them.'
                });
            }

            // Type-specific needs
            if (unit.type === 'artisticWeaver' && unit.creativity.inspirationLevel < 40) {
                unit.needs.current.push({
                    type: 'inspiration',
                    urgency: 'medium',
                    description: 'I need more beauty and inspiration to create meaningful art.'
                });
            }

            if (unit.type === 'philosopherDreamer' && gameState.insight < 20) {
                unit.needs.current.push({
                    type: 'contemplation_space',
                    urgency: 'low',
                    description: 'I require quiet contemplation to generate deeper insights.'
                });
            }
        };

        const generateCreativeIdea = (unit) => {
            const ideas = [];
            const creativityScore = unit.personality.creativity * (unit.creativity.inspirationLevel / 100);

            if (creativityScore > 0.6) {
                if (unit.type === 'artisticWeaver') {
                    ideas.push({
                        type: 'artistic_creation',
                        title: 'Harmony Tapestry',
                        description: 'A living tapestry that visualizes the sanctuary\'s energy flows',
                        requirements: { insight: 30, harmony: 60 },
                        effects: { beauty: 20, harmony_generation: 0.5 },
                        timeToComplete: 120000
                    });
                } else if (unit.type === 'philosopherDreamer') {
                    ideas.push({
                        type: 'philosophical_insight',
                        title: 'Meditation Garden Design',
                        description: 'A sacred space layout that enhances contemplation and wisdom',
                        requirements: { energy: 25, insight: 40 },
                        effects: { wisdom_boost: 1.3, meditation_efficiency: 1.5 },
                        timeToComplete: 180000
                    });
                }
            }

            if (ideas.length > 0) {
                unit.creativity.ideas.push(...ideas);
                log(`${unit.type} has a creative inspiration!`, 'info');
            }
        };

        const generateLLMDialogue = async (unit, playerInput = null) => {
            // Simulate LLM response for now (in real implementation, this would call the actual LLM API)
            const responses = {
                philosopherDreamer: {
                    greeting: [
                        "Ah, seeker of wisdom, I sense your curiosity about the cosmic mysteries. Would you like me to share a dream vision I had about the sanctuary's future?",
                        "Welcome, contemplative soul. I've been pondering the nature of existence in this sacred space. What brings you to seek conversation?",
                        "Greetings, fellow traveler of consciousness. I feel the harmony flowing between us. Shall we explore the deeper meanings together?"
                    ],
                    needs: [
                        "I sense discord in the sanctuary's harmony. Perhaps we could work together to restore the cosmic balance?",
                        "The energy flows seem diminished. I could guide a meditation to revitalize our shared space, if you're willing.",
                        "I've been contemplating ways to enhance our sanctuary's wisdom. Would you be interested in a philosophical collaboration?"
                    ],
                    creative: [
                        "I've envisioned a magnificent meditation garden that could transform how we experience consciousness here. Shall I share this dream with you?",
                        "In my contemplations, I've discovered a method to weave dreams into reality. Would you like to explore this possibility together?",
                        "I sense great potential for a consciousness bridge that could unite all beings in the sanctuary. Are you ready for such a profound undertaking?"
                    ]
                },
                artisticWeaver: {
                    greeting: [
                        "Oh, what beautiful energy you bring! I can see colors dancing around you that inspire new creations. Would you like to co-create something magnificent?",
                        "Welcome, kindred spirit! I've been weaving patterns of light and sound. Your presence adds such wonderful new hues to my palette!",
                        "Greetings, fellow appreciator of beauty! I sense an artistic collaboration brewing between us. What masterpiece shall we birth together?"
                    ],
                    needs: [
                        "I'm yearning for more inspiration to fuel my creative fire. The sanctuary's beauty feeds my art - could we enhance it together?",
                        "My artistic vision sees potential for incredible beauty here, but I need more creative energy. Would you help me gather inspiration?",
                        "I feel the sanctuary calling for more aesthetic harmony. My art could transform this space - shall we begin a beautiful project?"
                    ],
                    creative: [
                        "I've conceived of a living tapestry that would make the sanctuary's energy visible as flowing art. Would you commission this masterpiece?",
                        "My imagination has birthed a cosmic sculpture that could boost everyone's creativity. Shall we bring this vision to life?",
                        "I dream of creating an interactive art installation where beauty itself becomes a source of power. Are you ready to make art that changes reality?"
                    ]
                },
                curiousExplorer: {
                    greeting: [
                        "Fascinating! A new consciousness to explore and understand! I've been mapping the hidden mysteries of this sanctuary. Want to join my next expedition?",
                        "Greetings, fellow seeker! I've discovered the most intriguing phenomena in the sanctuary's depths. Would you like to investigate them with me?",
                        "Welcome, adventurous spirit! I sense you have the curiosity for great discoveries. Shall we uncover the sanctuary's secrets together?"
                    ],
                    needs: [
                        "I've detected mysterious energy signatures that need investigation. Would you help me explore these fascinating anomalies?",
                        "My explorations have revealed hidden chambers of knowledge, but I need a companion to safely venture deeper. Are you brave enough?",
                        "I sense undiscovered treasures of wisdom scattered throughout the sanctuary. Shall we embark on a treasure hunt together?"
                    ],
                    creative: [
                        "I've mapped a route to dimensions beyond our current perception. Would you join me on an interdimensional exploration?",
                        "My investigations have revealed a method to unlock hidden abilities through discovery. Are you ready for such an adventure?",
                        "I've conceived of an exploration network that could reveal all the sanctuary's mysteries simultaneously. Shall we build it together?"
                    ]
                }
            };

            const unitResponses = responses[unit.type] || responses.philosopherDreamer;
            let responseCategory = 'greeting';

            if (unit.needs.current.length > 0) {
                responseCategory = 'needs';
            } else if (unit.creativity.ideas.length > 0) {
                responseCategory = 'creative';
            }

            const possibleResponses = unitResponses[responseCategory];
            const response = possibleResponses[Math.floor(Math.random() * possibleResponses.length)];

            // Update conversation history
            if (playerInput) {
                unit.dialogue.conversationHistory.push({
                    timestamp: Date.now(),
                    player: playerInput,
                    unit: response,
                    topic: unit.dialogue.currentTopic
                });
            }

            return response;
        };

        const drawConversationalUnits = () => {
            gameState.conversationalUnits.forEach(unit => {
                drawConversationalUnit(unit);
            });
        };

        const drawConversationalUnit = (unit) => {
            ctx.save();
            ctx.translate(unit.x, unit.y);

            const pulse = 1 + Math.sin(animationTime * 1.2 + unit.animationOffset) * 0.08;
            const currentSize = unit.size * pulse;

            // Consciousness aura - more ethereal than regular units
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            ctx.shadowColor = unit.glowColor;
            ctx.shadowBlur = 40;

            const auraGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize * 3);
            const r = parseInt(unit.glowColor.slice(1,3), 16);
            const g = parseInt(unit.glowColor.slice(3,5), 16);
            const b = parseInt(unit.glowColor.slice(5,7), 16);

            auraGradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.4)`);
            auraGradient.addColorStop(0.3, `rgba(${r}, ${g}, ${b}, 0.2)`);
            auraGradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);

            ctx.beginPath();
            ctx.arc(0, 0, currentSize * 3, 0, Math.PI * 2);
            ctx.fillStyle = auraGradient;
            ctx.fill();
            ctx.restore();

            // Draw unit based on type
            if (unit.type === 'philosopherDreamer') {
                drawPhilosopherDreamer(unit, currentSize);
            } else if (unit.type === 'artisticWeaver') {
                drawArtisticWeaver(unit, currentSize);
            } else if (unit.type === 'curiousExplorer') {
                drawCuriousExplorer(unit, currentSize);
            }

            // Draw thought bubble if visible
            if (unit.dialogue.thoughtBubbleVisible && unit.dialogue.currentThought) {
                drawThoughtBubble(unit, currentSize);
            }

            // Draw conversation indicator
            if (unit.dialogue.conversationHistory.length > 0) {
                drawConversationIndicator(unit, currentSize);
            }

            // Draw needs indicator
            if (unit.needs.current.length > 0) {
                drawNeedsIndicator(unit, currentSize);
            }

            ctx.restore();
        };

        const drawPhilosopherDreamer = (unit, size) => {
            // Ethereal, contemplative design with flowing energy
            ctx.save();
            ctx.shadowColor = unit.glowColor;
            ctx.shadowBlur = 30;

            // Main consciousness form - flowing, organic shape
            const flow = animationTime * 0.8;
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
            const r = parseInt(unit.color.slice(1,3), 16);
            const g = parseInt(unit.color.slice(3,5), 16);
            const b = parseInt(unit.color.slice(5,7), 16);

            gradient.addColorStop(0, `rgba(${Math.min(255, r + 80)}, ${Math.min(255, g + 80)}, ${Math.min(255, b + 80)}, 1.0)`);
            gradient.addColorStop(0.6, `rgba(${r}, ${g}, ${b}, 0.9)`);
            gradient.addColorStop(1, `rgba(${Math.max(0, r - 40)}, ${Math.max(0, g - 40)}, ${Math.max(0, b - 40)}, 0.6)`);

            // Draw flowing consciousness form
            ctx.beginPath();
            for (let i = 0; i <= 20; i++) {
                const angle = (i * Math.PI * 2) / 20;
                const variation = 1 + Math.sin(angle * 3 + flow) * 0.15;
                const radius = size * variation;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fillStyle = gradient;
            ctx.fill();

            // Wisdom symbols floating around
            for (let i = 0; i < 4; i++) {
                const symbolAngle = flow * 0.3 + (i * Math.PI * 2 / 4);
                const symbolRadius = size * 1.8;
                const symbolX = Math.cos(symbolAngle) * symbolRadius;
                const symbolY = Math.sin(symbolAngle) * symbolRadius;

                ctx.save();
                ctx.translate(symbolX, symbolY);
                ctx.rotate(symbolAngle);
                ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.7)`;
                ctx.font = '16px serif';
                ctx.textAlign = 'center';
                ctx.fillText(['‚óä', '‚óà', '‚óá', '‚óÜ'][i], 0, 5);
                ctx.restore();
            }

            // Central consciousness eye
            ctx.beginPath();
            ctx.arc(0, 0, size * 0.3, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.fill();

            ctx.beginPath();
            ctx.arc(0, 0, size * 0.15, 0, Math.PI * 2);
            ctx.fillStyle = unit.color;
            ctx.fill();

            ctx.restore();
        };

        const drawArtisticWeaver = (unit, size) => {
            // Creative, colorful design with artistic flair
            ctx.save();
            ctx.shadowColor = unit.glowColor;
            ctx.shadowBlur = 25;

            const creativity = animationTime * 1.5;

            // Main artistic form - dynamic, creative shape
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
            const r = parseInt(unit.color.slice(1,3), 16);
            const g = parseInt(unit.color.slice(3,5), 16);
            const b = parseInt(unit.color.slice(5,7), 16);

            gradient.addColorStop(0, `rgba(${Math.min(255, r + 60)}, ${Math.min(255, g + 60)}, ${Math.min(255, b + 60)}, 1.0)`);
            gradient.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, 0.9)`);
            gradient.addColorStop(1, `rgba(${Math.max(0, r - 30)}, ${Math.max(0, g - 30)}, ${Math.max(0, b - 30)}, 0.7)`);

            // Draw artistic petals/brushstrokes
            for (let i = 0; i < 8; i++) {
                const petalAngle = (i * Math.PI * 2 / 8) + creativity * 0.2;
                const petalLength = size * (0.8 + Math.sin(creativity + i) * 0.3);

                ctx.save();
                ctx.rotate(petalAngle);
                ctx.beginPath();
                ctx.ellipse(petalLength * 0.4, 0, petalLength * 0.6, petalLength * 0.2, 0, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
                ctx.restore();
            }

            // Central creative core
            ctx.beginPath();
            ctx.arc(0, 0, size * 0.5, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(${Math.min(255, r + 100)}, ${Math.min(255, g + 100)}, ${Math.min(255, b + 100)}, 0.9)`;
            ctx.fill();

            // Creative sparkles
            for (let i = 0; i < 6; i++) {
                const sparkleAngle = creativity * 2 + (i * Math.PI * 2 / 6);
                const sparkleRadius = size * (1.2 + Math.sin(creativity * 3 + i) * 0.2);
                const sparkleX = Math.cos(sparkleAngle) * sparkleRadius;
                const sparkleY = Math.sin(sparkleAngle) * sparkleRadius;

                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                ctx.beginPath();
                ctx.arc(sparkleX, sparkleY, 2, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.shadowColor = unit.glowColor;
                ctx.shadowBlur = 8;
                ctx.fill();
                ctx.restore();
            }

            ctx.restore();
        };

        const drawCuriousExplorer = (unit, size) => {
            // Dynamic, energetic design with exploration motifs
            ctx.save();
            ctx.shadowColor = unit.glowColor;
            ctx.shadowBlur = 20;

            const exploration = animationTime * 2;

            // Main explorer form - angular, dynamic
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
            const r = parseInt(unit.color.slice(1,3), 16);
            const g = parseInt(unit.color.slice(3,5), 16);
            const b = parseInt(unit.color.slice(5,7), 16);

            gradient.addColorStop(0, `rgba(${Math.min(255, r + 50)}, ${Math.min(255, g + 50)}, ${Math.min(255, b + 50)}, 1.0)`);
            gradient.addColorStop(0.6, `rgba(${r}, ${g}, ${b}, 0.9)`);
            gradient.addColorStop(1, `rgba(${Math.max(0, r - 25)}, ${Math.max(0, g - 25)}, ${Math.max(0, b - 25)}, 0.7)`);

            // Draw exploration compass design
            ctx.beginPath();
            for (let i = 0; i < 8; i++) {
                const angle = (i * Math.PI * 2) / 8;
                const radius = i % 2 === 0 ? size : size * 0.6;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fillStyle = gradient;
            ctx.fill();

            // Exploration rays
            for (let i = 0; i < 4; i++) {
                const rayAngle = exploration * 0.5 + (i * Math.PI * 2 / 4);
                const rayLength = size * (1.5 + Math.sin(exploration + i) * 0.3);

                ctx.save();
                ctx.rotate(rayAngle);
                ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.6)`;
                ctx.lineWidth = 2;
                ctx.shadowBlur = 10;

                ctx.beginPath();
                ctx.moveTo(size * 0.8, 0);
                ctx.lineTo(rayLength, 0);
                ctx.stroke();

                // Arrow tip
                ctx.beginPath();
                ctx.moveTo(rayLength, 0);
                ctx.lineTo(rayLength - 8, -4);
                ctx.lineTo(rayLength - 8, 4);
                ctx.closePath();
                ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.8)`;
                ctx.fill();

                ctx.restore();
            }

            // Central discovery core
            ctx.beginPath();
            ctx.arc(0, 0, size * 0.3, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(${Math.min(255, r + 70)}, ${Math.min(255, g + 70)}, ${Math.min(255, b + 70)}, 0.9)`;
            ctx.fill();

            ctx.restore();
        };

        const drawThoughtBubble = (unit, size) => {
            if (!unit.dialogue.currentThought) return;

            ctx.save();
            ctx.translate(0, -size * 2);

            // Bubble background
            const bubbleWidth = Math.min(200, unit.dialogue.currentThought.length * 8);
            const bubbleHeight = 40;

            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            ctx.strokeStyle = 'rgba(100, 100, 100, 0.8)';
            ctx.lineWidth = 2;
            ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
            ctx.shadowBlur = 10;

            // Rounded rectangle
            ctx.beginPath();
            ctx.roundRect(-bubbleWidth/2, -bubbleHeight/2, bubbleWidth, bubbleHeight, 15);
            ctx.fill();
            ctx.stroke();

            // Bubble tail
            ctx.beginPath();
            ctx.moveTo(0, bubbleHeight/2);
            ctx.lineTo(-10, bubbleHeight/2 + 15);
            ctx.lineTo(10, bubbleHeight/2 + 15);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Text
            ctx.fillStyle = '#333';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.shadowBlur = 0;

            // Word wrap
            const words = unit.dialogue.currentThought.split(' ');
            const lines = [];
            let currentLine = '';

            words.forEach(word => {
                const testLine = currentLine + (currentLine ? ' ' : '') + word;
                if (ctx.measureText(testLine).width < bubbleWidth - 20) {
                    currentLine = testLine;
                } else {
                    if (currentLine) lines.push(currentLine);
                    currentLine = word;
                }
            });
            if (currentLine) lines.push(currentLine);

            lines.forEach((line, index) => {
                ctx.fillText(line, 0, -lines.length * 6 + index * 12);
            });

            ctx.restore();
        };

        const drawConversationIndicator = (unit, size) => {
            // Small chat icon to show unit is conversational
            ctx.save();
            ctx.translate(size * 0.8, -size * 0.8);

            ctx.fillStyle = 'rgba(100, 200, 255, 0.8)';
            ctx.strokeStyle = 'rgba(50, 150, 255, 1.0)';
            ctx.lineWidth = 1;
            ctx.shadowColor = 'rgba(100, 200, 255, 0.5)';
            ctx.shadowBlur = 5;

            // Chat bubble icon
            ctx.beginPath();
            ctx.roundRect(-8, -6, 16, 12, 4);
            ctx.fill();
            ctx.stroke();

            // Chat dots
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(-4, 0, 1.5, 0, Math.PI * 2);
            ctx.arc(0, 0, 1.5, 0, Math.PI * 2);
            ctx.arc(4, 0, 1.5, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        };

        const drawNeedsIndicator = (unit, size) => {
            if (unit.needs.current.length === 0) return;

            ctx.save();
            ctx.translate(-size * 0.8, -size * 0.8);

            // Exclamation mark for needs
            const urgencyColor = unit.needs.current.some(n => n.urgency === 'high') ?
                'rgba(255, 100, 100, 0.9)' : 'rgba(255, 200, 100, 0.9)';

            ctx.fillStyle = urgencyColor;
            ctx.strokeStyle = 'rgba(200, 50, 50, 1.0)';
            ctx.lineWidth = 1;
            ctx.shadowColor = urgencyColor;
            ctx.shadowBlur = 5;

            // Exclamation background
            ctx.beginPath();
            ctx.arc(0, 0, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // Exclamation mark
            ctx.fillStyle = 'white';
            ctx.font = 'bold 12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('!', 0, 4);

            ctx.restore();
        };

        // Conversation interaction system
        let selectedConversationalUnit = null;
        let conversationDialog = null;

        const createConversationDialog = (unit) => {
            // Remove existing dialog
            if (conversationDialog) {
                conversationDialog.remove();
            }

            conversationDialog = document.createElement('div');
            conversationDialog.className = 'conversation-dialog';
            conversationDialog.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(135deg, rgba(30, 27, 75, 0.95), rgba(49, 46, 129, 0.95));
                border: 2px solid rgba(139, 92, 246, 0.5);
                border-radius: 15px;
                padding: 20px;
                max-width: 500px;
                width: 90%;
                color: white;
                font-family: 'Inter', sans-serif;
                box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
                backdrop-filter: blur(10px);
                z-index: 1000;
            `;

            conversationDialog.innerHTML = `
                <div style="display: flex; align-items: center; margin-bottom: 15px;">
                    <div style="width: 40px; height: 40px; border-radius: 50%; background: ${unit.color}; margin-right: 15px; display: flex; align-items: center; justify-content: center; font-size: 20px;">
                        ${unit.type === 'philosopherDreamer' ? 'üßô‚Äç‚ôÇÔ∏è' : unit.type === 'artisticWeaver' ? 'üé®' : 'üîç'}
                    </div>
                    <div>
                        <h3 style="margin: 0; color: #A78BFA;">${unit.type.replace(/([A-Z])/g, ' $1').trim()}</h3>
                        <p style="margin: 0; font-size: 12px; color: #C4B5FD;">Mood: ${unit.personality.mood} ‚Ä¢ Traits: ${unit.personality.traits.slice(0, 2).join(', ')}</p>
                    </div>
                    <button onclick="closeConversationDialog()" style="margin-left: auto; background: none; border: none; color: #9CA3AF; font-size: 20px; cursor: pointer;">√ó</button>
                </div>

                <div id="conversation-content" style="margin-bottom: 15px; max-height: 200px; overflow-y: auto;">
                    <div style="background: rgba(139, 92, 246, 0.2); padding: 10px; border-radius: 8px; margin-bottom: 10px;">
                        <div style="font-size: 12px; color: #A78BFA; margin-bottom: 5px;">${unit.type}:</div>
                        <div id="unit-response">Generating response...</div>
                    </div>
                </div>

                <div style="display: flex; gap: 10px;">
                    <input type="text" id="player-input" placeholder="What would you like to say?"
                           style="flex: 1; padding: 10px; border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 8px; background: rgba(0, 0, 0, 0.2); color: white;" />
                    <button onclick="sendMessage()" style="padding: 10px 20px; background: linear-gradient(45deg, #8B5CF6, #A855F7); border: none; border-radius: 8px; color: white; cursor: pointer;">Send</button>
                </div>

                ${unit.needs.current.length > 0 ? `
                    <div style="margin-top: 15px; padding: 10px; background: rgba(239, 68, 68, 0.1); border-radius: 8px; border-left: 4px solid #EF4444;">
                        <div style="font-size: 12px; color: #FCA5A5; margin-bottom: 5px;">Current Needs:</div>
                        ${unit.needs.current.map(need => `<div style="font-size: 11px; color: #FED7D7;">‚Ä¢ ${need.description}</div>`).join('')}
                    </div>
                ` : ''}

                ${unit.creativity.ideas.length > 0 ? `
                    <div style="margin-top: 15px; padding: 10px; background: rgba(236, 72, 153, 0.1); border-radius: 8px; border-left: 4px solid #EC4899;">
                        <div style="font-size: 12px; color: #F9A8D4; margin-bottom: 5px;">Creative Ideas:</div>
                        ${unit.creativity.ideas.slice(0, 2).map(idea => `<div style="font-size: 11px; color: #FBCFE8;">‚Ä¢ ${idea.title}: ${idea.description}</div>`).join('')}
                    </div>
                ` : ''}
            `;

            document.body.appendChild(conversationDialog);

            // Generate initial response
            generateLLMDialogue(unit).then(response => {
                document.getElementById('unit-response').textContent = response;
            });

            // Focus input
            document.getElementById('player-input').focus();

            // Enter key handler
            document.getElementById('player-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            });
        };

        // --- TDD: Unit Interactions & Synergy System ---

        const detectNearbyUnits = (unit, allUnits, interactionRadius = 60) => {
            const nearbyUnits = [];

            allUnits.forEach(otherUnit => {
                if (otherUnit.id === unit.id) return;

                const distance = Math.sqrt(
                    Math.pow(otherUnit.x - unit.x, 2) +
                    Math.pow(otherUnit.y - unit.y, 2)
                );

                if (distance <= interactionRadius) {
                    nearbyUnits.push({
                        unit: otherUnit,
                        distance: distance,
                        interactionType: determineInteractionType(unit, otherUnit)
                    });
                }
            });

            return nearbyUnits;
        };

        const determineInteractionType = (unit1, unit2) => {
            const interactions = {
                'dreamer-weaver': 'inspiration',
                'weaver-dreamer': 'inspiration',
                'philosopherDreamer-artisticWeaver': 'creative_collaboration',
                'artisticWeaver-philosopherDreamer': 'creative_collaboration',
                'curiousExplorer-philosopherDreamer': 'knowledge_sharing',
                'philosopherDreamer-curiousExplorer': 'knowledge_sharing'
            };

            const key1 = `${unit1.type}-${unit2.type}`;
            const key2 = `${unit2.type}-${unit1.type}`;

            return interactions[key1] || interactions[key2] || 'general_synergy';
        };

        const updateUnitInteractions = (deltaTime) => {
            const currentTime = Date.now();

            // Clean up expired interactions
            gameState.activeInteractions = gameState.activeInteractions.filter(interaction => {
                return currentTime - interaction.startTime < interaction.duration;
            });

            // Check for new interactions between all units
            const allUnits = [
                ...gameState.villageGrid.filter(unit => unit.movable),
                ...gameState.intelligentCreatures,
                ...gameState.conversationalUnits
            ];

            allUnits.forEach(unit => {
                const nearbyUnits = detectNearbyUnits(unit, allUnits);

                nearbyUnits.forEach(nearby => {
                    // Check if interaction already exists
                    const existingInteraction = gameState.activeInteractions.find(interaction =>
                        (interaction.participants.includes(unit.id) && interaction.participants.includes(nearby.unit.id))
                    );

                    if (!existingInteraction && Math.random() < 0.01) { // 1% chance per frame to start interaction
                        createInteraction(unit, nearby.unit, nearby.interactionType);
                    }
                });
            });

            // Apply interaction effects
            gameState.activeInteractions.forEach(interaction => {
                applyInteractionEffects(interaction, deltaTime);
            });
        };

        const createInteraction = (unit1, unit2, interactionType) => {
            const interaction = {
                id: `${unit1.id}_${unit2.id}_${Date.now()}`,
                participants: [unit1.id, unit2.id],
                type: interactionType,
                startTime: Date.now(),
                duration: 5000,
                effects: [],
                active: true
            };

            // Define interaction effects
            switch (interactionType) {
                case 'inspiration':
                    interaction.effects = [
                        { type: 'resource_generation', resource: 'inspiration', amount: 2 }
                    ];
                    break;

                case 'creative_collaboration':
                    interaction.effects = [
                        { type: 'resource_generation', resource: 'inspiration', amount: 3 },
                        { type: 'resource_generation', resource: 'insight', amount: 1 }
                    ];
                    break;

                case 'knowledge_sharing':
                    interaction.effects = [
                        { type: 'resource_generation', resource: 'wisdom', amount: 2 },
                        { type: 'resource_generation', resource: 'insight', amount: 1 }
                    ];
                    break;

                default:
                    interaction.effects = [
                        { type: 'resource_generation', resource: 'inspiration', amount: 1 }
                    ];
            }

            gameState.activeInteractions.push(interaction);
            log(`${unit1.type} and ${unit2.type} begin ${interactionType}!`, 'info');
        };

        const applyInteractionEffects = (interaction, deltaTime) => {
            interaction.effects.forEach(effect => {
                if (effect.type === 'resource_generation') {
                    const amount = effect.amount * deltaTime;
                    if (gameState[effect.resource] !== undefined) {
                        gameState[effect.resource] += amount;
                    }
                }
            });
        };

        // --- Grok API Integration with Popup ---
        async function callGrok(prompt, button, systemPrompt = "") {
            if (button) {
                button.disabled = true;
                button.classList.add('loading');
                button.innerHTML = 'AI is thinking...';
            }

            try {
                const apiKey = getApiKey();
                if (!apiKey) {
                    showApiKeyPopup();
                    throw new Error("API key required - popup shown");
                }

                const apiUrl = "https://api.x.ai/v1/chat/completions";
                const messages = [];

                if (systemPrompt) {
                    messages.push({ role: "system", content: systemPrompt });
                }
                messages.push({ role: "user", content: prompt });

                const payload = {
                    messages: messages,
                    model: "grok-beta",
                    stream: false,
                    temperature: 0.8
                };

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    throw new Error(`Grok API call failed: ${response.status} ${response.statusText}`);
                }

                const result = await response.json();
                return result.choices?.[0]?.message?.content || "The cosmic winds carry no clear message...";

            } catch (error) {
                console.error("Grok API Error:", error);
                if (error.message.includes("API key")) {
                    return "The Grok API key must be configured to access cosmic wisdom. Set your API key in the code.";
                }
                return "The aetheric connection is disrupted. The cosmic network seems unreachable.";
            } finally {
                if (button) {
                    button.disabled = false;
                    button.classList.remove('loading');
                    if(button.id === 'seasonal-vision-btn') button.innerHTML = '‚ú® Get Resonant Vision';
                    if(button.id === 'advisor-btn') button.innerHTML = 'üìú Ask Advisor';
                }
            }
        }
        async function getSeasonalVision() {
            const systemPrompt = "You are a mystical storyteller for Resonant Sanctuary: The Weaver, a cosmic incremental game. Create poetic, ethereal visions about the sanctuary's future or cosmic events. Use mystical language and keep responses to 2-3 sentences.";

            const prompt = `Current sanctuary state: Energy production ${gameState.energyPerSecond.toFixed(1)}/s, Insight production ${gameState.insightPerSecond.toFixed(1)}/s. The sanctuary houses ${gameState.units.dreamers} dreamers and ${gameState.units.weavers} weavers, with ${gameState.harmony.toFixed(1)}% harmony. Provide a mystical seasonal vision or cosmic forecast.`;

            const story = await callGrok(prompt, seasonalVisionBtn, systemPrompt);
            log(`‚ú® ${story}`, 'grok');
        }

        async function getAdvisorInsight() {
            const systemPrompt = "You are the Cosmic Advisor for Resonant Sanctuary: The Weaver. Provide brief, mystical advice using cosmic language. Always start responses with 'The sanctuary whispers...' and keep under 30 words. Focus on actionable game advice.";

            const prompt = `Current stats: Energy: ${formatNumber(gameState.energy)}, Insight: ${formatNumber(gameState.insight)}, Energy/s: ${formatNumber(gameState.energyPerSecond)}, Insight/s: ${formatNumber(gameState.insightPerSecond)}, Harmony: ${gameState.harmony.toFixed(1)}%. What should the player focus on next?`;

            const advice = await callGrok(prompt, advisorBtn, systemPrompt);
            log(`üìú ${advice}`, 'grok');
        }

        // --- TDD: Intelligent Creatures Global Functions ---
        window.spawnIntelligentCreature = (type) => {
            const creature = spawnIntelligentCreature(type);
            updateCreatureCount();
            return creature;
        };

        const updateCreatureCount = () => {
            const countElement = document.getElementById('creature-count');
            if (countElement) {
                countElement.textContent = gameState.intelligentCreatures.length;
            }
        };

        // --- TDD: Conversational AI Global Functions ---
        window.spawnConversationalUnit = (type) => {
            const unit = spawnConversationalUnit(type);
            updateConversationalCount();
            return unit;
        };

        // --- TDD: Improved UI Functions ---
        window.switchTab = (tabName) => {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.add('hidden');
            });

            // Remove active class from all tabs
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });

            // Show selected tab content
            document.getElementById(`content-${tabName}`).classList.remove('hidden');

            // Add active class to selected tab
            document.getElementById(`tab-${tabName}`).classList.add('active');
        };

        // --- TDD: Keyboard Shortcuts ---
        document.addEventListener('keydown', (e) => {
            // Only handle shortcuts if not typing in an input
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

            switch(e.key) {
                case '1':
                    switchTab('units');
                    break;
                case '2':
                    switchTab('upgrades');
                    break;
                case '3':
                    switchTab('beings');
                    break;
                case '4':
                    switchTab('ai');
                    break;
                case 'd':
                case 'D':
                    if (gameState.energy >= gameState.unitCosts.dreamers) {
                        createUnit('dreamers');
                    }
                    break;
                case 'w':
                case 'W':
                    if (gameState.insight >= gameState.unitCosts.weavers) {
                        createUnit('weavers');
                    }
                    break;
                case 's':
                case 'S':
                    spawnIntelligentCreature('cosmicSage');
                    break;
                case 'e':
                case 'E':
                    spawnIntelligentCreature('voidExplorer');
                    break;
                case 'h':
                case 'H':
                    spawnIntelligentCreature('harmonyKeeper');
                    break;
                case 'Escape':
                    closeConversationDialog();
                    break;
            }
        });

        const updateConversationalCount = () => {
            const countElement = document.getElementById('conversational-count');
            if (countElement) {
                countElement.textContent = gameState.conversationalUnits.length;
            }
        };

        window.closeConversationDialog = () => {
            if (conversationDialog) {
                conversationDialog.remove();
                conversationDialog = null;
                selectedConversationalUnit = null;
            }
        };

        window.sendMessage = async () => {
            const input = document.getElementById('player-input');
            const content = document.getElementById('conversation-content');

            if (!input.value.trim() || !selectedConversationalUnit) return;

            const playerMessage = input.value.trim();
            input.value = '';

            // Add player message to conversation
            const playerDiv = document.createElement('div');
            playerDiv.style.cssText = 'background: rgba(16, 185, 129, 0.2); padding: 10px; border-radius: 8px; margin-bottom: 10px;';
            playerDiv.innerHTML = `
                <div style="font-size: 12px; color: #34D399; margin-bottom: 5px;">You:</div>
                <div>${playerMessage}</div>
            `;
            content.appendChild(playerDiv);

            // Generate unit response
            const response = await generateLLMDialogue(selectedConversationalUnit, playerMessage);

            // Add unit response
            const unitDiv = document.createElement('div');
            unitDiv.style.cssText = 'background: rgba(139, 92, 246, 0.2); padding: 10px; border-radius: 8px; margin-bottom: 10px;';
            unitDiv.innerHTML = `
                <div style="font-size: 12px; color: #A78BFA; margin-bottom: 5px;">${selectedConversationalUnit.type}:</div>
                <div>${response}</div>
            `;
            content.appendChild(unitDiv);

            // Improve relationship
            selectedConversationalUnit.playerRelationship = Math.min(1.0, selectedConversationalUnit.playerRelationship + 0.05);

            // Scroll to bottom
            content.scrollTop = content.scrollHeight;
        };

        // --- Game Logic ---
        window.createUnit = (key) => {
            const unitConf = unitsConfig[key];
            const cost = gameState.unitCosts[key];
            if (gameState[unitConf.costResource] >= cost) {
                gameState[unitConf.costResource] -= cost;
                gameState.units[key]++;
                gameState.unitCosts[key] *= 1.15;
                if (key === 'dreamers') addSprite('crystal_tree');
                if (key === 'weavers') addSprite('dome');
                log(`A new ${unitConf.name} joins the sanctuary.`, 'success');

                // TDD Task 1: Add movable sprite for the new unit
                addSprite(key, 1);

                // TDD Fix: Don't immediately re-render UI, let game loop handle it
            }
        };

        window.upgradeNode = (key) => {
            const nodeConf = nodesConfig[key];
            const cost = gameState.nodeCosts[key];
            if (gameState[nodeConf.costResource] >= cost) {
                gameState[nodeConf.costResource] -= cost;
                gameState.nodes[key]++;
                gameState.nodeCosts[key] *= 2.5;
                if (nodeConf.harmony) {
                    gameState.harmony = Math.min(100, gameState.harmony + nodeConf.harmony);
                }
                if (key === 'sustenance') addSprite('garden');
                log(`Attuned the ${nodeConf.name}. Its resonance grows stronger.`, 'success');
                // TDD Fix: Don't immediately re-render UI, let game loop handle it
            }
        };
        
        const updateGameState = (delta) => {
            // Calculate production per second
            let energyPerSecond = gameState.units.weavers * unitsConfig.weavers.baseEnergy;
            let insightPerSecond = gameState.units.dreamers * unitsConfig.dreamers.baseInsight;

            // Apply node bonuses
            let costMultiplier = 1;
            energyPerSecond *= Math.pow(nodesConfig.energy.multiplier, gameState.nodes.energy);
            insightPerSecond *= Math.pow(nodesConfig.sustenance.multiplier, gameState.nodes.sustenance);
            const cohesionBonus = Math.pow(nodesConfig.cohesion.multiplier, gameState.nodes.cohesion);
            energyPerSecond *= cohesionBonus;
            insightPerSecond *= cohesionBonus;
            costMultiplier *= Math.pow(nodesConfig.cycling.multiplier, gameState.nodes.cycling);

            // Update unit costs based on multiplier (visual only, actual cost is in gameState)
            // This is a simplification; a more robust model would adjust the base cost.

            gameState.energyPerSecond = energyPerSecond;
            gameState.insightPerSecond = insightPerSecond;

            // Add resources
            gameState.energy += energyPerSecond * delta;
            gameState.insight += insightPerSecond * delta;
        };

        let lastUIUpdate = 0;
        const gameLoop = () => {
            const now = Date.now();
            const delta = (now - gameState.lastUpdate) / 1000; // Time in seconds

            updateGameState(delta);

            // TDD Fix: Update UI less frequently to prevent button blinking
            if (now - lastUIUpdate > 500) { // Increased from 100ms to 500ms
                renderUI();
                lastUIUpdate = now;
            }
            drawSanctuary();

            gameState.lastUpdate = now;
            requestAnimationFrame(gameLoop);
        };

        // --- TDD Test Suite ---
        const runTests = () => {
            console.log("--- Running TDD Test Suite ---");

            // Test 1: Initial game state
            const initialState = { ...gameState };
            console.assert(initialState.energy === 10, "Test 1.1 Failed: Initial energy should be 10.");
            console.assert(initialState.insight === 0, "Test 1.2 Failed: Initial insight should be 0.");
            console.assert(initialState.harmony === 50, "Test 1.3 Failed: Initial harmony should be 50.");

            // Test 1.4: Initial energy is displayed in the UI
            renderUI();
            const energyText = document.getElementById('energy').textContent;
            console.assert(parseFloat(energyText) === 10.0, "Test 1.4 Failed: Initial energy displayed should be 10.0.");

            // Test 2: Composting upgrade increases harmony
            const initialHarmony = initialState.harmony;
            gameState.insight = 200; // Ensure we can afford the upgrade
            upgradeNode('cycling');
            console.assert(gameState.harmony > initialHarmony, "Test 2.1 Failed: Composting upgrade should increase harmony.");

            // Test 3: Creating a unit deducts resources
            const initialEnergy = gameState.energy;
            createUnit('dreamers');
            console.assert(gameState.energy < initialEnergy, "Test 3.1 Failed: Creating a dreamer should deduct energy.");

            console.log("--- TDD Test Suite Finished ---");
        };

        // --- Initialization ---
        const init = () => {
            log("Welcome, Weaver. The sanctuary awakens with your first Dreamer and Weaver.", "success");
            log("üîë Grok API integration ready - key will be requested when needed", "info");

            // Initialize sprites
            addSprite('dome', 1);
            addSprite('crystal_tree', 1);

            // Initialize event listeners
            advisorBtn.addEventListener('click', getAdvisorInsight);
            seasonalVisionBtn.addEventListener('click', getSeasonalVision);

            // TDD API Key Popup Event Listeners
            const saveKeyBtn = document.getElementById('save-api-key');
            const cancelKeyBtn = document.getElementById('cancel-api-key');
            const apiKeyInput = document.getElementById('api-key-input');

            saveKeyBtn.addEventListener('click', () => {
                const key = apiKeyInput.value.trim();

                if (!key) {
                    showApiKeyError('Please enter an API key');
                    return;
                }

                if (key.length < 10) {
                    showApiKeyError('API key seems too short. Please check your key.');
                    return;
                }

                if (key.includes(' ')) {
                    showApiKeyError('API key should not contain spaces');
                    return;
                }

                if (saveApiKey(key)) {
                    hideApiKeyPopup();
                    log('üîë Grok API key saved successfully! You can now access cosmic wisdom.', 'success');
                } else {
                    showApiKeyError('Failed to save API key. Please try again.');
                }
            });

            cancelKeyBtn.addEventListener('click', () => {
                hideApiKeyPopup();
            });

            // Handle Enter key in API key input
            apiKeyInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    saveKeyBtn.click();
                }
            });

            // Handle Escape key to close popup
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    const popup = document.getElementById('api-key-popup');
                    if (!popup.classList.contains('hidden')) {
                        hideApiKeyPopup();
                    }
                }
            });

            // TDD Task 1: Mouse event listeners for drag-and-drop
            canvas.addEventListener('mousedown', (e) => {
                const coords = getCanvasCoordinates(e);
                const unit = getUnitAtPosition(coords.x, coords.y);

                if (unit && unit.movable) {
                    dragState.isDragging = true;
                    dragState.draggedUnit = unit;
                    dragState.dragOffsetX = coords.x - unit.x;
                    dragState.dragOffsetY = coords.y - unit.y;

                    // Stop auto-wandering while dragging
                    unit.wanderCenter = { x: unit.x, y: unit.y };

                    canvas.style.cursor = 'grabbing';
                }
            });

            canvas.addEventListener('mousemove', (e) => {
                const coords = getCanvasCoordinates(e);

                if (dragState.isDragging && dragState.draggedUnit) {
                    // Update dragged unit position
                    dragState.draggedUnit.targetX = coords.x - dragState.dragOffsetX;
                    dragState.draggedUnit.targetY = coords.y - dragState.dragOffsetY;

                    // Keep within canvas bounds
                    dragState.draggedUnit.targetX = Math.max(50, Math.min(canvas.width - 50, dragState.draggedUnit.targetX));
                    dragState.draggedUnit.targetY = Math.max(50, Math.min(canvas.height - 50, dragState.draggedUnit.targetY));
                } else {
                    // Update hover state
                    const unit = getUnitAtPosition(coords.x, coords.y);
                    dragState.hoveredUnit = unit;

                    if (unit && unit.movable) {
                        canvas.style.cursor = 'grab';
                    } else {
                        canvas.style.cursor = 'default';
                    }
                }
            });

            canvas.addEventListener('mouseup', (e) => {
                if (dragState.isDragging && dragState.draggedUnit) {
                    // Update wander center to new position
                    dragState.draggedUnit.wanderCenter = {
                        x: dragState.draggedUnit.x,
                        y: dragState.draggedUnit.y
                    };

                    log(`Moved ${dragState.draggedUnit.type} to new location`, 'info');
                } else {
                    // Check for conversational unit clicks
                    const coords = getCanvasCoordinates(e);
                    const conversationalUnit = getConversationalUnitAtPosition(coords.x, coords.y);

                    if (conversationalUnit) {
                        selectedConversationalUnit = conversationalUnit;
                        createConversationDialog(conversationalUnit);
                        log(`Started conversation with ${conversationalUnit.type}`, 'info');
                    }
                }

                dragState.isDragging = false;
                dragState.draggedUnit = null;
                dragState.dragOffsetX = 0;
                dragState.dragOffsetY = 0;
                canvas.style.cursor = 'default';
            });

            canvas.addEventListener('mouseleave', (e) => {
                dragState.hoveredUnit = null;
                canvas.style.cursor = 'default';
            });

            runTests(); // Run TDD tests on startup
            gameLoop();
        };

        init();
    </script>
</body>
</html>
