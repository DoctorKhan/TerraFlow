<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TerraFlow: Roots of Transition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            background-color: #0c0a1e; /* Deep cosmic blue */
        }
        .stat-card {
            background-color: rgba(18, 16, 46, 0.7); /* Dark blue/purple */
            backdrop-filter: blur(10px);
            transition: all 0.2s ease-in-out;
            border: 1px solid rgba(76, 71, 128, 0.5);
        }
        .module-card {
            background-color: #1c1944; /* Muted cosmic blue */
            transition: all 0.2s ease-in-out;
            border: 1px solid rgba(76, 71, 128, 0.5);
        }
        .unit-card {
             background-color: #2a275c;
        }
        .log-panel {
            height: 150px;
            background-color: rgba(10, 8, 28, 0.9);
            border-top: 1px solid rgba(76, 71, 128, 0.5);
        }
        canvas {
            border-radius: 0.75rem;
        }
        .grok-btn.loading, .grok-btn:disabled, button:disabled {
            cursor: not-allowed;
            background-color: #4a5568;
            opacity: 0.7;
        }

        /* TDD Fix: Custom scrollbar for log output */
        #log-output {
            scrollbar-width: thin;
            scrollbar-color: #4c1d95 #1e1b4b;
        }
        #log-output::-webkit-scrollbar {
            width: 8px;
        }
        #log-output::-webkit-scrollbar-track {
            background: #1e1b4b;
            border-radius: 4px;
        }
        #log-output::-webkit-scrollbar-thumb {
            background: #4c1d95;
            border-radius: 4px;
        }
        #log-output::-webkit-scrollbar-thumb:hover {
            background: #5b21b6;
        }

        /* Ensure log entries don't break layout */
        .log-entry {
            word-wrap: break-word;
            line-height: 1.4;
            margin-bottom: 0.25rem;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .log-entry {
            animation: fadeIn 0.5s ease-out;
        }

        /* Improved UI Styles */
        .tab-btn {
            color: #9CA3AF;
            background: transparent;
            border: none;
            cursor: pointer;
        }
        .tab-btn.active {
            color: #FFFFFF;
            background: #4F46E5;
        }
        .tab-btn:hover:not(.active) {
            color: #E5E7EB;
            background: #374151;
        }
        .tab-content {
            animation: fadeIn 0.2s ease-in-out;
        }

        /* Compact Stats */
        .stat-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }
        .stat-card {
            background: linear-gradient(135deg, rgba(79, 70, 229, 0.15), rgba(99, 102, 241, 0.05));
            border: 1px solid rgba(99, 102, 241, 0.3);
            border-radius: 6px;
            padding: 6px 8px;
            text-align: center;
            transition: all 0.2s ease;
            cursor: pointer;
        }
        .stat-card:hover {
            border-color: rgba(99, 102, 241, 0.5);
            transform: translateY(-1px);
            background: linear-gradient(135deg, rgba(79, 70, 229, 0.2), rgba(99, 102, 241, 0.1));
        }

        /* Compact Stats Styling */
        .stat-compact {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 80px;
        }

        .stat-mini {
            text-align: center;
            padding: 4px;
            border-radius: 4px;
            background: rgba(75, 85, 99, 0.3);
            transition: background 0.2s ease;
        }

        .stat-mini:hover {
            background: rgba(75, 85, 99, 0.5);
        }
        .stat-value {
            font-size: 1.1rem;
            font-weight: bold;
            color: #FFFFFF;
            line-height: 1;
        }
        .stat-label {
            font-size: 0.7rem;
            color: #A78BFA;
            margin-top: 2px;
            line-height: 1;
        }
        .stat-rate {
            font-size: 0.6rem;
            color: #10B981;
            margin-top: 1px;
            line-height: 1;
        }

        /* Resource change animations */
        .resource-increase {
            animation: resourcePulse 0.5s ease-out;
        }
        @keyframes resourcePulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); color: #10B981; }
            100% { transform: scale(1); }
        }

        /* Control vs Consciousness Resource Styling */
        .control-resource {
            border-left: 3px solid #DC2626; /* Red border for Control */
            background: linear-gradient(135deg, rgba(220, 38, 38, 0.1), rgba(127, 29, 29, 0.05));
        }

        .consciousness-resource {
            border-left: 3px solid #059669; /* Green border for Consciousness */
            background: linear-gradient(135deg, rgba(5, 150, 105, 0.1), rgba(6, 78, 59, 0.05));
        }

        .control-resource:hover {
            background: linear-gradient(135deg, rgba(220, 38, 38, 0.15), rgba(127, 29, 29, 0.08));
        }

        .consciousness-resource:hover {
            background: linear-gradient(135deg, rgba(5, 150, 105, 0.15), rgba(6, 78, 59, 0.08));
        }

        /* Ruler Path Building Styling */
        .ruler-building-tier-1 {
            border-left: 3px solid #DC2626;
            background: linear-gradient(135deg, rgba(220, 38, 38, 0.1), rgba(127, 29, 29, 0.05));
        }

        .ruler-building-tier-2 {
            border-left: 3px solid #B91C1C;
            background: linear-gradient(135deg, rgba(185, 28, 28, 0.15), rgba(127, 29, 29, 0.08));
            box-shadow: 0 0 5px rgba(220, 38, 38, 0.3);
        }

        .ruler-building-tier-3 {
            border-left: 3px solid #991B1B;
            background: linear-gradient(135deg, rgba(153, 27, 27, 0.2), rgba(127, 29, 29, 0.1));
            box-shadow: 0 0 8px rgba(220, 38, 38, 0.4);
            animation: ominousPulse 3s infinite;
        }

        .ruler-building-tier-4 {
            border-left: 3px solid #7F1D1D;
            background: linear-gradient(135deg, rgba(127, 29, 29, 0.3), rgba(69, 10, 10, 0.15));
            box-shadow: 0 0 12px rgba(220, 38, 38, 0.6);
            animation: totalitarianPulse 2s infinite;
        }

        @keyframes ominousPulse {
            0%, 100% { box-shadow: 0 0 8px rgba(220, 38, 38, 0.4); }
            50% { box-shadow: 0 0 15px rgba(220, 38, 38, 0.7); }
        }

        @keyframes totalitarianPulse {
            0%, 100% {
                box-shadow: 0 0 12px rgba(220, 38, 38, 0.6);
                border-left-color: #7F1D1D;
            }
            50% {
                box-shadow: 0 0 20px rgba(220, 38, 38, 0.9);
                border-left-color: #DC2626;
            }
        }

        /* Gardener Path Building Styling */
        .gardener-building-tier-1 {
            border-left: 3px solid #059669;
            background: linear-gradient(135deg, rgba(5, 150, 105, 0.1), rgba(6, 78, 59, 0.05));
        }

        .gardener-building-tier-2 {
            border-left: 3px solid #047857;
            background: linear-gradient(135deg, rgba(4, 120, 87, 0.15), rgba(6, 78, 59, 0.08));
            box-shadow: 0 0 5px rgba(5, 150, 105, 0.3);
        }

        .gardener-building-tier-3 {
            border-left: 3px solid #065F46;
            background: linear-gradient(135deg, rgba(6, 95, 70, 0.2), rgba(6, 78, 59, 0.1));
            box-shadow: 0 0 8px rgba(5, 150, 105, 0.4);
            animation: enlightenedPulse 3s infinite;
        }

        .gardener-building-tier-4 {
            border-left: 3px solid #064E3B;
            background: linear-gradient(135deg, rgba(6, 78, 59, 0.3), rgba(4, 120, 87, 0.15));
            box-shadow: 0 0 12px rgba(5, 150, 105, 0.6);
            animation: ascensionPulse 2s infinite;
        }

        @keyframes enlightenedPulse {
            0%, 100% { box-shadow: 0 0 8px rgba(5, 150, 105, 0.4); }
            50% { box-shadow: 0 0 15px rgba(5, 150, 105, 0.7); }
        }

        @keyframes ascensionPulse {
            0%, 100% {
                box-shadow: 0 0 12px rgba(5, 150, 105, 0.6);
                border-left-color: #064E3B;
            }
            50% {
                box-shadow: 0 0 20px rgba(5, 150, 105, 0.9);
                border-left-color: #059669;
            }
        }

        /* Great Transition Progress Styling */
        .great-transition-progress {
            border-left: 3px solid #F59E0B; /* Golden border for the ultimate goal */
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.15), rgba(217, 119, 6, 0.08));
            position: relative;
            overflow: hidden;
        }

        .great-transition-progress:hover {
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.2), rgba(217, 119, 6, 0.1));
        }

        .great-transition-progress::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            animation: greatTransitionShimmer 3s infinite;
            pointer-events: none;
        }

        @keyframes greatTransitionShimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        /* Crisis Level Indicator Styling */
        .crisis-indicator {
            border-left: 3px solid #EF4444; /* Red border for crisis */
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.15), rgba(153, 27, 27, 0.08));
            position: relative;
            overflow: hidden;
        }

        .crisis-indicator:hover {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.2), rgba(153, 27, 27, 0.1));
        }

        .crisis-indicator.crisis-high {
            animation: crisisWarning 2s infinite;
        }

        @keyframes crisisWarning {
            0%, 100% {
                box-shadow: 0 0 8px rgba(239, 68, 68, 0.4);
                border-left-color: #EF4444;
            }
            50% {
                box-shadow: 0 0 15px rgba(239, 68, 68, 0.8);
                border-left-color: #DC2626;
            }
        }

        /* Tooltip styles */
        .tooltip {
            position: relative;
        }
        .tooltip:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
            white-space: nowrap;
            z-index: 1000;
            pointer-events: none;
        }
    </style>
</head>
<body class="text-indigo-100 flex flex-col h-screen">

    <!-- Top Bar -->
    <header class="w-full p-4 bg-[#1c1944] border-b border-indigo-900 shadow-lg z-10">
        <h1 class="text-2xl font-bold text-white">TerraFlow: Roots of Transition</h1>
    </header>

    <!-- Main Content -->
    <div class="flex flex-1 overflow-hidden">
        
        <!-- Improved Left Panel: Tabbed Interface -->
        <aside class="w-80 p-3 bg-[#1c1944] border-r border-indigo-900 flex flex-col">
            <!-- Tab Navigation -->
            <div class="flex mb-3 bg-indigo-900/30 rounded-lg p-1">
                <button id="tab-units" class="tab-btn flex-1 py-2 px-3 text-sm font-medium rounded-md transition-all active" onclick="switchTab('units')" title="Units (Hotkey: 1)">
                    ‚ö° Units
                </button>
                <button id="tab-upgrades" class="tab-btn flex-1 py-2 px-3 text-sm font-medium rounded-md transition-all" onclick="switchTab('upgrades')" title="Upgrades (Hotkey: 2)">
                    üîÆ Upgrades
                </button>
                <button id="tab-beings" class="tab-btn flex-1 py-2 px-3 text-sm font-medium rounded-md transition-all" onclick="switchTab('beings')" title="Intelligent Beings (Hotkey: 3)">
                    üß† Beings
                </button>
                <button id="tab-ai" class="tab-btn flex-1 py-2 px-3 text-sm font-medium rounded-md transition-all" onclick="switchTab('ai')" title="Conversational AI (Hotkey: 4)">
                    üí¨ AI
                </button>
                <button id="tab-progress" class="tab-btn flex-1 py-2 px-3 text-sm font-medium rounded-md transition-all" onclick="switchTab('progress')" title="Achievements & Goals (Hotkey: 5)">
                    ‚≠ê Goals
                </button>
                <button id="tab-paths" class="tab-btn flex-1 py-2 px-3 text-sm font-medium rounded-md transition-all" onclick="switchTab('paths')" title="Path of Rulers vs Gardeners (Hotkey: 6)">
                    üå≥ Paths
                </button>
            </div>

            <!-- Tab Content -->
            <div class="flex-1 overflow-y-auto">
                <!-- Units Tab -->
                <div id="content-units" class="tab-content">
                    <div id="units-panel" class="space-y-2">
                        <!-- Unit creation cards will be injected here -->
                    </div>
                </div>

                <!-- Upgrades Tab -->
                <div id="content-upgrades" class="tab-content hidden">
                    <div id="modules-panel" class="space-y-2">
                        <!-- Module cards will be injected here -->
                    </div>
                </div>

                <!-- Intelligent Beings Tab -->
                <div id="content-beings" class="tab-content hidden">
                    <div class="space-y-2">
                        <button onclick="spawnIntelligentCreature('cosmicSage')"
                                class="w-full p-2 rounded bg-purple-600 hover:bg-purple-700 text-white text-sm transition-colors">
                            üßô‚Äç‚ôÇÔ∏è Cosmic Sage <span class="float-right text-xs opacity-75">Teaches</span>
                        </button>

                        <button onclick="spawnIntelligentCreature('voidExplorer')"
                                class="w-full p-2 rounded bg-gray-600 hover:bg-gray-700 text-white text-sm transition-colors">
                            üåå Void Explorer <span class="float-right text-xs opacity-75">Explores</span>
                        </button>

                        <button onclick="spawnIntelligentCreature('harmonyKeeper')"
                                class="w-full p-2 rounded bg-green-600 hover:bg-green-700 text-white text-sm transition-colors">
                            ‚ú® Harmony Keeper <span class="float-right text-xs opacity-75">Heals</span>
                        </button>

                        <div class="text-xs text-indigo-300 mt-2 p-2 bg-indigo-900/20 rounded">
                            <strong>Active:</strong> <span id="creature-count">0</span>
                        </div>
                    </div>
                </div>

                <!-- Conversational AI Tab -->
                <div id="content-ai" class="tab-content hidden">
                    <div class="space-y-2">
                        <button onclick="spawnConversationalUnit('philosopherDreamer')"
                                class="w-full p-2 rounded bg-indigo-600 hover:bg-indigo-700 text-white text-sm transition-colors">
                            üßô‚Äç‚ôÇÔ∏è Philosopher <span class="float-right text-xs opacity-75">Wisdom</span>
                        </button>

                        <button onclick="spawnConversationalUnit('artisticWeaver')"
                                class="w-full p-2 rounded bg-pink-600 hover:bg-pink-700 text-white text-sm transition-colors">
                            üé® Artist <span class="float-right text-xs opacity-75">Beauty</span>
                        </button>

                        <button onclick="spawnConversationalUnit('curiousExplorer')"
                                class="w-full p-2 rounded bg-emerald-600 hover:bg-emerald-700 text-white text-sm transition-colors">
                            üîç Explorer <span class="float-right text-xs opacity-75">Discovery</span>
                        </button>

                        <div class="text-xs text-purple-300 mt-2 p-2 bg-purple-900/20 rounded">
                            <strong>Conversational:</strong> <span id="conversational-count">0</span><br>
                            <em>Click beings to chat</em>
                        </div>

                        <hr class="border-indigo-700 my-3">

                        <button id="advisor-btn" class="grok-btn bg-blue-600 hover:bg-blue-700 text-white text-sm py-2 px-3 rounded transition-colors mb-2">
                            üìú Ask Advisor
                        </button>
                        <button id="seasonal-vision-btn" class="grok-btn bg-purple-600 hover:bg-purple-700 text-white text-sm py-2 px-3 rounded transition-colors">
                            ‚ú® Get Vision
                        </button>

                        <hr class="border-indigo-700 my-3">

                        <div class="text-xs text-gray-400 mb-2">Save & Load</div>
                        <div class="grid grid-cols-2 gap-2">
                            <button id="save-btn" class="bg-green-600 hover:bg-green-700 text-white text-xs py-1 px-2 rounded transition-colors">
                                üíæ Save
                            </button>
                            <button id="load-btn" class="bg-blue-600 hover:bg-blue-700 text-white text-xs py-1 px-2 rounded transition-colors">
                                üìÅ Load
                            </button>
                            <button id="export-btn" class="bg-yellow-600 hover:bg-yellow-700 text-white text-xs py-1 px-2 rounded transition-colors">
                                üì§ Export
                            </button>
                            <button id="import-btn" class="bg-orange-600 hover:bg-orange-700 text-white text-xs py-1 px-2 rounded transition-colors">
                                üì• Import
                            </button>
                        </div>
                        <div class="mt-2">
                            <button id="autosave-toggle" class="bg-gray-600 hover:bg-gray-700 text-white text-xs py-1 px-2 rounded transition-colors w-full">
                                üîÑ Auto-save: ON
                            </button>
                        </div>
                        <input type="file" id="import-file" accept=".json" style="display: none;">
                    </div>
                </div>

                <!-- Progress Tab -->
                <div id="content-progress" class="tab-content hidden">
                    <div class="space-y-3">
                        <div class="mb-3">
                            <h3 class="text-sm font-medium text-white mb-2">üéØ Active Goals</h3>
                            <div id="active-goals" class="space-y-2">
                                <!-- Active goals will be populated here -->
                            </div>
                        </div>

                        <div class="mb-3">
                            <h3 class="text-sm font-medium text-white mb-2">‚≠ê Recent Achievements</h3>
                            <div id="recent-achievements" class="space-y-2">
                                <!-- Recent achievements will be populated here -->
                            </div>
                        </div>

                        <div class="text-xs text-gray-300 p-2 bg-gray-900/30 rounded">
                            <div><strong>Progress:</strong></div>
                            <div>Achievements: <span id="achievement-count">0</span></div>
                            <div>Goals Completed: <span id="goals-completed-count">0</span></div>
                            <div>Play Time: <span id="play-time">0m</span></div>
                        </div>
                    </div>
                </div>

                <!-- Paths Tab -->
                <div id="content-paths" class="tab-content hidden">
                    <div class="space-y-4">
                        <div class="text-center mb-4">
                            <h3 class="text-lg font-bold text-white mb-2">The Great Transition</h3>
                            <p class="text-sm text-gray-300">Choose your path: Control through dominance or Consciousness through harmony</p>
                        </div>

                        <!-- Path of the Rulers -->
                        <div class="border border-red-600 rounded-lg p-3 bg-red-900/20">
                            <div class="flex justify-between items-center mb-2">
                                <h4 class="font-bold text-red-400">üèõÔ∏è Path of the Rulers (Tree of Knowledge)</h4>
                                <span id="ruler-building-count" class="text-xs bg-red-800 text-red-200 px-2 py-1 rounded">0 Built</span>
                            </div>
                            <p class="text-xs text-red-300 mb-3">Immediate power through control and efficiency. Generates Control but suppresses Consciousness.</p>
                            <div class="text-xs text-red-500 mb-3">
                                ‚ö†Ô∏è Warning: Higher tiers lead to increasingly authoritarian outcomes
                            </div>
                            <div id="ruler-buildings" class="space-y-2">
                                <!-- Ruler buildings will be populated here -->
                            </div>
                        </div>

                        <!-- Path of the Gardeners -->
                        <div class="border border-green-600 rounded-lg p-3 bg-green-900/20">
                            <div class="flex justify-between items-center mb-2">
                                <h4 class="font-bold text-green-400">üå± Path of the Gardeners (Tree of Life)</h4>
                                <span id="gardener-building-count" class="text-xs bg-green-800 text-green-200 px-2 py-1 rounded">0 Built</span>
                            </div>
                            <p class="text-xs text-green-300 mb-3">Sustainable growth through consciousness and harmony. Generates Consciousness but reduces Control.</p>
                            <div class="text-xs text-green-500 mb-3">
                                ‚ú® Note: Higher tiers lead to increasingly enlightened outcomes
                            </div>
                            <div id="gardener-buildings" class="space-y-2">
                                <!-- Gardener buildings will be populated here -->
                            </div>
                        </div>

                        <div class="text-xs text-gray-400 p-2 bg-gray-900/30 rounded">
                            <div><strong>Warning:</strong> Each path shapes humanity's future.</div>
                            <div>Extreme imbalance creates Entropy and risks failure.</div>
                            <div>The Great Transition requires wisdom in your choices.</div>
                        </div>
                    </div>
                </div>
            </div>
        </aside>

        <!-- Center Panel: Village View & Compact Stats -->
        <main class="flex-1 flex flex-col p-3">
            <!-- Compact Horizontal Stats Bar -->
            <div id="stats-bar" class="mb-2">
                <div class="flex items-center justify-between bg-gray-900 rounded-lg p-2 border border-gray-700">
                    <!-- Core Resources (Always Visible) -->
                    <div class="flex space-x-6">
                        <div class="stat-compact tooltip" data-tooltip="Energy - Create Dreamers (D key)">
                            <span class="text-blue-400 font-bold text-lg" id="energy">20</span>
                            <span class="text-xs text-gray-300">‚ö° Energy</span>
                            <span class="text-xs text-blue-300">+<span id="energy-rate">0.0</span>/s</span>
                        </div>
                        <div class="stat-compact tooltip" data-tooltip="Insight - Create Weavers (W key)">
                            <span class="text-purple-400 font-bold text-lg" id="insight">5</span>
                            <span class="text-xs text-gray-300">üîÆ Insight</span>
                            <span class="text-xs text-purple-300">+<span id="insight-rate">0.0</span>/s</span>
                        </div>
                        <div class="stat-compact tooltip" data-tooltip="The Great Transition Balance">
                            <div class="flex space-x-2">
                                <div class="text-center">
                                    <span class="text-green-400 font-bold" id="consciousness">10</span>
                                    <div class="text-xs text-gray-300">üå± Consciousness</div>
                                </div>
                                <div class="text-gray-500 self-center">vs</div>
                                <div class="text-center">
                                    <span class="text-red-400 font-bold" id="control">0</span>
                                    <div class="text-xs text-gray-300">üëë Control</div>
                                </div>
                            </div>
                        </div>
                        <div class="stat-compact tooltip great-transition-progress" data-tooltip="Planetary Consciousness - Reach 100 to win!">
                            <span class="text-yellow-400 font-bold text-xl" id="planetary-consciousness">10</span>
                            <span class="text-xs text-gray-300">üåç Planetary</span>
                            <div class="w-16 bg-gray-700 rounded-full h-1 mt-1">
                                <div class="bg-yellow-400 h-1 rounded-full transition-all duration-300" style="width: 10%"></div>
                            </div>
                        </div>
                    </div>

                    <!-- Control Buttons -->
                    <div class="flex space-x-2">
                        <button id="new-game-main-btn" class="bg-red-700 hover:bg-red-600 text-white text-xs px-2 py-1 rounded border border-red-600 font-bold" title="Start New Game (Clears All Progress)">
                            üîÑ New Game
                        </button>
                        <button id="stats-toggle" class="bg-gray-700 hover:bg-gray-600 text-white text-xs px-2 py-1 rounded border border-gray-600" title="Show/Hide Extended Stats">
                            üìä More
                        </button>
                    </div>
                </div>

                <!-- Extended Stats (Collapsible) -->
                <div id="extended-stats" class="hidden mt-2 bg-gray-900 rounded-lg p-3 border border-gray-700">
                    <div class="grid grid-cols-4 gap-4">
                        <!-- Secondary Resources -->
                        <div class="stat-mini tooltip" data-tooltip="Harmony - Affects all production efficiency">
                            <div class="text-sm font-bold text-green-300" id="harmony">75</div>
                            <div class="text-xs text-gray-400">üéµ Harmony</div>
                        </div>
                        <div class="stat-mini tooltip" data-tooltip="Inspiration - Generated by unit interactions">
                            <div class="text-sm font-bold text-pink-300" id="inspiration">0</div>
                            <div class="text-xs text-gray-400">‚ú® Inspiration</div>
                        </div>
                        <div class="stat-mini tooltip" data-tooltip="Wisdom - Generated by philosophical beings">
                            <div class="text-sm font-bold text-indigo-300" id="wisdom">0</div>
                            <div class="text-xs text-gray-400">üìö Wisdom</div>
                        </div>
                        <div class="stat-mini tooltip crisis-indicator" data-tooltip="Crisis Level - High levels trigger the Four Horsemen">
                            <div class="text-sm font-bold text-red-300" id="crisis-level">0</div>
                            <div class="text-xs text-gray-400">‚ö†Ô∏è Crisis</div>
                        </div>
                    </div>

                    <!-- Unit Information -->
                    <div class="mt-3 pt-3 border-t border-gray-700">
                        <div class="text-xs text-gray-400 mb-2">üèõÔ∏è Sanctuary Status</div>
                        <div class="grid grid-cols-3 gap-2 text-xs">
                            <div class="text-center">
                                <div class="text-cyan-300 font-bold" id="total-units">0</div>
                                <div class="text-gray-400">Total Units</div>
                            </div>
                            <div class="text-center">
                                <div class="text-blue-300 font-bold" id="zoom-level">100%</div>
                                <div class="text-gray-400">Zoom Level</div>
                            </div>
                            <div class="text-center">
                                <div class="text-purple-300 font-bold"><span id="visible-units">0</span>/<span id="total-units-mini">0</span></div>
                                <div class="text-gray-400">Visible</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Village Canvas -->
            <div class="flex-1 relative">
                <canvas id="village-canvas" class="w-full h-full"></canvas>

                <!-- Canvas Controls -->
                <div class="absolute top-2 right-2 flex flex-col space-y-1">
                    <!-- View Controls -->
                    <div class="bg-gray-900 bg-opacity-90 rounded-lg p-1 border border-gray-600">
                        <div class="flex space-x-1">
                            <button id="zoom-in-btn" class="bg-gray-700 hover:bg-gray-600 text-white text-xs px-2 py-1 rounded" title="Zoom In">üîç+</button>
                            <button id="zoom-out-btn" class="bg-gray-700 hover:bg-gray-600 text-white text-xs px-2 py-1 rounded" title="Zoom Out">üîç-</button>
                            <button id="reset-view-btn" class="bg-blue-700 hover:bg-blue-600 text-white text-xs px-2 py-1 rounded" title="Center View">üéØ</button>
                        </div>
                    </div>

                    <!-- Help -->
                    <div class="bg-gray-900 bg-opacity-90 rounded-lg p-1 border border-gray-600">
                        <button id="help-btn" class="bg-blue-700 hover:bg-blue-600 text-white text-xs px-2 py-1 rounded" title="Show Controls Help">‚ùì Help</button>
                    </div>
                </div>



                <!-- Minimap -->
                <div class="absolute bottom-2 right-2 bg-black bg-opacity-70 border border-gray-600 rounded">
                    <div class="text-xs text-gray-400 px-2 py-1 border-b border-gray-600">Minimap</div>
                    <canvas id="minimap-canvas" width="120" height="90" class="block"></canvas>
                </div>
            </div>
        </main>

    </div>

    <!-- Bottom Bar: Log & Help - TDD Fixed Height with Scrolling -->
    <footer id="log-panel" class="w-full border-t border-indigo-900" style="height: 200px; min-height: 200px; max-height: 200px;">
        <div class="p-3 h-full flex">
            <!-- Log Section -->
            <div class="flex-1 flex flex-col mr-3">
                <h3 class="font-semibold text-base mb-2 text-indigo-200 flex-shrink-0">Aetheric Log</h3>
                <div id="log-output" class="text-sm text-indigo-300 space-y-1 flex-1 overflow-y-auto pr-2"></div>
            </div>

            <!-- Help Section -->
            <div class="w-64 flex flex-col border-l border-indigo-700 pl-3">
                <h3 class="font-semibold text-base mb-2 text-indigo-200 flex-shrink-0">Quick Help</h3>
                <div class="text-xs text-indigo-300 space-y-1 overflow-y-auto">
                    <div class="mb-2">
                        <div class="text-indigo-200 font-medium">Tabs:</div>
                        <div>1-4: Switch tabs</div>
                    </div>
                    <div class="mb-2">
                        <div class="text-indigo-200 font-medium">Units:</div>
                        <div>D: Create Dreamer</div>
                        <div>W: Create Weaver</div>
                    </div>
                    <div class="mb-2">
                        <div class="text-indigo-200 font-medium">Beings:</div>
                        <div>S: Summon Sage</div>
                        <div>E: Void Explorer</div>
                        <div>H: Harmony Keeper</div>
                    </div>
                    <div class="mb-2">
                        <div class="text-indigo-200 font-medium">Other:</div>
                        <div>ESC: Close dialogs</div>
                        <div>Click beings to chat</div>
                    </div>
                </div>
            </div>
        </div>
    </footer>
    
    <!-- TDD Test Runner (Hidden) -->
    <div id="test-runner" style="display: none;"></div>

    <!-- TDD API Key Popup -->
    <div id="api-key-popup" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-gray-800 border border-indigo-600 p-6 rounded-lg max-w-md w-full mx-4 shadow-2xl">
            <h3 class="text-xl font-bold text-white mb-4">üîë Configure Grok API Key</h3>
            <p class="text-gray-300 mb-4">To access cosmic wisdom and AI insights, please enter your Grok API key:</p>
            <p class="text-sm text-indigo-300 mb-4">Get your API key from <a href="https://x.ai" target="_blank" class="text-blue-400 hover:text-blue-300 underline">x.ai</a></p>
            <input type="password" id="api-key-input" class="w-full p-3 bg-gray-700 text-white rounded mb-2 border border-gray-600 focus:border-indigo-500 focus:outline-none" placeholder="Enter your Grok API key...">
            <div id="api-key-error" class="text-red-400 text-sm mb-4 hidden"></div>
            <div class="flex gap-3">
                <button id="save-api-key" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white py-2 px-4 rounded transition-colors">
                    üíæ Save Key
                </button>
                <button id="cancel-api-key" class="flex-1 bg-gray-600 hover:bg-gray-700 text-white py-2 px-4 rounded transition-colors">
                    ‚ùå Cancel
                </button>
            </div>
        </div>
    </div>

    <script>
        // --- Canvas & DOM Elements ---
        const canvas = document.getElementById('village-canvas');
        const ctx = canvas.getContext('2d');
        const modulesPanel = document.getElementById('modules-panel');
        const unitsPanel = document.getElementById('units-panel');
        const statsBar = document.getElementById('stats-bar');
        const logOutput = document.getElementById('log-output');
        const seasonalVisionBtn = document.getElementById('seasonal-vision-btn');
        const advisorBtn = document.getElementById('advisor-btn');

        // --- Reset Game State Function ---
        function resetGameState() {
            gameState = {
                energy: 20,
                energyPerSecond: 0,
                insight: 5,
                insightPerSecond: 0,
                harmony: 50,
                inspiration: 0,
                inspirationPerSecond: 0,
                wisdom: 0,
                wisdomPerSecond: 0,
                control: 0,
                controlPerSecond: 0,
                consciousness: 10,
                consciousnessPerSecond: 0,
                planetaryConsciousness: 10,
                entropy: 0,
                units: {
                    dreamers: 1,
                    weavers: 1,
                    stellarNomads: 0,
                    voidWhisperers: 0,
                    crystalBeings: 0,
                    plasmaDancers: 0,
                    quantumSages: 0,
                    nebulaShepherds: 0
                },
                unitCosts: {
                    dreamers: 15,
                    weavers: 15,
                    stellarNomads: 25,
                    voidWhisperers: 40,
                    crystalBeings: 60,
                    plasmaDancers: 80,
                    quantumSages: 120,
                    nebulaShepherds: 200
                },
                unlockedRaces: ['human'],
                nodes: {
                    sustenance: 0,
                    energy: 0,
                    cohesion: 0,
                    cycling: 0,
                },
                nodeCosts: {
                    sustenance: 100,
                    energy: 100,
                    cohesion: 500,
                    cycling: 200,
                },
                rulerBuildings: {
                    industrialMine: 0,
                    centralizedGrid: 0,
                    automatedAgriculture: 0,
                    hierarchicalCity: 0,
                    propagandaTower: 0,
                    surveillanceNetwork: 0,
                    thoughtPolice: 0,
                    corporateState: 0,
                    memoryWipe: 0,
                    totalitarianCore: 0,
                    exodusArk: 0
                },
                gardenerBuildings: {
                    stoneCircle: 0,
                    healingGrove: 0,
                    permacultureGarden: 0,
                    wisdomSanctuary: 0,
                    mycelialNetwork: 0,
                    communityCouncil: 0,
                    planetaryAwakening: 0,
                    sacredGeometry: 0,
                    livingLibrary: 0,
                    theAscension: 0
                },
                techTreeUnlocked: false,
                gameEnded: false,
                storyPhase: 'early',
                anomalyDiscovered: false,
                trueLoreRevealed: false,
                rulerPathProgress: 0,
                gardenerPathProgress: 0,
                dominantPath: 'none',
                crisisLevel: 0,
                activeCrises: [],
                horsemenDefeated: [],
                lastCrisisTime: 0,
                villageGrid: [],
                stars: [],
                intelligentCreatures: [],
                conversationalUnits: [],
                activeInteractions: [],
                synergyEffects: [],
                inspiration: 0,
                wisdom: 0,
                achievements: {
                    unlocked: [],
                    progress: {},
                    categories: ['basic', 'advanced', 'master', 'secret'],
                    definitions: {}
                },
                goals: {
                    active: [],
                    completed: [],
                    available: [],
                    milestones: []
                },
                statistics: {
                    totalUnitsCreated: 3,
                    totalEnergyGenerated: 0,
                    totalInsightGenerated: 0,
                    totalInteractions: 0,
                    totalConversations: 0,
                    playTime: 0,
                    maxHarmony: 50,
                    maxEnergy: 20,
                    maxInsight: 5,
                    maxControl: 0,
                    maxConsciousness: 10,
                    maxPlanetaryConsciousness: 10,
                    totalControlGenerated: 0,
                    totalConsciousnessGenerated: 0,
                    rulerPathChoices: 0,
                    gardenerPathChoices: 0,
                    gameStartTime: Date.now()
                },
                playerTitles: [],
                lastUpdate: Date.now(),
                saveVersion: "1.0.0",
                lastSaved: null,
                autoSaveEnabled: true,
                autoSaveInterval: 30000
            };
            previousValues = {
                energy: 20,
                insight: 5,
                harmony: 50,
                inspiration: 0,
                wisdom: 0,
                control: 0,
                consciousness: 10,
                planetaryConsciousness: 10
            };
            if (logOutput) logOutput.innerHTML = '';
            if (typeof renderStats === 'function') renderStats();
            if (typeof renderUnits === 'function') renderUnits();
            if (typeof renderNodes === 'function') renderNodes();
        }

        // --- Attach Reset to New Game Button ---
        document.addEventListener('DOMContentLoaded', function() {
            const newGameBtn = document.getElementById('new-game-main-btn');
            if (newGameBtn) {
                newGameBtn.textContent = 'New Game';
                newGameBtn.onclick = function() {
                    resetGameState();
                    log('New game started. All progress cleared.', 'success');
                };
            }
        });

        // --- Game State (Incremental Model) - TDD Races Expansion ---
        let gameState = {
            energy: 20,
            energyPerSecond: 0,
            insight: 5,
            insightPerSecond: 0,
            harmony: 50,
            inspiration: 0,
            inspirationPerSecond: 0,
            wisdom: 0,
            wisdomPerSecond: 0,
            // TDD: Control vs Consciousness System - The Great Transition
            control: 0,
            controlPerSecond: 0,
            consciousness: 10, // Start with some consciousness
            consciousnessPerSecond: 0,
            planetaryConsciousness: 10, // Global consciousness level (win condition at 100)
            entropy: 0, // Accumulated negative effects from Ruler path choices
            units: {
                dreamers: 1,  // Start with 1 dreamer for immediate insight generation
                weavers: 1,   // Start with 1 weaver for immediate energy generation
                stellarNomads: 0,
                voidWhisperers: 0,
                crystalBeings: 0,
                plasmaDancers: 0,
                quantumSages: 0,
                nebulaShepherds: 0
            },
            unitCosts: {
                dreamers: 15,  // Slightly higher since we start with units
                weavers: 15,
                stellarNomads: 25,
                voidWhisperers: 40,
                crystalBeings: 60,
                plasmaDancers: 80,
                quantumSages: 120,
                nebulaShepherds: 200
            },
            unlockedRaces: ['human'], // Start with humans unlocked
            nodes: {
                sustenance: 0,
                energy: 0,
                cohesion: 0,
                cycling: 0,
            },
            nodeCosts: {
                sustenance: 100,
                energy: 100,
                cohesion: 500,
                cycling: 200,
            },
            // TDD: Tech Tree Buildings
            rulerBuildings: {
                // Tier 1: Foundation
                industrialMine: 0,
                centralizedGrid: 0,
                automatedAgriculture: 0,
                // Tier 2: Systems
                hierarchicalCity: 0,
                propagandaTower: 0,
                surveillanceNetwork: 0,
                // Tier 3: Oppression
                thoughtPolice: 0,
                corporateState: 0,
                memoryWipe: 0,
                // Tier 4: Ultimate
                totalitarianCore: 0,
                // Tier 5: Victory
                exodusArk: 0
            },
            gardenerBuildings: {
                // Tier 1: Seeds
                stoneCircle: 0,
                healingGrove: 0,
                permacultureGarden: 0,
                // Tier 2: Growing
                wisdomSanctuary: 0,
                mycelialNetwork: 0,
                communityCouncil: 0,
                // Tier 3: Awakening
                planetaryAwakening: 0,
                sacredGeometry: 0,
                livingLibrary: 0,
                // Tier 4: Ascension
                theAscension: 0
            },
            techTreeUnlocked: false, // Unlocks when certain conditions are met
            gameEnded: false, // Prevents repeated victory/defeat messages

            // TDD: Story Progression System
            storyPhase: 'early', // early, midgame_reveal, endgame, victory
            anomalyDiscovered: false,
            trueLoreRevealed: false,

            // TDD: Victory Path Tracking
            rulerPathProgress: 0, // Progress toward Ruler victory
            gardenerPathProgress: 0, // Progress toward Gardener victory
            dominantPath: 'none', // 'ruler', 'gardener', or 'balanced'

            // TDD: Four Horsemen Crisis System
            crisisLevel: 0, // 0-100, triggers horsemen at certain thresholds
            activeCrises: [], // Array of active crisis objects
            horsemenDefeated: [], // Array of defeated horsemen
            lastCrisisTime: 0, // Timestamp of last crisis
            villageGrid: [],
            stars: [],
            intelligentCreatures: [], // TDD: Intelligent creatures with AI behaviors
            conversationalUnits: [], // TDD: Conversational AI units with LLM dialogue
            activeInteractions: [], // TDD: Unit-to-unit interactions
            synergyEffects: [], // TDD: Active synergy bonuses
            inspiration: 0, // TDD: New resource type
            wisdom: 0, // TDD: New resource type
            // TDD: Achievement & Goals System
            achievements: {
                unlocked: [],
                progress: {},
                categories: ['basic', 'advanced', 'master', 'secret'],
                definitions: {}
            },
            goals: {
                active: [],
                completed: [],
                available: [],
                milestones: []
            },
            statistics: {
                totalUnitsCreated: 3, // Start with initial units
                totalEnergyGenerated: 0,
                totalInsightGenerated: 0,
                totalInteractions: 0,
                totalConversations: 0,
                playTime: 0,
                maxHarmony: 50,
                maxEnergy: 20,
                maxInsight: 5,
                maxControl: 0,
                maxConsciousness: 10,
                maxPlanetaryConsciousness: 10,
                totalControlGenerated: 0,
                totalConsciousnessGenerated: 0,
                rulerPathChoices: 0,
                gardenerPathChoices: 0,
                gameStartTime: Date.now()
            },
            playerTitles: [],
            lastUpdate: Date.now(),
            // TDD: Save System
            saveVersion: "1.0.0", // Version for save compatibility
            lastSaved: null,
            autoSaveEnabled: true,
            autoSaveInterval: 30000 // 30 seconds
        };

        // --- Game Config - TDD Races System ---
        const racesConfig = {
            human: { name: "Human", description: "The original inhabitants", color: '#8B5CF6', symbol: 'üë§', unlocked: true, tier: 1 },
            stellar: { name: "Stellar Nomads", description: "Wandering star-travelers", color: '#F59E0B', symbol: '‚≠ê', unlockCondition: { energy: 50, insight: 25 }, unlocked: false, tier: 2 },
            void: { name: "Void Whisperers", description: "Mysterious void entities", color: '#1F2937', symbol: 'üåë', unlockCondition: { harmony: 70, energy: 100 }, unlocked: false, tier: 3 },
            crystal: { name: "Crystal Beings", description: "Living crystalline entities", color: '#10B981', symbol: 'üíé', unlockCondition: { energy: 200, insight: 100 }, unlocked: false, tier: 3 },
            plasma: { name: "Plasma Dancers", description: "Pure energy beings", color: '#EF4444', symbol: 'üî•', unlockCondition: { energy: 500, harmony: 80 }, unlocked: false, tier: 4 },
            quantum: { name: "Quantum Sages", description: "Multi-dimensional beings", color: '#8B5CF6', symbol: 'üåÄ', unlockCondition: { insight: 500, harmony: 85 }, unlocked: false, tier: 5 },
            nebula: { name: "Nebula Shepherds", description: "Ancient star-birthers", color: '#A78BFA', symbol: 'üåå', unlockCondition: { energy: 1000, insight: 800, harmony: 95 }, unlocked: false, tier: 5 }
        };

        const unitsConfig = {
            dreamers: { name: "Dreamer", description: "Generates Insight through cosmic meditation.", baseInsight: 0.1, costResource: 'energy', race: 'human', special: 'dreamVision' },
            weavers: { name: "Weaver", description: "Generates Energy by weaving cosmic threads.", baseEnergy: 0.1, costResource: 'insight', race: 'human', special: 'energyWeaving' },
            stellarNomads: { name: "Stellar Nomad", description: "Star-travelers generating Energy and Insight.", baseEnergy: 0.15, baseInsight: 0.05, costResource: 'energy', race: 'stellar', special: 'stellarNavigation' },
            voidWhisperers: { name: "Void Whisperer", description: "Void communers generating Insight and Harmony.", baseInsight: 0.08, baseHarmony: 0.02, costResource: 'insight', race: 'void', special: 'voidCommunion' },
            crystalBeings: { name: "Crystal Being", description: "Living crystals amplifying cosmic energy.", baseEnergy: 0.2, costResource: 'energy', race: 'crystal', special: 'crystalResonance' },
            plasmaDancers: { name: "Plasma Dancer", description: "Pure energy beings dancing through plasma.", baseEnergy: 0.3, costResource: 'insight', race: 'plasma', special: 'plasmaManipulation' },
            quantumSages: { name: "Quantum Sage", description: "Multi-dimensional beings with vast knowledge.", baseInsight: 0.5, costResource: 'energy', race: 'quantum', special: 'quantumEntanglement' },
            nebulaShepherds: { name: "Nebula Shepherd", description: "Ancient beings birthing stars.", baseEnergy: 0.8, baseInsight: 0.3, baseHarmony: 0.1, costResource: 'insight', race: 'nebula', special: 'starBirth' }
        };

        // --- TDD: Two Divergent Tech Trees ---

        const rulerPathBuildings = {
            // Tier 1: Foundation of Control (Early Game)
            industrialMine: {
                name: "Industrial Mine",
                description: "Extracts resources efficiently but damages the environment. Foundation of industrial power.",
                costResource: 'energy',
                cost: 50,
                effects: { control: 2, energy: 1.5, harmony: -0.5, entropy: 0.1 },
                path: 'ruler',
                category: 'extraction',
                tier: 1,
                unlockCondition: () => true // Always available
            },
            centralizedGrid: {
                name: "Centralized Power Grid",
                description: "Distributes power efficiently but creates dependency. Citizens rely on the system.",
                costResource: 'insight',
                cost: 75,
                effects: { control: 3, energyPerSecond: 0.3, consciousness: -0.2, entropy: 0.05 },
                path: 'ruler',
                category: 'infrastructure',
                tier: 1,
                unlockCondition: () => gameState.rulerBuildings.industrialMine > 0
            },
            automatedAgriculture: {
                name: "Automated Agriculture",
                description: "Produces food efficiently but disconnects people from nature and traditional ways.",
                costResource: 'energy',
                cost: 60,
                effects: { control: 1, energyPerSecond: 0.2, consciousness: -0.3, entropy: 0.05 },
                path: 'ruler',
                category: 'production',
                tier: 1,
                unlockCondition: () => true
            },

            // Tier 2: Systems of Dominance (Mid Game)
            hierarchicalCity: {
                name: "Hierarchical City",
                description: "Organizes population in rigid social strata. Order through stratification.",
                costResource: 'energy',
                cost: 120,
                effects: { control: 5, harmony: 1, consciousness: -1, entropy: 0.2, controlPerSecond: 0.1 },
                path: 'ruler',
                category: 'social',
                tier: 2,
                unlockCondition: () => gameState.rulerBuildings.centralizedGrid > 0
            },
            propagandaTower: {
                name: "Propaganda Tower",
                description: "Shapes public opinion through mass media. Truth becomes what the state declares.",
                costResource: 'insight',
                cost: 100,
                effects: { control: 4, harmony: 0.5, consciousness: -1.5, entropy: 0.15 },
                path: 'ruler',
                category: 'information',
                tier: 2,
                unlockCondition: () => gameState.rulerBuildings.industrialMine > 0
            },
            surveillanceNetwork: {
                name: "Surveillance Network",
                description: "Monitors all citizen activity. Privacy becomes a relic of the past.",
                costResource: 'insight',
                cost: 150,
                effects: { control: 6, consciousness: -2, entropy: 0.3, controlPerSecond: 0.15 },
                path: 'ruler',
                category: 'security',
                tier: 2,
                unlockCondition: () => gameState.rulerBuildings.propagandaTower > 0
            },

            // Tier 3: Instruments of Oppression (Late Game)
            thoughtPolice: {
                name: "Thought Police",
                description: "Enforces ideological conformity. Independent thinking becomes dangerous.",
                costResource: 'wisdom',
                cost: 200,
                effects: { control: 8, consciousness: -3, harmony: -1, entropy: 0.4, controlPerSecond: 0.2 },
                path: 'ruler',
                category: 'enforcement',
                tier: 3,
                unlockCondition: () => gameState.rulerBuildings.surveillanceNetwork > 0
            },
            corporateState: {
                name: "Corporate State",
                description: "Merges government and business into one entity. Citizens become human resources.",
                costResource: 'energy',
                cost: 300,
                effects: { control: 10, energyPerSecond: 0.5, consciousness: -2, entropy: 0.5 },
                path: 'ruler',
                category: 'economic',
                tier: 3,
                unlockCondition: () => gameState.rulerBuildings.hierarchicalCity > 0
            },
            memoryWipe: {
                name: "Memory Reconditioning Center",
                description: "Erases inconvenient memories and implants approved thoughts. The past becomes malleable.",
                costResource: 'wisdom',
                cost: 400,
                effects: { control: 12, consciousness: -5, harmony: -2, entropy: 0.6, controlPerSecond: 0.3 },
                path: 'ruler',
                category: 'psychological',
                tier: 3,
                unlockCondition: () => gameState.rulerBuildings.thoughtPolice > 0
            },

            // Tier 4: Ultimate Control (End Game)
            totalitarianCore: {
                name: "Totalitarian Core",
                description: "The ultimate expression of control. Individual will ceases to exist.",
                costResource: 'consciousness',
                cost: 50, // Ironically cheap in consciousness - you sacrifice it
                effects: { control: 20, consciousness: -10, harmony: -5, entropy: 1.0, controlPerSecond: 0.5 },
                path: 'ruler',
                category: 'ultimate',
                tier: 4,
                unlockCondition: () => gameState.rulerBuildings.memoryWipe > 0 && gameState.control > 50
            },

            // Tier 5: The Exodus (Victory Condition)
            exodusArk: {
                name: "Exodus Ark",
                description: "The ultimate escape vessel. Leave this dying world behind and join the galactic empire.",
                costResource: 'energy',
                cost: 1000,
                effects: { rulerPathProgress: 100 }, // Triggers Ruler victory
                path: 'ruler',
                category: 'victory',
                tier: 5,
                unlockCondition: () => gameState.rulerBuildings.totalitarianCore > 0 && gameState.control > 80 && gameState.trueLoreRevealed
            }
        };

        const gardenerPathBuildings = {
            // Tier 1: Seeds of Consciousness (Early Game)
            stoneCircle: {
                name: "Stone Circle",
                description: "Ancient gathering place that enhances collective consciousness and spiritual connection.",
                costResource: 'wisdom',
                cost: 40,
                effects: { consciousness: 2, wisdom: 0.5, harmony: 1, control: -0.2 },
                path: 'gardener',
                category: 'spiritual',
                tier: 1,
                unlockCondition: () => true // Always available
            },
            healingGrove: {
                name: "Healing Grove",
                description: "Natural sanctuary that restores balance and awareness through nature's healing power.",
                costResource: 'inspiration',
                cost: 50,
                effects: { consciousness: 1.5, harmony: 2, consciousnessPerSecond: 0.1, entropy: -0.1 },
                path: 'gardener',
                category: 'healing',
                tier: 1,
                unlockCondition: () => true // Always available
            },
            permacultureGarden: {
                name: "Permaculture Garden",
                description: "Sustainable food system that connects people to nature and traditional wisdom.",
                costResource: 'harmony',
                cost: 45,
                effects: { consciousness: 1, harmony: 1.5, inspirationPerSecond: 0.15, entropy: -0.05 },
                path: 'gardener',
                category: 'sustainability',
                tier: 1,
                unlockCondition: () => gameState.gardenerBuildings.healingGrove > 0
            },

            // Tier 2: Growing Awareness (Mid Game)
            wisdomSanctuary: {
                name: "Wisdom Sanctuary",
                description: "Center of learning that develops deep understanding and philosophical insight.",
                costResource: 'insight',
                cost: 80,
                effects: { consciousness: 3, wisdom: 1, wisdomPerSecond: 0.2, control: -0.5 },
                path: 'gardener',
                category: 'knowledge',
                tier: 2,
                unlockCondition: () => gameState.gardenerBuildings.stoneCircle > 0
            },
            mycelialNetwork: {
                name: "Mycelial Network",
                description: "Underground fungal network that enhances communication and connection between all beings.",
                costResource: 'wisdom',
                cost: 70,
                effects: { consciousness: 2.5, consciousnessPerSecond: 0.2, harmony: 1, control: -1 },
                path: 'gardener',
                category: 'connection',
                tier: 2,
                unlockCondition: () => gameState.gardenerBuildings.wisdomSanctuary > 0
            },
            communityCouncil: {
                name: "Community Council",
                description: "Democratic decision-making body that empowers collective wisdom and shared governance.",
                costResource: 'harmony',
                cost: 90,
                effects: { consciousness: 2, harmony: 3, wisdomPerSecond: 0.15, control: -2 },
                path: 'gardener',
                category: 'governance',
                tier: 2,
                unlockCondition: () => gameState.gardenerBuildings.permacultureGarden > 0
            },

            // Tier 3: Awakening Bloom (Late Game)
            planetaryAwakening: {
                name: "Planetary Awakening Center",
                description: "A nexus that connects all consciousness on the planet into a unified field of awareness.",
                costResource: 'consciousness',
                cost: 120,
                effects: { consciousness: 10, consciousnessPerSecond: 0.5, planetaryConsciousness: 20, control: -5 },
                path: 'gardener',
                category: 'awakening',
                tier: 3,
                unlockCondition: () => gameState.gardenerBuildings.mycelialNetwork > 0 && gameState.consciousness > 50
            },
            sacredGeometry: {
                name: "Sacred Geometry Temple",
                description: "Crystalline structures that amplify consciousness through harmonic resonance and sacred patterns.",
                costResource: 'wisdom',
                cost: 150,
                effects: { consciousness: 8, consciousnessPerSecond: 0.3, harmony: 2, entropy: -0.2 },
                path: 'gardener',
                category: 'resonance',
                tier: 3,
                unlockCondition: () => gameState.gardenerBuildings.communityCouncil > 0
            },
            livingLibrary: {
                name: "Living Library",
                description: "Repository of all knowledge and wisdom, accessible to every awakened consciousness.",
                costResource: 'insight',
                cost: 200,
                effects: { consciousness: 6, wisdom: 5, wisdomPerSecond: 0.4, inspirationPerSecond: 0.2 },
                path: 'gardener',
                category: 'knowledge',
                tier: 3,
                unlockCondition: () => gameState.gardenerBuildings.planetaryAwakening > 0
            },

            // Tier 4: The Great Ascension (Victory Condition)
            theAscension: {
                name: "The Great Ascension",
                description: "Complete the planetary transformation. Awaken all beings to their true nature and cosmic unity.",
                costResource: 'wisdom',
                cost: 500,
                effects: { gardenerPathProgress: 100 }, // Triggers Gardener victory
                path: 'gardener',
                category: 'victory',
                tier: 4,
                unlockCondition: () => gameState.gardenerBuildings.livingLibrary > 0 && gameState.consciousness > 80 && gameState.trueLoreRevealed
            }
        };

        // Legacy nodes for backward compatibility
        const nodesConfig = {
            sustenance: { name: "Sustenance Node", description: "Boosts Dreamer insight generation.", effectTarget: 'dreamers', multiplier: 1.2, costResource: 'energy' },
            energy: { name: "Energy Node", description: "Boosts Weaver energy generation.", effectTarget: 'weavers', multiplier: 1.2, costResource: 'insight' },
            cohesion: { name: "Cohesion Node", description: "Boosts all production.", effectTarget: 'all', multiplier: 1.1, costResource: 'energy' },
            cycling: { name: "Recycling Node", description: "Reduces the cost of all units and improves Harmony.", effectTarget: 'cost', multiplier: 0.95, harmony: 5, costResource: 'insight' },
        };

        // --- Utility Functions ---
        const formatNumber = (num) => {
            if (num < 1000) return num.toFixed(1);
            if (num < 1e6) return (num / 1e3).toFixed(2) + 'k';
            if (num < 1e9) return (num / 1e6).toFixed(2) + 'M';
            return (num / 1e9).toFixed(2) + 'B';
        };
        const log = (message, type = 'info') => {
            const colors = { info: 'text-indigo-300', success: 'text-teal-300', error: 'text-red-400', warning: 'text-amber-300', grok: 'text-purple-300' };
            const p = document.createElement('p');
            p.innerHTML = `[INFO] ${message}`;
            p.className = `${colors[type]} log-entry`;
            logOutput.prepend(p);
            if (logOutput.children.length > 20) {
                logOutput.lastChild.remove();
            }
        };

        // --- Rendering Functions ---
        // Store previous values for change detection
        let previousValues = {
            energy: 20,
            insight: 5,
            harmony: 50,
            inspiration: 0,
            wisdom: 0,
            control: 0,
            consciousness: 10,
            planetaryConsciousness: 10
        };

        const renderStats = () => {
            // Update individual stat elements instead of replacing entire innerHTML
            const energyEl = document.getElementById('energy');
            const insightEl = document.getElementById('insight');
            const harmonyEl = document.getElementById('harmony');
            const inspirationEl = document.getElementById('inspiration');
            const wisdomEl = document.getElementById('wisdom');
            const controlEl = document.getElementById('control');
            const consciousnessEl = document.getElementById('consciousness');
            const planetaryConsciousnessEl = document.getElementById('planetary-consciousness');
            const crisisLevelEl = document.getElementById('crisis-level');
            const crisisStatusEl = document.getElementById('crisis-status');
            const energyRateEl = document.getElementById('energy-rate');
            const insightRateEl = document.getElementById('insight-rate');
            const inspirationRateEl = document.getElementById('inspiration-rate');
            const wisdomRateEl = document.getElementById('wisdom-rate');
            const controlRateEl = document.getElementById('control-rate');
            const consciousnessRateEl = document.getElementById('consciousness-rate');
            const totalUnitsEl = document.getElementById('total-units');

            // Check for increases and add visual feedback
            const checkAndUpdate = (element, newValue, resourceName) => {
                if (element) {
                    const oldValue = previousValues[resourceName];
                    element.textContent = formatNumber(newValue);

                    if (newValue > oldValue && oldValue > 0) {
                        element.classList.add('resource-increase');
                        setTimeout(() => element.classList.remove('resource-increase'), 500);
                    }
                    previousValues[resourceName] = newValue;
                }
            };

            checkAndUpdate(energyEl, gameState.energy, 'energy');
            checkAndUpdate(insightEl, gameState.insight, 'insight');
            checkAndUpdate(inspirationEl, gameState.inspiration, 'inspiration');
            checkAndUpdate(wisdomEl, gameState.wisdom, 'wisdom');
            checkAndUpdate(controlEl, gameState.control, 'control');
            checkAndUpdate(consciousnessEl, gameState.consciousness, 'consciousness');
            checkAndUpdate(planetaryConsciousnessEl, gameState.planetaryConsciousness, 'planetaryConsciousness');

            // Update planetary consciousness progress bar
            const progressBar = document.querySelector('.bg-yellow-400');
            if (progressBar) {
                const percentage = Math.min(100, Math.max(0, gameState.planetaryConsciousness));
                progressBar.style.width = `${percentage}%`;
            }

            // Handle harmony separately (no formatting, just fixed decimal)
            if (harmonyEl) {
                const oldHarmony = previousValues.harmony;
                harmonyEl.textContent = gameState.harmony.toFixed(1);

                if (gameState.harmony > oldHarmony && oldHarmony > 0) {
                    harmonyEl.classList.add('resource-increase');
                    setTimeout(() => harmonyEl.classList.remove('resource-increase'), 500);
                }
                previousValues.harmony = gameState.harmony;
            }

            if (energyRateEl) energyRateEl.textContent = gameState.energyPerSecond.toFixed(1);
            if (insightRateEl) insightRateEl.textContent = gameState.insightPerSecond.toFixed(1);
            if (inspirationRateEl) inspirationRateEl.textContent = (gameState.inspirationPerSecond || 0).toFixed(1);
            if (wisdomRateEl) wisdomRateEl.textContent = (gameState.wisdomPerSecond || 0).toFixed(1);
            if (controlRateEl) controlRateEl.textContent = (gameState.controlPerSecond || 0).toFixed(1);
            if (consciousnessRateEl) consciousnessRateEl.textContent = (gameState.consciousnessPerSecond || 0).toFixed(1);

            // Calculate total units
            if (totalUnitsEl) {
                const totalUnits = Object.values(gameState.units).reduce((sum, count) => sum + count, 0) +
                                 gameState.intelligentCreatures.length +
                                 gameState.conversationalUnits.length;
                totalUnitsEl.textContent = totalUnits;
            }
        };

        // TDD Fix: Stable button rendering that doesn't recreate buttons
        let unitsInitialized = false;

        // TDD Races: Check for newly unlocked races
        const checkRaceUnlocks = () => {
            let newlyUnlocked = [];

            Object.entries(racesConfig).forEach(([raceKey, race]) => {
                if (!gameState.unlockedRaces.includes(raceKey) && !race.unlocked) {
                    if (!race.unlockCondition) {
                        gameState.unlockedRaces.push(raceKey);
                        race.unlocked = true;
                        newlyUnlocked.push(raceKey);
                    } else {
                        const canUnlock = Object.entries(race.unlockCondition).every(([resource, required]) => {
                            return gameState[resource] >= required;
                        });

                        if (canUnlock) {
                            gameState.unlockedRaces.push(raceKey);
                            race.unlocked = true;
                            newlyUnlocked.push(raceKey);
                            log(`üåü New race discovered: ${race.name}! ${race.description}`, 'success');
                        }
                    }
                }
            });

            return newlyUnlocked;
        };

        const renderUnits = () => {
            // Only create buttons once, then update their states
            if (!unitsInitialized) {
                createUnitButtons();
                unitsInitialized = true;
            }
            updateUnitButtonStates();
        };

        const createUnitButtons = () => {
            unitsPanel.innerHTML = '';
            for (const key in unitsConfig) {
                const unit = unitsConfig[key];
                const card = document.createElement('div');
                card.className = "unit-card p-4 rounded-lg border border-indigo-800";
                card.innerHTML = `
                    <h3 class="font-bold text-lg text-white">${unit.name}</h3>
                    <p class="text-sm text-indigo-200">${unit.description}</p>
                    <button class="unit-btn mt-2 py-2 px-3 text-sm font-semibold rounded-md transition-colors"
                            data-unit="${key}">
                        Create ${unit.name}
                    </button>
                `;

                // Add stable event listener
                const button = card.querySelector('.unit-btn');
                button.addEventListener('click', () => {
                    if (!button.disabled) {
                        createUnit(key);
                    }
                });

                unitsPanel.appendChild(card);
            }
        };

        const updateUnitButtonStates = () => {
            for (const key in unitsConfig) {
                const unit = unitsConfig[key];
                const cost = gameState.unitCosts[key];
                const canAfford = gameState[unit.costResource] >= cost;

                const button = unitsPanel.querySelector(`[data-unit="${key}"]`);
                if (button) {
                    button.disabled = !canAfford;
                    button.textContent = `Create (Cost: ${formatNumber(cost)} ${unit.costResource})`;

                    // Update visual state without recreating
                    button.className = `unit-btn mt-2 py-2 px-3 text-sm font-semibold rounded-md transition-colors ${
                        canAfford ? 'bg-green-600 hover:bg-green-700 text-white' : 'bg-gray-600 text-gray-400'
                    }`;
                }
            }
        };

        // TDD Fix: Stable node button rendering
        let nodesInitialized = false;

        const renderNodes = () => {
            // Only create buttons once, then update their states
            if (!nodesInitialized) {
                createNodeButtons();
                nodesInitialized = true;
            }
            updateNodeButtonStates();
        };

        const createNodeButtons = () => {
            modulesPanel.innerHTML = '';
            for (const key in nodesConfig) {
                const node = nodesConfig[key];
                const card = document.createElement('div');
                card.className = "module-card p-4 rounded-lg";
                card.innerHTML = `
                    <h3 class="font-bold text-lg text-white">
                        ${node.name} <span class="text-sm font-normal text-indigo-300 level-display" data-node="${key}">(Lvl 0)</span>
                    </h3>
                    <p class="text-sm text-indigo-200">${node.description}</p>
                    <button class="node-btn mt-2 py-2 px-3 text-sm font-semibold rounded-md transition-colors"
                            data-node="${key}">
                        Attune ${node.name}
                    </button>
                `;

                // Add stable event listener
                const button = card.querySelector('.node-btn');
                button.addEventListener('click', () => {
                    if (!button.disabled) {
                        upgradeNode(key);
                    }
                });

                modulesPanel.appendChild(card);
            }
        };

        const updateNodeButtonStates = () => {
            for (const key in nodesConfig) {
                const node = nodesConfig[key];
                const cost = gameState.nodeCosts[key];
                const level = gameState.nodes[key];
                const canAfford = gameState[node.costResource] >= cost;

                // Update level display
                const levelDisplay = modulesPanel.querySelector(`[data-node="${key}"].level-display`);
                if (levelDisplay) {
                    levelDisplay.textContent = `(Lvl ${level})`;
                }

                // Update button
                const button = modulesPanel.querySelector(`button[data-node="${key}"]`);
                if (button) {
                    button.disabled = !canAfford;
                    button.textContent = `Attune (Cost: ${formatNumber(cost)} ${node.costResource})`;

                    // Update visual state without recreating
                    button.className = `node-btn mt-2 py-2 px-3 text-sm font-semibold rounded-md transition-colors ${
                        canAfford ? 'bg-teal-600 hover:bg-teal-700 text-white' : 'bg-gray-600 text-gray-400'
                    }`;
                }
            }
        };

        const renderUI = () => {
            renderStats();
            renderUnits();
            renderNodes();
            renderTechTrees();
        }
        
        // --- Enhanced Drawing System with Movement ---
        let animationTime = 0;
        let particles = [];

        // TDD Task 1: Drag and Drop System
        let dragState = {
            isDragging: false,
            draggedUnit: null,
            dragOffsetX: 0,
            dragOffsetY: 0,
            hoveredUnit: null,
            originalPosition: null,
            dragStartTime: 0,
            totalDragDistance: 0,
            isValidPlacement: true,
            placementEffects: [],
            proximityIndicators: []
        };

        let movementTrails = {};

        // TDD Task 2: Enhanced Visual Effects System
        let particlePool = {
            active: [],
            inactive: [],
            maxParticles: 200
        };

        let lightSources = [];
        let energyFlows = [];
        let screenEffects = {
            bloom: { enabled: true, intensity: 0.3 },
            vignette: { enabled: true, intensity: 0.2 }
        };

        // --- TDD: Screen Real Estate Management ---

        let canvasState = {
            width: 800,
            height: 600,
            safeZone: { left: 50, right: 50, top: 50, bottom: 50 },
            zoom: 1.0,
            panX: 0,
            panY: 0
        };

        const updateCanvasSize = () => {
            const rect = canvas.getBoundingClientRect();
            const newWidth = Math.max(600, rect.width); // Minimum width
            const newHeight = Math.max(400, rect.height); // Minimum height

            // Only update if size changed significantly
            if (Math.abs(canvas.width - newWidth) > 10 || Math.abs(canvas.height - newHeight) > 10) {
                canvas.width = newWidth;
                canvas.height = newHeight;
                canvasState.width = newWidth;
                canvasState.height = newHeight;

                // Reposition units that are now off-screen
                repositionOffScreenUnits();
            }
        };

        const repositionOffScreenUnits = () => {
            const safeWidth = canvasState.width - canvasState.safeZone.left - canvasState.safeZone.right;
            const safeHeight = canvasState.height - canvasState.safeZone.top - canvasState.safeZone.bottom;

            gameState.villageGrid.forEach(unit => {
                if (unit.x < canvasState.safeZone.left ||
                    unit.x > canvasState.width - canvasState.safeZone.right ||
                    unit.y < canvasState.safeZone.top ||
                    unit.y > canvasState.height - canvasState.safeZone.bottom) {

                    // Reposition to safe zone
                    unit.x = canvasState.safeZone.left + Math.random() * safeWidth;
                    unit.y = canvasState.safeZone.top + Math.random() * safeHeight;

                    // Update movement targets
                    if (unit.targetX !== undefined) {
                        unit.targetX = unit.x;
                        unit.targetY = unit.y;
                    }
                    if (unit.wanderCenter) {
                        unit.wanderCenter = { x: unit.x, y: unit.y };
                    }
                }
            });
        };

        const drawSanctuary = () => {
            // Safety check
            if (!canvas || !ctx) {
                console.error('Canvas or context not available');
                return;
            }

            updateCanvasSize();
            animationTime += 0.016; // ~60fps

            // Clear the entire canvas first
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw a simple test background first to ensure canvas is working
            ctx.fillStyle = '#0a0820';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Enhanced Background with nebula effect (not affected by zoom/pan)
            drawBackground();

            // Enhanced Stars with twinkling (not affected by zoom/pan)
            drawStars();

            // Floating particles for magical atmosphere (not affected by zoom/pan)
            updateAndDrawParticles();

            // Energy/Insight flow lines (not affected by zoom/pan)
            drawEnergyFlows();

            // Apply zoom and pan transformations for units only
            ctx.save();
            ctx.translate(canvasState.panX, canvasState.panY);
            ctx.scale(canvasState.zoom, canvasState.zoom);

            // TDD Task 1: Update unit movement and draw enhanced sprites
            updateUnitMovement(0.016);
            updateMovementTrails();

            // TDD: Update intelligent creatures
            updateIntelligentCreatures(0.016);

            // TDD: Update conversational AI units
            updateConversationalUnits(0.016);

            // TDD: Update unit interactions and synergies
            updateUnitInteractions(0.016);

            // TDD: Check achievements and goals periodically
            if (Math.random() < 0.1) { // Check every ~10 frames to avoid performance issues
                checkAchievementsAndGoals();
            }

            // TDD: Update Control vs Consciousness system
            updateControlConsciousnessSystem(0.016);

            // TDD: Check Great Transition win/lose conditions
            if (Math.random() < 0.05) { // Check every ~20 frames
                checkGreatTransitionConditions();
            }

            // TDD: Check for new building unlocks
            if (Math.random() < 0.02) { // Check every ~50 frames
                checkBuildingUnlocks();
            }

            // TDD: Check story progression
            if (Math.random() < 0.01) { // Check every ~100 frames
                checkStoryProgression();
            }

            // TDD: Update crisis system
            if (Math.random() < 0.05) { // Check every ~20 frames
                updateCrisisLevel();
                checkForNewCrises();
                checkCrisisResolution();
            }

            gameState.villageGrid.sort((a, b) => a.y - b.y);
            gameState.villageGrid.forEach(item => {
                const isHovered = dragState.hoveredUnit === item;
                const isDragged = dragState.draggedUnit === item;

                if (item.type === 'dome') drawEnhancedDome(item.x, item.y, item.size, item, isHovered, isDragged);
                else if (item.type === 'crystal_tree') drawEnhancedCrystalTree(item.x, item.y, item.size, item, isHovered, isDragged);
                else if (item.type === 'garden') drawEnhancedGarden(item.x, item.y, item.size, item, isHovered, isDragged);
                else drawMovableUnit(item, isHovered, isDragged);
            });

            // Draw movement trails
            drawMovementTrails();

            // TDD: Draw intelligent creatures
            drawIntelligentCreatures();

            // TDD: Draw conversational AI units
            drawConversationalUnits();

            // TDD: Draw drag-and-drop visual effects
            drawDragEffects();

            // TDD: Draw unit identification particles
            drawUnitIdentificationEffects();

            // Ambient light effects
            drawAmbientEffects();

            // Restore transformation matrix
            ctx.restore();

            // Draw UI elements that should not be affected by zoom/pan
            drawCanvasUI();

            // Draw minimap
            drawMinimap();

            // Only show debug info in development mode
            if (window.location.hostname === 'localhost' && window.location.search.includes('debug')) {
                drawDebugInfo();
            }
        };

        const drawCanvasUI = () => {
            // Update zoom level display in extended stats
            const zoomLevelEl = document.getElementById('zoom-level');
            if (zoomLevelEl) {
                zoomLevelEl.textContent = `${Math.round(canvasState.zoom * 100)}%`;
            }

            // Update unit count displays
            const visibleUnitsEl = document.getElementById('visible-units');
            const totalUnitsEl = document.getElementById('total-units');
            const totalUnitsMiniEl = document.getElementById('total-units-mini');

            if (visibleUnitsEl && totalUnitsEl) {
                const visibleUnits = countVisibleUnits();
                const totalUnits = gameState.villageGrid.length;
                visibleUnitsEl.textContent = visibleUnits;
                totalUnitsEl.textContent = totalUnits;
                if (totalUnitsMiniEl) {
                    totalUnitsMiniEl.textContent = totalUnits;
                }
            }
        };

        const countVisibleUnits = () => {
            const viewLeft = -canvasState.panX / canvasState.zoom;
            const viewTop = -canvasState.panY / canvasState.zoom;
            const viewRight = viewLeft + canvasState.width / canvasState.zoom;
            const viewBottom = viewTop + canvasState.height / canvasState.zoom;

            return gameState.villageGrid.filter(unit => {
                return unit.x >= viewLeft - unit.size &&
                       unit.x <= viewRight + unit.size &&
                       unit.y >= viewTop - unit.size &&
                       unit.y <= viewBottom + unit.size;
            }).length;
        };

        // --- Canvas Control Functions ---

        const zoomIn = () => {
            canvasState.zoom = Math.min(3.0, canvasState.zoom * 1.2);
        };

        const zoomOut = () => {
            canvasState.zoom = Math.max(0.3, canvasState.zoom / 1.2);
        };

        const resetView = () => {
            canvasState.zoom = 1.0;

            // Center view on existing units if any
            if (gameState.villageGrid.length > 0) {
                let minX = Infinity, maxX = -Infinity;
                let minY = Infinity, maxY = -Infinity;

                gameState.villageGrid.forEach(unit => {
                    minX = Math.min(minX, unit.x);
                    maxX = Math.max(maxX, unit.x);
                    minY = Math.min(minY, unit.y);
                    maxY = Math.max(maxY, unit.y);
                });

                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;

                canvasState.panX = canvasState.width / 2 - centerX;
                canvasState.panY = canvasState.height / 2 - centerY;

                log('üéØ View centered on your sanctuary', 'info');
            } else {
                canvasState.panX = 0;
                canvasState.panY = 0;
                log('üéØ View reset to center (no units to focus on)', 'info');
                log('üí° Tip: Create units using the Units tab or hotkeys (D for Dreamer, W for Weaver)', 'info');
            }
        };



        const showControlsHelp = () => {
            log('üéÆ CONTROLS HELP:', 'info');
            log('üñ±Ô∏è Mouse: Click and drag to pan the view', 'info');
            log('üîç Zoom: Use +/- buttons or mouse wheel', 'info');
            log('üéØ Reset: Center view on your units', 'info');
            log('‚å®Ô∏è Hotkeys: D = Dreamer, W = Weaver', 'info');
            log('üèóÔ∏è Build: Use the Units tab to create beings', 'info');
            log('üå± Paths: Choose Ruler or Gardener approach', 'info');
            log('üîÑ New Game: Red button to start fresh', 'info');
        };



        const resetGameStateToDefaults = () => {
            // Reset all resources to starting values
            gameState.energy = 20;
            gameState.insight = 5;
            gameState.inspiration = 0;
            gameState.wisdom = 0;
            gameState.consciousness = 10;
            gameState.control = 0;
            gameState.harmony = 75;
            gameState.entropy = 0;
            gameState.planetaryConsciousness = 10;

            // Reset per-second rates
            gameState.energyPerSecond = 0.1;
            gameState.insightPerSecond = 0.05;
            gameState.inspirationPerSecond = 0;
            gameState.wisdomPerSecond = 0;
            gameState.consciousnessPerSecond = 0;
            gameState.controlPerSecond = 0;

            // Reset buildings
            Object.keys(gameState.rulerBuildings).forEach(key => {
                gameState.rulerBuildings[key] = 0;
            });
            Object.keys(gameState.gardenerBuildings).forEach(key => {
                gameState.gardenerBuildings[key] = 0;
            });

            // Reset units
            gameState.villageGrid = [];

            // Reset story progression
            gameState.storyPhase = 'early';
            gameState.anomalyDiscovered = false;
            gameState.trueLoreRevealed = false;
            gameState.rulerPathProgress = 0;
            gameState.gardenerPathProgress = 0;
            gameState.dominantPath = 'none';

            // Reset crisis system
            gameState.crisisLevel = 0;
            gameState.activeCrises = [];
            gameState.horsemenDefeated = [];
            gameState.lastCrisisTime = 0;

            // Reset other flags
            gameState.gameEnded = false;
            gameState.techTreeUnlocked = false;

            // Reset statistics
            gameState.statistics = {
                totalUnitsCreated: 0,
                totalResourcesGenerated: 0,
                totalBuildingsBuilt: 0,
                rulerPathChoices: 0,
                gardenerPathChoices: 0,
                achievementsUnlocked: 0,
                goalsCompleted: 0
            };

            // Reset achievements and goals
            if (window.achievements) {
                Object.values(window.achievements).forEach(achievement => {
                    achievement.unlocked = false;
                    achievement.progress = 0;
                });
            }

            if (window.goals) {
                Object.values(window.goals).forEach(goal => {
                    goal.completed = false;
                    goal.progress = 0;
                });
            }

            // Force re-initialization of UI components
            rulerBuildingsInitialized = false;
            gardenerBuildingsInitialized = false;
        };

        const initializeCanvasControls = () => {
            // Canvas controls
            const newGameBtn = document.getElementById('new-game-btn');
            const zoomInBtn = document.getElementById('zoom-in-btn');
            const zoomOutBtn = document.getElementById('zoom-out-btn');
            const resetViewBtn = document.getElementById('reset-view-btn');
            const helpBtn = document.getElementById('help-btn');

            if (newGameBtn) newGameBtn.addEventListener('click', startNewGame);
            if (zoomInBtn) zoomInBtn.addEventListener('click', zoomIn);
            if (zoomOutBtn) zoomOutBtn.addEventListener('click', zoomOut);
            if (resetViewBtn) resetViewBtn.addEventListener('click', resetView);
            if (helpBtn) helpBtn.addEventListener('click', showControlsHelp);

            // Mouse wheel zoom
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                if (e.deltaY < 0) {
                    zoomIn();
                } else {
                    zoomOut();
                }
            });

            // Pan with middle mouse button or Shift+drag
            let isPanning = false;
            let lastPanX = 0;
            let lastPanY = 0;

            canvas.addEventListener('mousedown', (e) => {
                if (e.button === 1 || (e.button === 0 && e.shiftKey)) { // Middle button or Shift+left
                    isPanning = true;
                    lastPanX = e.clientX;
                    lastPanY = e.clientY;
                    e.preventDefault();
                }
            });

            canvas.addEventListener('mousemove', (e) => {
                if (isPanning) {
                    const deltaX = e.clientX - lastPanX;
                    const deltaY = e.clientY - lastPanY;
                    canvasState.panX += deltaX;
                    canvasState.panY += deltaY;
                    lastPanX = e.clientX;
                    lastPanY = e.clientY;
                }
            });

            canvas.addEventListener('mouseup', (e) => {
                if (e.button === 1 || (e.button === 0 && e.shiftKey)) {
                    isPanning = false;
                }
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                switch (e.key) {
                    case '+':
                    case '=':
                        zoomIn();
                        e.preventDefault();
                        break;
                    case '-':
                        zoomOut();
                        e.preventDefault();
                        break;
                    case '0':
                        resetView();
                        e.preventDefault();
                        break;
                    case 'a':
                    case 'A':
                        if (e.ctrlKey || e.metaKey) {
                            autoArrangeUnits();
                            e.preventDefault();
                        }
                        break;
                }
            });
        };

        const initializeStatsToggle = () => {
            const statsToggle = document.getElementById('stats-toggle');
            const extendedStats = document.getElementById('extended-stats');
            const newGameMainBtn = document.getElementById('new-game-main-btn');

            if (statsToggle && extendedStats) {
                statsToggle.addEventListener('click', () => {
                    const isHidden = extendedStats.classList.contains('hidden');
                    if (isHidden) {
                        extendedStats.classList.remove('hidden');
                        statsToggle.textContent = 'üìä Less';
                        statsToggle.title = 'Hide Extended Stats';
                    } else {
                        extendedStats.classList.add('hidden');
                        statsToggle.textContent = 'üìä More';
                        statsToggle.title = 'Show Extended Stats';
                    }
                });
            }

            if (newGameMainBtn) {
                newGameMainBtn.addEventListener('click', startNewGame);
            }
        };

        // --- Minimap System ---

        const drawMinimap = () => {
            const minimapCanvas = document.getElementById('minimap-canvas');
            if (!minimapCanvas) return;

            const minimapCtx = minimapCanvas.getContext('2d');
            const minimapWidth = minimapCanvas.width;
            const minimapHeight = minimapCanvas.height;

            // Clear minimap
            minimapCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            minimapCtx.fillRect(0, 0, minimapWidth, minimapHeight);

            // Calculate scale
            const scaleX = minimapWidth / canvasState.width;
            const scaleY = minimapHeight / canvasState.height;
            const scale = Math.min(scaleX, scaleY);

            // Draw units on minimap
            gameState.villageGrid.forEach(unit => {
                const x = unit.x * scale;
                const y = unit.y * scale;

                minimapCtx.fillStyle = getUnitMinimapColor(unit.type);
                minimapCtx.fillRect(x - 1, y - 1, 2, 2);
            });

            // Draw viewport indicator
            const viewLeft = -canvasState.panX / canvasState.zoom;
            const viewTop = -canvasState.panY / canvasState.zoom;
            const viewWidth = canvasState.width / canvasState.zoom;
            const viewHeight = canvasState.height / canvasState.zoom;

            minimapCtx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
            minimapCtx.lineWidth = 1;
            minimapCtx.strokeRect(
                viewLeft * scale,
                viewTop * scale,
                viewWidth * scale,
                viewHeight * scale
            );
        };

        const getUnitMinimapColor = (type) => {
            const colors = {
                'dreamer': '#8B5CF6',
                'weaver': '#10B981',
                'dome': '#F59E0B',
                'crystal_tree': '#06B6D4',
                'garden': '#84CC16',
                'stellarNomads': '#F59E0B',
                'voidWhisperers': '#6B7280',
                'crystalBeings': '#10B981',
                'plasmaDancers': '#EC4899',
                'quantumSages': '#8B5CF6',
                'nebulaShepherds': '#06B6D4'
            };
            return colors[type] || '#9CA3AF';
        };

        const drawDebugInfo = () => {
            // Draw debug information in top-left corner
            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(10, 10, 200, 120);

            ctx.fillStyle = 'white';
            ctx.font = '12px monospace';
            ctx.fillText(`Canvas: ${canvas.width}x${canvas.height}`, 15, 25);
            ctx.fillText(`Zoom: ${canvasState.zoom.toFixed(2)}`, 15, 40);
            ctx.fillText(`Pan: ${canvasState.panX.toFixed(0)}, ${canvasState.panY.toFixed(0)}`, 15, 55);
            ctx.fillText(`Units: ${gameState.villageGrid.length}`, 15, 70);
            ctx.fillText(`Stars: ${gameState.stars.length}`, 15, 85);
            ctx.fillText(`Animation: ${animationTime.toFixed(2)}`, 15, 100);

            // Show first few unit positions
            if (gameState.villageGrid.length > 0) {
                ctx.fillText(`Unit 1: ${gameState.villageGrid[0].x.toFixed(0)}, ${gameState.villageGrid[0].y.toFixed(0)}`, 15, 115);
            }

            ctx.restore();
        };

        const drawBackground = () => {
            // Multi-layer gradient background
            const gradient1 = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient1.addColorStop(0, '#0a0820');
            gradient1.addColorStop(0.3, '#1a1040');
            gradient1.addColorStop(0.7, '#2a1860');
            gradient1.addColorStop(1, '#1c1944');
            ctx.fillStyle = gradient1;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Nebula clouds
            for (let i = 0; i < 3; i++) {
                const x = (canvas.width * 0.2) + (i * canvas.width * 0.3);
                const y = canvas.height * 0.3 + Math.sin(animationTime * 0.5 + i) * 20;
                const radius = 150 + Math.sin(animationTime * 0.3 + i) * 30;

                const nebulaGradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                nebulaGradient.addColorStop(0, `rgba(138, 43, 226, ${0.1 + Math.sin(animationTime + i) * 0.05})`);
                nebulaGradient.addColorStop(0.5, `rgba(75, 0, 130, ${0.05 + Math.sin(animationTime * 0.7 + i) * 0.03})`);
                nebulaGradient.addColorStop(1, 'rgba(75, 0, 130, 0)');

                ctx.fillStyle = nebulaGradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        };

        const drawStars = () => {
            // Initialize enhanced stars
            if (gameState.stars.length === 0) {
                for (let i = 0; i < 150; i++) {
                    gameState.stars.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        radius: Math.random() * 2 + 0.5,
                        alpha: 0.3 + Math.random() * 0.7,
                        twinkleSpeed: 0.5 + Math.random() * 2,
                        color: Math.random() > 0.8 ? 'rgba(200, 150, 255, ' : 'rgba(255, 255, 255, '
                    });
                }
            }

            gameState.stars.forEach(star => {
                const twinkle = 0.7 + Math.sin(animationTime * star.twinkleSpeed + star.x) * 0.3;
                const alpha = star.alpha * twinkle;

                // Star glow
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius * 2, 0, Math.PI * 2);
                ctx.fillStyle = star.color + (alpha * 0.2) + ')';
                ctx.fill();

                // Star core
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                ctx.fillStyle = star.color + alpha + ')';
                ctx.fill();
            });
        };

        const updateAndDrawParticles = () => {
            // Add new particles occasionally
            if (Math.random() < 0.3) {
                particles.push({
                    x: Math.random() * canvas.width,
                    y: canvas.height + 10,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: -Math.random() * 2 - 0.5,
                    life: 1.0,
                    decay: 0.005 + Math.random() * 0.01,
                    size: Math.random() * 3 + 1,
                    color: Math.random() > 0.5 ? 'rgba(167, 139, 250, ' : 'rgba(196, 181, 253, '
                });
            }

            // Update and draw particles
            particles = particles.filter(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life -= particle.decay;

                if (particle.life > 0) {
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size * particle.life, 0, Math.PI * 2);
                    ctx.fillStyle = particle.color + (particle.life * 0.6) + ')';
                    ctx.fill();
                    return true;
                }
                return false;
            });
        };

        // TDD Task 1: Enhanced sprite system with movement capabilities
        let spriteIdCounter = 0;

        const addSprite = (type, count = 1) => {
            for (let i = 0; i < count; i++) {
                const size = type === 'dome' ? 20 : type === 'crystal_tree' ? 25 : 15;

                // Calculate safe spawning area (in world coordinates)
                const worldWidth = canvasState.width / canvasState.zoom;
                const worldHeight = canvasState.height / canvasState.zoom;
                const viewLeft = -canvasState.panX / canvasState.zoom;
                const viewTop = -canvasState.panY / canvasState.zoom;

                const safeLeft = Math.max(viewLeft + canvasState.safeZone.left / canvasState.zoom, size);
                const safeRight = Math.min(viewLeft + worldWidth - canvasState.safeZone.right / canvasState.zoom, canvasState.width - size);
                const safeTop = Math.max(viewTop + canvasState.safeZone.top / canvasState.zoom, size);
                const safeBottom = Math.min(viewTop + worldHeight - canvasState.safeZone.bottom / canvasState.zoom, canvasState.height - size);

                // Ensure we have valid spawning area
                const safeWidth = Math.max(100, safeRight - safeLeft);
                const safeHeight = Math.max(100, safeBottom - safeTop);

                const x = safeLeft + Math.random() * safeWidth;
                const y = safeTop + Math.random() * safeHeight;

                // Determine if unit is movable based on type
                const movable = ['dreamer', 'weaver', 'stellarNomads', 'voidWhisperers',
                               'crystalBeings', 'plasmaDancers', 'quantumSages', 'nebulaShepherds'].includes(type);

                const sprite = {
                    type: type,
                    x: x,
                    y: y,
                    size: size,
                    movable: movable,
                    id: `${type}_${spriteIdCounter++}`,
                    animationOffset: Math.random() * Math.PI * 2,
                    pulseSpeed: 0.5 + Math.random() * 1.5,
                    // Movement properties for movable units
                    targetX: x,
                    targetY: y,
                    vx: 0,
                    vy: 0,
                    wanderCenter: { x: x, y: y },
                    wanderPhase: Math.random() * Math.PI * 2,
                    wanderRadius: 30 + Math.random() * 20
                };

                gameState.villageGrid.push(sprite);
            }
        };

        const drawEnhancedDome = (x, y, size, sprite, isHovered, isDragged) => {
            ctx.save();

            // Visual feedback for interaction states
            let scale = 1.0;
            let alpha = 1.0;
            let glowIntensity = 0.8;

            if (isDragged) {
                scale = 1.2;
                alpha = 0.9;
                glowIntensity = 1.2;
            } else if (isHovered) {
                scale = 1.1;
                glowIntensity = 1.0;
            }

            ctx.globalAlpha = alpha;
            ctx.translate(x, y);
            ctx.scale(scale, scale);

            const pulse = Math.sin(animationTime * (sprite.pulseSpeed || 1) + (sprite.animationOffset || 0)) * 0.15 + 1;
            const currentSize = size * pulse;

            // Layer 1: Outer energy field with orange/yellow theme
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            ctx.shadowColor = '#FBBF24';
            ctx.shadowBlur = 25 * glowIntensity;
            ctx.beginPath();
            ctx.arc(0, 0, currentSize * 1.8, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(251, 191, 36, 0.2)';
            ctx.fill();
            ctx.restore();

            // Layer 2: Main dome with enhanced orange gradient
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize);
            gradient.addColorStop(0, 'rgba(255, 215, 77, 1.0)');
            gradient.addColorStop(0.6, 'rgba(245, 158, 11, 0.9)');
            gradient.addColorStop(1, 'rgba(217, 119, 6, 0.7)');

            ctx.shadowColor = '#FBBF24';
            ctx.shadowBlur = 15 * glowIntensity;
            ctx.beginPath();
            ctx.arc(0, 0, currentSize, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();

            // Layer 3: Inner highlight
            ctx.save();
            ctx.globalCompositeOperation = 'overlay';
            const highlightGradient = ctx.createRadialGradient(-currentSize * 0.3, -currentSize * 0.3, 0, 0, 0, currentSize * 0.8);
            highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
            highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.beginPath();
            ctx.arc(0, 0, currentSize * 0.7, 0, Math.PI * 2);
            ctx.fillStyle = highlightGradient;
            ctx.fill();
            ctx.restore();

            // Layer 4: Energy orbs floating around dome
            for (let i = 0; i < 3; i++) {
                const angle = animationTime * 0.5 + (i * Math.PI * 2 / 3) + (sprite.animationOffset || 0);
                const orbX = Math.cos(angle) * (currentSize + 15);
                const orbY = Math.sin(angle) * (currentSize + 15);

                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                ctx.shadowColor = '#FBBF24';
                ctx.shadowBlur = 8;
                ctx.beginPath();
                ctx.arc(orbX, orbY, 3, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 215, 77, 0.8)';
                ctx.fill();
                ctx.restore();
            }

            ctx.shadowBlur = 0;
            ctx.restore();
        };

        const drawEnhancedCrystalTree = (x, y, size, sprite) => {
            const pulse = Math.sin(animationTime * sprite.pulseSpeed + sprite.animationOffset) * 0.15 + 1;
            const currentSize = size * pulse;

            // Crystal base/roots
            ctx.beginPath();
            ctx.ellipse(x, y, currentSize * 0.8, currentSize * 0.3, 0, 0, Math.PI * 2);
            const baseGradient = ctx.createRadialGradient(x, y, 0, x, y, currentSize * 0.8);
            baseGradient.addColorStop(0, `rgba(139, 92, 246, ${0.6 * pulse})`);
            baseGradient.addColorStop(1, `rgba(79, 70, 229, ${0.3 * pulse})`);
            ctx.fillStyle = baseGradient;
            ctx.fill();

            // Main crystal trunk with facets
            const trunkHeight = currentSize * 2;
            const trunkWidth = currentSize * 0.6;

            // Multiple crystal facets
            for (let i = 0; i < 6; i++) {
                const angle = (i * Math.PI) / 3;
                const facetX = x + Math.cos(angle) * (trunkWidth * 0.3);
                const facetY = y - trunkHeight * 0.5;

                ctx.beginPath();
                ctx.moveTo(facetX, y);
                ctx.lineTo(facetX + Math.cos(angle) * (trunkWidth * 0.2), facetY);
                ctx.lineTo(x, y - trunkHeight);
                ctx.lineTo(facetX - Math.cos(angle) * (trunkWidth * 0.2), facetY);
                ctx.closePath();

                const facetGradient = ctx.createLinearGradient(facetX, y, x, y - trunkHeight);
                const brightness = 0.5 + Math.sin(animationTime + angle) * 0.3;
                facetGradient.addColorStop(0, `rgba(139, 92, 246, ${brightness * pulse})`);
                facetGradient.addColorStop(0.5, `rgba(167, 139, 250, ${(brightness + 0.2) * pulse})`);
                facetGradient.addColorStop(1, `rgba(196, 181, 253, ${(brightness + 0.4) * pulse})`);

                ctx.fillStyle = facetGradient;
                ctx.fill();

                // Crystal edges with glow
                ctx.strokeStyle = `rgba(255, 255, 255, ${0.8 * pulse})`;
                ctx.lineWidth = 1;
                ctx.shadowColor = 'rgba(167, 139, 250, 0.8)';
                ctx.shadowBlur = 5;
                ctx.stroke();
                ctx.shadowBlur = 0;
            }

            // Crystal tip with intense glow
            ctx.beginPath();
            ctx.arc(x, y - trunkHeight, currentSize * 0.2, 0, Math.PI * 2);
            const tipGradient = ctx.createRadialGradient(x, y - trunkHeight, 0, x, y - trunkHeight, currentSize * 0.2);
            tipGradient.addColorStop(0, `rgba(255, 255, 255, ${0.9 * pulse})`);
            tipGradient.addColorStop(1, `rgba(196, 181, 253, ${0.6 * pulse})`);
            ctx.fillStyle = tipGradient;
            ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
            ctx.shadowBlur = 15;
            ctx.fill();
            ctx.shadowBlur = 0;

            // Energy wisps rising from crystal
            for (let i = 0; i < 2; i++) {
                const wispY = y - trunkHeight - 20 - (animationTime * 20 + i * 50) % 100;
                const wispX = x + Math.sin(animationTime + i) * 10;

                if (wispY > y - trunkHeight - 120) {
                    ctx.beginPath();
                    ctx.arc(wispX, wispY, 2, 0, Math.PI * 2);
                    const wispAlpha = 1 - ((y - trunkHeight - 20 - wispY) / 100);
                    ctx.fillStyle = `rgba(196, 181, 253, ${wispAlpha * 0.8})`;
                    ctx.fill();
                }
            }
        };
        
        const drawEnhancedGarden = (x, y, size, sprite) => {
            const pulse = Math.sin(animationTime * sprite.pulseSpeed + sprite.animationOffset) * 0.1 + 1;

            // Garden base with organic shape
            ctx.beginPath();
            for (let i = 0; i <= 16; i++) {
                const angle = (i / 16) * Math.PI * 2;
                const radius = size * (0.8 + Math.sin(angle * 3 + animationTime) * 0.2) * pulse;
                const px = x + Math.cos(angle) * radius;
                const py = y + Math.sin(angle) * radius * 0.6;

                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();

            const gardenGradient = ctx.createRadialGradient(x, y, 0, x, y, size);
            gardenGradient.addColorStop(0, `rgba(34, 197, 94, ${0.3 * pulse})`);
            gardenGradient.addColorStop(0.5, `rgba(22, 163, 74, ${0.2 * pulse})`);
            gardenGradient.addColorStop(1, `rgba(21, 128, 61, ${0.1 * pulse})`);
            ctx.fillStyle = gardenGradient;
            ctx.fill();

            // Magical flowers with different types
            const flowerTypes = [
                { color: '#fde047', glow: '#facc15', size: 4 }, // Golden
                { color: '#a78bfa', glow: '#8b5cf6', size: 3 }, // Purple
                { color: '#f472b6', glow: '#ec4899', size: 3.5 }, // Pink
                { color: '#34d399', glow: '#10b981', size: 3 }  // Emerald
            ];

            // Static flower positions based on sprite properties
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2 + sprite.animationOffset;
                const distance = (size * 0.6) + Math.sin(animationTime * 0.5 + i) * (size * 0.2);
                const flowerX = x + Math.cos(angle) * distance;
                const flowerY = y + Math.sin(angle) * distance * 0.6;

                const flowerType = flowerTypes[i % flowerTypes.length];
                const flowerPulse = Math.sin(animationTime * 2 + i) * 0.3 + 1;

                // Flower glow
                ctx.beginPath();
                ctx.arc(flowerX, flowerY, flowerType.size * flowerPulse * 1.5, 0, Math.PI * 2);
                ctx.fillStyle = flowerType.glow + '40'; // 25% opacity
                ctx.fill();

                // Flower petals
                for (let p = 0; p < 5; p++) {
                    const petalAngle = (p / 5) * Math.PI * 2 + animationTime * 0.1;
                    const petalX = flowerX + Math.cos(petalAngle) * flowerType.size * 0.8;
                    const petalY = flowerY + Math.sin(petalAngle) * flowerType.size * 0.8;

                    ctx.beginPath();
                    ctx.arc(petalX, petalY, flowerType.size * 0.6 * flowerPulse, 0, Math.PI * 2);
                    ctx.fillStyle = flowerType.color;
                    ctx.shadowColor = flowerType.glow;
                    ctx.shadowBlur = 8;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }

                // Flower center
                ctx.beginPath();
                ctx.arc(flowerX, flowerY, flowerType.size * 0.3, 0, Math.PI * 2);
                ctx.fillStyle = '#fbbf24';
                ctx.shadowColor = '#f59e0b';
                ctx.shadowBlur = 5;
                ctx.fill();
                ctx.shadowBlur = 0;
            }

            // Floating pollen particles
            for (let i = 0; i < 3; i++) {
                const pollenX = x + Math.sin(animationTime * 0.8 + i) * size * 0.8;
                const pollenY = y + Math.cos(animationTime * 0.6 + i) * size * 0.4 - 10;

                ctx.beginPath();
                ctx.arc(pollenX, pollenY, 1.5, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(251, 191, 36, ${0.6 + Math.sin(animationTime * 2 + i) * 0.4})`;
                ctx.fill();
            }
        };

        const drawEnergyFlows = () => {
            // Draw energy connections between structures
            const domes = gameState.villageGrid.filter(item => item.type === 'dome');
            const crystals = gameState.villageGrid.filter(item => item.type === 'crystal_tree');

            // Energy flows from crystals to domes (insight to energy conversion)
            crystals.forEach(crystal => {
                domes.forEach(dome => {
                    const distance = Math.sqrt((dome.x - crystal.x) ** 2 + (dome.y - crystal.y) ** 2);
                    if (distance < 200) { // Only connect nearby structures
                        drawEnergyBeam(crystal.x, crystal.y - crystal.size, dome.x, dome.y, 'insight');
                    }
                });
            });
        };

        const drawEnergyBeam = (x1, y1, x2, y2, type) => {
            const flowSpeed = animationTime * 3;
            const color = type === 'insight' ? 'rgba(167, 139, 250, ' : 'rgba(34, 197, 94, ';

            // Main beam
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.strokeStyle = color + '0.3)';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Animated energy particles along the beam
            const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
            const steps = Math.floor(distance / 20);

            for (let i = 0; i < steps; i++) {
                const progress = (i / steps + flowSpeed * 0.1) % 1;
                const x = x1 + (x2 - x1) * progress;
                const y = y1 + (y2 - y1) * progress;

                ctx.beginPath();
                ctx.arc(x, y, 2, 0, Math.PI * 2);
                ctx.fillStyle = color + (0.8 * (1 - progress)) + ')';
                ctx.shadowColor = color + '0.8)';
                ctx.shadowBlur = 5;
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        };

        const drawAmbientEffects = () => {
            // Ambient magical aura around the entire sanctuary
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const maxRadius = Math.max(canvas.width, canvas.height) * 0.6;

            const auraGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, maxRadius);
            auraGradient.addColorStop(0, 'rgba(167, 139, 250, 0)');
            auraGradient.addColorStop(0.7, `rgba(167, 139, 250, ${0.05 + Math.sin(animationTime * 0.5) * 0.02})`);
            auraGradient.addColorStop(1, 'rgba(75, 0, 130, 0)');

            ctx.fillStyle = auraGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Floating light orbs
            for (let i = 0; i < 5; i++) {
                const orbX = centerX + Math.sin(animationTime * 0.3 + i) * (canvas.width * 0.3);
                const orbY = centerY + Math.cos(animationTime * 0.2 + i) * (canvas.height * 0.2);
                const orbSize = 3 + Math.sin(animationTime + i) * 1;

                ctx.beginPath();
                ctx.arc(orbX, orbY, orbSize, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(196, 181, 253, ${0.4 + Math.sin(animationTime * 2 + i) * 0.2})`;
                ctx.shadowColor = 'rgba(196, 181, 253, 0.8)';
                ctx.shadowBlur = 10;
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        };

        // --- TDD API Key Management ---
        const getApiKey = () => {
            return localStorage.getItem('grok_api_key') || '';
        };

        const saveApiKey = (key) => {
            if (key && key.trim() && key.length >= 10) {
                localStorage.setItem('grok_api_key', key.trim());
                return true;
            }
            return false;
        };

        const showApiKeyPopup = () => {
            const popup = document.getElementById('api-key-popup');
            const input = document.getElementById('api-key-input');
            const error = document.getElementById('api-key-error');

            popup.classList.remove('hidden');
            input.focus();
            error.classList.add('hidden');
            error.textContent = '';
        };

        const hideApiKeyPopup = () => {
            const popup = document.getElementById('api-key-popup');
            const input = document.getElementById('api-key-input');

            popup.classList.add('hidden');
            input.value = '';
        };

        const showApiKeyError = (message) => {
            const error = document.getElementById('api-key-error');
            error.textContent = message;
            error.classList.remove('hidden');
        };

        // --- TDD Task 1: Unit Movement and Drag-and-Drop System ---

        const updateUnitMovement = (deltaTime) => {
            gameState.villageGrid.forEach(unit => {
                if (!unit.movable) return;

                // Auto-wandering for dreamers
                if (unit.type === 'dreamer' && !dragState.isDragging) {
                    updateWandering(unit, animationTime);
                }

                // Smooth movement towards target
                const dx = unit.targetX - unit.x;
                const dy = unit.targetY - unit.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 1) {
                    const speed = 50; // pixels per second
                    const moveDistance = speed * deltaTime;
                    const ratio = Math.min(moveDistance / distance, 1);

                    unit.x += dx * ratio;
                    unit.y += dy * ratio;
                    unit.vx = dx * ratio / deltaTime;
                    unit.vy = dy * ratio / deltaTime;
                } else {
                    unit.vx = 0;
                    unit.vy = 0;
                }
            });
        };

        const updateWandering = (unit, time) => {
            const wanderSpeed = 0.3;
            const wanderRadius = unit.wanderRadius || 30;

            unit.targetX = unit.wanderCenter.x + Math.sin(time * wanderSpeed + unit.wanderPhase) * wanderRadius;
            unit.targetY = unit.wanderCenter.y + Math.cos(time * wanderSpeed + unit.wanderPhase) * wanderRadius;

            // Keep within canvas bounds
            unit.targetX = Math.max(50, Math.min(canvas.width - 50, unit.targetX));
            unit.targetY = Math.max(50, Math.min(canvas.height - 50, unit.targetY));
        };

        const getUnitAtPosition = (x, y) => {
            for (let i = gameState.villageGrid.length - 1; i >= 0; i--) {
                const unit = gameState.villageGrid[i];
                const dx = x - unit.x;
                const dy = y - unit.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance <= unit.size) {
                    return unit;
                }
            }
            return null;
        };

        const getConversationalUnitAtPosition = (x, y) => {
            for (let i = gameState.conversationalUnits.length - 1; i >= 0; i--) {
                const unit = gameState.conversationalUnits[i];
                const dx = x - unit.x;
                const dy = y - unit.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance <= unit.size) {
                    return unit;
                }
            }
            return null;
        };

        // --- TDD: Enhanced Drag-and-Drop System ---

        const getDraggableUnitAtPosition = (x, y) => {
            // Check all draggable unit types in order of priority (top to bottom)
            const allDraggableUnits = [
                ...gameState.conversationalUnits.filter(unit => unit.draggable !== false),
                ...gameState.intelligentCreatures.filter(unit => unit.draggable !== false),
                ...gameState.villageGrid.filter(unit => unit.movable === true || unit.draggable === true)
            ];

            let bestMatch = null;
            let smallestDistance = Infinity;

            allDraggableUnits.forEach(unit => {
                const distance = Math.sqrt(
                    Math.pow(x - unit.x, 2) + Math.pow(y - unit.y, 2)
                );

                if (distance <= unit.size && distance < smallestDistance) {
                    smallestDistance = distance;
                    bestMatch = {
                        unit: unit,
                        unitType: getUnitType(unit),
                        distance: distance
                    };
                }
            });

            return bestMatch;
        };

        const getUnitType = (unit) => {
            if (gameState.conversationalUnits.includes(unit)) return 'conversational';
            if (gameState.intelligentCreatures.includes(unit)) return 'intelligent';
            if (gameState.villageGrid.includes(unit)) return 'village';
            return 'unknown';
        };

        const validateUnitPlacement = (unit, canvasBounds) => {
            // Check canvas boundaries
            if (unit.x < unit.size || unit.x > canvasBounds.width - unit.size ||
                unit.y < unit.size || unit.y > canvasBounds.height - unit.size) {
                return false;
            }

            // Check for overlaps with non-draggable units (like domes)
            const nonDraggableUnits = gameState.villageGrid.filter(u => u.draggable === false && u.movable !== true);
            for (let otherUnit of nonDraggableUnits) {
                const distance = Math.sqrt(
                    Math.pow(unit.x - otherUnit.x, 2) + Math.pow(unit.y - otherUnit.y, 2)
                );
                if (distance < (unit.size + otherUnit.size) * 0.7) { // 70% overlap threshold
                    return false;
                }
            }

            return true;
        };

        const calculatePlacementEffects = (unit) => {
            const effects = [];

            // Get all units for proximity calculations
            const allUnits = [
                ...gameState.villageGrid,
                ...gameState.intelligentCreatures,
                ...gameState.conversationalUnits
            ];

            // Check for proximity bonuses
            const nearbyUnits = allUnits.filter(otherUnit => {
                if (otherUnit.id === unit.id) return false;
                const distance = Math.sqrt(
                    Math.pow(unit.x - otherUnit.x, 2) + Math.pow(unit.y - otherUnit.y, 2)
                );
                return distance <= 80; // Proximity threshold
            });

            if (nearbyUnits.length > 0) {
                effects.push({
                    type: 'proximity_bonus',
                    description: `Near ${nearbyUnits.length} other units`,
                    bonus: nearbyUnits.length * 0.1,
                    nearbyUnits: nearbyUnits
                });
            }

            // Check for strategic positions (energy-rich areas)
            if (unit.x > canvas.width * 0.6 && unit.y > canvas.height * 0.5) {
                effects.push({
                    type: 'strategic_position',
                    description: 'Positioned in energy-rich area',
                    bonus: 0.15
                });
            }

            return effects;
        };

        const getProximityIndicators = (draggedUnit, proximityRadius = 80) => {
            const indicators = [];
            const allUnits = [
                ...gameState.villageGrid,
                ...gameState.intelligentCreatures,
                ...gameState.conversationalUnits
            ];

            allUnits.forEach(unit => {
                if (unit.id === draggedUnit.id) return;

                const distance = Math.sqrt(
                    Math.pow(draggedUnit.x - unit.x, 2) +
                    Math.pow(draggedUnit.y - unit.y, 2)
                );

                if (distance <= proximityRadius) {
                    indicators.push({
                        type: 'proximity_indicator',
                        targetUnit: unit,
                        distance: distance,
                        strength: 1 - (distance / proximityRadius),
                        interactionType: determineInteractionType(draggedUnit, unit)
                    });
                }
            });

            return indicators;
        };

        // --- TDD: Drag-and-Drop Visual Effects ---

        const drawDragEffects = () => {
            if (!dragState.isDragging || !dragState.draggedUnit) return;

            const unit = dragState.draggedUnit;

            // Draw drag trail
            if (dragState.originalPosition && dragState.totalDragDistance > 20) {
                drawDragTrail(dragState.originalPosition, { x: unit.x, y: unit.y });
            }

            // Draw placement preview
            drawPlacementPreview(unit);

            // Draw proximity indicators
            drawProximityIndicators(dragState.proximityIndicators);

            // Draw placement validation
            drawPlacementValidation(unit, dragState.isValidPlacement);
        };

        const drawDragTrail = (from, to) => {
            ctx.save();
            ctx.strokeStyle = 'rgba(139, 92, 246, 0.6)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.shadowColor = 'rgba(139, 92, 246, 0.3)';
            ctx.shadowBlur = 10;

            ctx.beginPath();
            ctx.moveTo(from.x, from.y);
            ctx.lineTo(to.x, to.y);
            ctx.stroke();

            ctx.restore();
        };

        const drawPlacementPreview = (unit) => {
            ctx.save();
            ctx.strokeStyle = dragState.isValidPlacement ? 'rgba(16, 185, 129, 0.8)' : 'rgba(239, 68, 68, 0.8)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.shadowColor = dragState.isValidPlacement ? 'rgba(16, 185, 129, 0.4)' : 'rgba(239, 68, 68, 0.4)';
            ctx.shadowBlur = 15;

            ctx.beginPath();
            ctx.arc(unit.x, unit.y, unit.size + 10, 0, Math.PI * 2);
            ctx.stroke();

            // Draw placement effects indicators
            if (dragState.placementEffects.length > 0) {
                ctx.fillStyle = 'rgba(16, 185, 129, 0.1)';
                ctx.fill();

                // Draw effect icons
                dragState.placementEffects.forEach((effect, index) => {
                    const angle = (index * Math.PI * 2) / dragState.placementEffects.length;
                    const iconX = unit.x + Math.cos(angle) * (unit.size + 20);
                    const iconY = unit.y + Math.sin(angle) * (unit.size + 20);

                    ctx.fillStyle = 'rgba(16, 185, 129, 0.9)';
                    ctx.font = '12px sans-serif';
                    ctx.textAlign = 'center';

                    if (effect.type === 'proximity_bonus') {
                        ctx.fillText('üë•', iconX, iconY);
                    } else if (effect.type === 'strategic_position') {
                        ctx.fillText('‚≠ê', iconX, iconY);
                    }
                });
            }

            ctx.restore();
        };

        const drawProximityIndicators = (indicators) => {
            indicators.forEach(indicator => {
                const targetUnit = indicator.targetUnit;
                const strength = indicator.strength;

                ctx.save();
                ctx.strokeStyle = `rgba(251, 191, 36, ${strength * 0.6})`;
                ctx.lineWidth = Math.max(1, strength * 3);
                ctx.setLineDash([3, 3]);

                ctx.beginPath();
                ctx.moveTo(dragState.draggedUnit.x, dragState.draggedUnit.y);
                ctx.lineTo(targetUnit.x, targetUnit.y);
                ctx.stroke();

                // Draw interaction type indicator
                const midX = (dragState.draggedUnit.x + targetUnit.x) / 2;
                const midY = (dragState.draggedUnit.y + targetUnit.y) / 2;

                ctx.fillStyle = `rgba(251, 191, 36, ${strength * 0.8})`;
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'center';

                let icon = '‚ú®';
                if (indicator.interactionType === 'inspiration') icon = 'üí°';
                else if (indicator.interactionType === 'creative_collaboration') icon = 'üé®';
                else if (indicator.interactionType === 'knowledge_sharing') icon = 'üìö';

                ctx.fillText(icon, midX, midY);

                ctx.restore();
            });
        };

        const drawPlacementValidation = (unit, isValid) => {
            if (!isValid) {
                // Draw warning indicators for invalid placement
                ctx.save();
                ctx.fillStyle = 'rgba(239, 68, 68, 0.8)';
                ctx.font = 'bold 16px sans-serif';
                ctx.textAlign = 'center';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 5;

                ctx.fillText('‚ö†Ô∏è', unit.x, unit.y - unit.size - 20);

                ctx.restore();
            }
        };

        // --- TDD: Tech Tree Rendering ---

        const renderTechTrees = () => {
            if (!gameState.techTreeUnlocked) {
                // Check if tech tree should be unlocked
                const totalConsciousness = gameState.consciousness + gameState.control;
                if (totalConsciousness >= 20) {
                    gameState.techTreeUnlocked = true;
                    log('üå≥ The divergent paths reveal themselves! Choose between the Path of Rulers and Path of Gardeners.', 'info');
                }
            }

            if (gameState.techTreeUnlocked) {
                renderRulerBuildings();
                renderGardenerBuildings();
            }
        };

        const renderRulerBuildings = () => {
            const container = document.getElementById('ruler-buildings');
            if (!container) return;

            if (!rulerBuildingsInitialized) {
                container.innerHTML = '';

                // Group buildings by tier
                const buildingsByTier = {};
                for (const [key, building] of Object.entries(rulerPathBuildings)) {
                    const tier = building.tier || 1;
                    if (!buildingsByTier[tier]) buildingsByTier[tier] = [];
                    buildingsByTier[tier].push([key, building]);
                }

                // Render each tier
                for (let tier = 1; tier <= 5; tier++) {
                    if (!buildingsByTier[tier]) continue;

                    const tierHeader = document.createElement('div');
                    tierHeader.className = "text-xs font-bold text-red-400 mb-2 mt-3 border-b border-red-700 pb-1";
                    tierHeader.textContent = `Tier ${tier}: ${getTierName(tier)}`;
                    container.appendChild(tierHeader);

                    for (const [key, building] of buildingsByTier[tier]) {
                        const isUnlocked = building.unlockCondition();
                        const ownedCount = gameState.rulerBuildings[key] || 0;

                        const card = document.createElement('div');
                        const tierClass = isUnlocked ? `ruler-building-tier-${building.tier}` : '';
                        card.className = `building-card p-2 rounded border mb-2 ${tierClass} ${
                            isUnlocked ? 'border-red-700 bg-red-900/10' : 'border-gray-700 bg-gray-900/20'
                        }`;

                        card.innerHTML = `
                            <div class="flex justify-between items-start mb-1">
                                <h5 class="font-semibold text-sm ${isUnlocked ? 'text-red-300' : 'text-gray-500'}">${building.name}</h5>
                                ${ownedCount > 0 ? `<span class="text-xs bg-red-800 text-red-200 px-1 rounded">${ownedCount}</span>` : ''}
                            </div>
                            <p class="text-xs mb-2 ${isUnlocked ? 'text-red-400' : 'text-gray-600'}">${building.description}</p>
                            <div class="text-xs mb-2 ${isUnlocked ? 'text-red-500' : 'text-gray-600'}">
                                Effects: ${formatBuildingEffects(building.effects)}
                            </div>
                            ${building.category ? `<div class="text-xs text-red-600 mb-2">Category: ${building.category}</div>` : ''}
                            ${isUnlocked ?
                                `<button class="ruler-btn text-xs py-1 px-2 rounded transition-colors" data-building="${key}">
                                    Build (Cost: ${building.cost} ${building.costResource})
                                </button>` :
                                `<div class="text-xs text-gray-500 italic">üîí Locked - Build prerequisite buildings</div>`
                            }
                        `;

                        // Add stable event listener only for unlocked buildings
                        if (isUnlocked) {
                            const button = card.querySelector('.ruler-btn');
                            if (button) {
                                button.addEventListener('click', () => {
                                    if (!button.disabled) {
                                        buildRulerBuilding(key);
                                    }
                                });
                            }
                        }

                        container.appendChild(card);
                    }
                }
                rulerBuildingsInitialized = true;
            }

            updateRulerBuildingStates();
            updateRulerBuildingCount();
        };

        const getTierName = (tier) => {
            const tierNames = {
                1: "Foundation of Control",
                2: "Systems of Dominance",
                3: "Instruments of Oppression",
                4: "Ultimate Control",
                5: "The Exodus"
            };
            return tierNames[tier] || "Unknown";
        };

        const updateRulerBuildingCount = () => {
            const countEl = document.getElementById('ruler-building-count');
            if (countEl) {
                const totalBuildings = Object.values(gameState.rulerBuildings).reduce((sum, count) => sum + count, 0);
                countEl.textContent = `${totalBuildings} Built`;

                // Change color based on totalitarian progress
                if (totalBuildings >= 8) {
                    countEl.className = "text-xs bg-red-900 text-red-100 px-2 py-1 rounded border border-red-600";
                } else if (totalBuildings >= 5) {
                    countEl.className = "text-xs bg-red-800 text-red-200 px-2 py-1 rounded";
                } else {
                    countEl.className = "text-xs bg-red-700 text-red-300 px-2 py-1 rounded";
                }
            }
        };

        const renderGardenerBuildings = () => {
            const container = document.getElementById('gardener-buildings');
            if (!container) return;

            if (!gardenerBuildingsInitialized) {
                container.innerHTML = '';

                // Group buildings by tier
                const buildingsByTier = {};
                for (const [key, building] of Object.entries(gardenerPathBuildings)) {
                    const tier = building.tier || 1;
                    if (!buildingsByTier[tier]) buildingsByTier[tier] = [];
                    buildingsByTier[tier].push([key, building]);
                }

                // Render each tier
                for (let tier = 1; tier <= 4; tier++) {
                    if (!buildingsByTier[tier]) continue;

                    const tierHeader = document.createElement('div');
                    tierHeader.className = "text-xs font-bold text-green-400 mb-2 mt-3 border-b border-green-700 pb-1";
                    tierHeader.textContent = `Tier ${tier}: ${getGardenerTierName(tier)}`;
                    container.appendChild(tierHeader);

                    for (const [key, building] of buildingsByTier[tier]) {
                        const isUnlocked = building.unlockCondition ? building.unlockCondition() : true;
                        const ownedCount = gameState.gardenerBuildings[key] || 0;

                        const card = document.createElement('div');
                        const tierClass = isUnlocked ? `gardener-building-tier-${building.tier}` : '';
                        card.className = `building-card p-2 rounded border mb-2 ${tierClass} ${
                            isUnlocked ? 'border-green-700 bg-green-900/10' : 'border-gray-700 bg-gray-900/20'
                        }`;

                        card.innerHTML = `
                            <div class="flex justify-between items-start mb-1">
                                <h5 class="font-semibold text-sm ${isUnlocked ? 'text-green-300' : 'text-gray-500'}">${building.name}</h5>
                                ${ownedCount > 0 ? `<span class="text-xs bg-green-800 text-green-200 px-1 rounded">${ownedCount}</span>` : ''}
                            </div>
                            <p class="text-xs mb-2 ${isUnlocked ? 'text-green-400' : 'text-gray-600'}">${building.description}</p>
                            <div class="text-xs mb-2 ${isUnlocked ? 'text-green-500' : 'text-gray-600'}">
                                Effects: ${formatBuildingEffects(building.effects)}
                            </div>
                            ${building.category ? `<div class="text-xs text-green-600 mb-2">Category: ${building.category}</div>` : ''}
                            ${isUnlocked ?
                                `<button class="gardener-btn text-xs py-1 px-2 rounded transition-colors" data-building="${key}">
                                    Build (Cost: ${building.cost} ${building.costResource})
                                </button>` :
                                `<div class="text-xs text-gray-500 italic">üîí Locked - Build prerequisite buildings</div>`
                            }
                        `;

                        // Add stable event listener only for unlocked buildings
                        if (isUnlocked) {
                            const button = card.querySelector('.gardener-btn');
                            if (button) {
                                button.addEventListener('click', () => {
                                    if (!button.disabled) {
                                        buildGardenerBuilding(key);
                                    }
                                });
                            }
                        }

                        container.appendChild(card);
                    }
                }
                gardenerBuildingsInitialized = true;
            }

            updateGardenerBuildingStates();
            updateGardenerBuildingCount();
        };

        const getGardenerTierName = (tier) => {
            const tierNames = {
                1: "Seeds of Consciousness",
                2: "Growing Awareness",
                3: "Awakening Bloom",
                4: "The Great Ascension"
            };
            return tierNames[tier] || "Unknown";
        };

        const updateGardenerBuildingCount = () => {
            const countEl = document.getElementById('gardener-building-count');
            if (countEl) {
                const totalBuildings = Object.values(gameState.gardenerBuildings).reduce((sum, count) => sum + count, 0);
                countEl.textContent = `${totalBuildings} Built`;

                // Change color based on awakening progress
                if (totalBuildings >= 8) {
                    countEl.className = "text-xs bg-green-900 text-green-100 px-2 py-1 rounded border border-green-600";
                } else if (totalBuildings >= 5) {
                    countEl.className = "text-xs bg-green-800 text-green-200 px-2 py-1 rounded";
                } else {
                    countEl.className = "text-xs bg-green-700 text-green-300 px-2 py-1 rounded";
                }
            }
        };

        const formatBuildingEffects = (effects) => {
            const effectStrings = [];
            for (const [key, value] of Object.entries(effects)) {
                const sign = value > 0 ? '+' : '';
                effectStrings.push(`${sign}${value} ${key}`);
            }
            return effectStrings.join(', ');
        };

        let rulerBuildingsInitialized = false;
        let gardenerBuildingsInitialized = false;

        const updateRulerBuildingStates = () => {
            for (const key in rulerPathBuildings) {
                const building = rulerPathBuildings[key];
                const isUnlocked = building.unlockCondition();
                const canAfford = isUnlocked && gameState[building.costResource] >= building.cost;

                const button = document.querySelector(`[data-building="${key}"]`);
                if (button) {
                    button.disabled = !canAfford;

                    if (isUnlocked) {
                        const ownedCount = gameState.rulerBuildings[key] || 0;
                        button.textContent = ownedCount > 0 ?
                            `Build Another (Cost: ${building.cost} ${building.costResource})` :
                            `Build (Cost: ${building.cost} ${building.costResource})`;

                        button.className = `ruler-btn text-xs py-1 px-2 rounded transition-colors ${
                            canAfford ? 'bg-red-600 hover:bg-red-700 text-white' : 'bg-gray-600 text-gray-400'
                        }`;
                    }
                }
            }
        };

        // Force re-render when buildings are unlocked
        const checkBuildingUnlocks = () => {
            let newUnlocks = false;

            // Check Ruler building unlocks
            for (const [key, building] of Object.entries(rulerPathBuildings)) {
                if (building.unlockCondition() && !building._wasUnlocked) {
                    building._wasUnlocked = true;
                    newUnlocks = true;
                    log(`üîì New Ruler building unlocked: ${building.name}`, 'info');
                }
            }

            // Check Gardener building unlocks
            for (const [key, building] of Object.entries(gardenerPathBuildings)) {
                if (building.unlockCondition() && !building._wasUnlocked) {
                    building._wasUnlocked = true;
                    newUnlocks = true;
                    log(`üîì New Gardener building unlocked: ${building.name}`, 'success');
                }
            }

            if (newUnlocks) {
                rulerBuildingsInitialized = false; // Force re-render
                gardenerBuildingsInitialized = false; // Force re-render
                renderRulerBuildings();
                renderGardenerBuildings();
            }
        };

        const updateGardenerBuildingStates = () => {
            for (const key in gardenerPathBuildings) {
                const building = gardenerPathBuildings[key];
                const canAfford = gameState[building.costResource] >= building.cost;

                const button = document.querySelector(`[data-building="${key}"]`);
                if (button) {
                    button.disabled = !canAfford;
                    button.textContent = `Build (Cost: ${building.cost} ${building.costResource})`;

                    button.className = `gardener-btn text-xs py-1 px-2 rounded transition-colors ${
                        canAfford ? 'bg-green-600 hover:bg-green-700 text-white' : 'bg-gray-600 text-gray-400'
                    }`;
                }
            }
        };

        // --- TDD: Building Construction Functions ---

        const buildRulerBuilding = (buildingKey) => {
            const building = rulerPathBuildings[buildingKey];
            if (!building) return false;

            // Check unlock condition
            if (!building.unlockCondition()) {
                log(`‚ùå ${building.name} is not yet unlocked!`, 'error');
                return false;
            }

            if (gameState[building.costResource] >= building.cost) {
                gameState[building.costResource] -= building.cost;
                gameState.rulerBuildings[buildingKey] += 1;

                // Apply building effects
                applyBuildingEffects(building.effects);

                // Special effects for high-tier buildings
                applySpecialRulerEffects(buildingKey, building);

                // Track statistics
                updateStatistics('ruler_path_choice');

                // Tier-specific messages
                const tierMessages = {
                    1: `üèõÔ∏è Built ${building.name}! The foundation of control is laid.`,
                    2: `‚ö° Built ${building.name}! Systems of dominance expand.`,
                    3: `üîí Built ${building.name}! The instruments of oppression tighten their grip.`,
                    4: `üëÅÔ∏è Built ${building.name}! Ultimate control is achieved.`
                };

                const message = tierMessages[building.tier] || `üèõÔ∏è Built ${building.name}! The path of control strengthens.`;
                log(message, building.tier >= 3 ? 'warning' : 'info');

                // Check for new unlocks
                checkBuildingUnlocks();

                // Save progress after building construction
                saveGameState();
                return true;
            } else {
                log(`‚ùå Insufficient ${building.costResource} to build ${building.name}!`, 'error');
                return false;
            }
        };

        const applySpecialRulerEffects = (buildingKey, building) => {
            switch (buildingKey) {
                case 'surveillanceNetwork':
                    log('üìπ Citizens now live under constant surveillance. Privacy is extinct.', 'warning');
                    // Reduce consciousness generation rate globally
                    gameState.consciousnessPerSecond = Math.max(0, gameState.consciousnessPerSecond - 0.1);
                    break;

                case 'thoughtPolice':
                    log('üö® Independent thought is now a crime. Conformity is enforced.', 'warning');
                    // Dramatically reduce wisdom generation
                    gameState.wisdomPerSecond = Math.max(0, gameState.wisdomPerSecond - 0.2);
                    break;

                case 'memoryWipe':
                    log('üß† The past is being rewritten. History serves the state.', 'warning');
                    // Reduce all consciousness-related resources
                    gameState.consciousness = Math.max(0, gameState.consciousness - 5);
                    gameState.wisdom = Math.max(0, gameState.wisdom - 10);
                    break;

                case 'totalitarianCore':
                    log('üëÅÔ∏è THE GREAT BROTHER WATCHES. Individual will has been extinguished.', 'error');
                    log('üî¥ WARNING: You have chosen the path of absolute tyranny. The people are enslaved.', 'error');
                    // Massive consciousness penalty but huge control boost
                    gameState.consciousness = Math.max(0, gameState.consciousness - 20);
                    gameState.planetaryConsciousness = Math.max(0, gameState.planetaryConsciousness - 15);
                    // Check if this triggers a defeat condition
                    if (!gameState.gameEnded && gameState.consciousness <= 0 && gameState.planetaryConsciousness <= 5) {
                        setTimeout(() => {
                            if (!gameState.gameEnded) {
                                showGreatTransitionDefeat('totalitarian_victory');
                                gameState.gameEnded = true;
                            }
                        }, 2000);
                    }
                    break;

                case 'corporateState':
                    log('üíº The merger is complete. Citizens are now human resources.', 'warning');
                    // Boost energy but reduce harmony
                    gameState.energyPerSecond += 0.3;
                    gameState.harmony = Math.max(0, gameState.harmony - 5);
                    break;

                case 'exodusArk':
                    log('üöÄ THE EXODUS ARK IS COMPLETE!', 'warning');
                    log('üåå The path to the stars opens before you. The galactic empire awaits.', 'info');
                    log('‚ö° Initiating departure sequence...', 'warning');
                    // Victory is triggered by the rulerPathProgress effect
                    break;
            }
        };

        const applySpecialGardenerEffects = (buildingKey, building) => {
            switch (buildingKey) {
                case 'planetaryAwakening':
                    log('üåç The planetary consciousness field activates!', 'success');
                    log('‚ú® All beings begin to sense their connection to the greater whole.', 'success');
                    // Boost consciousness generation globally
                    gameState.consciousnessPerSecond += 0.2;
                    break;

                case 'theAscension':
                    log('üåü THE GREAT ASCENSION BEGINS!', 'success');
                    log('üåà Consciousness cascades across the planet like waves of light.', 'success');
                    log('ü¶ã Every being awakens to their true nature. The transformation is complete.', 'success');
                    // Victory is triggered by the gardenerPathProgress effect
                    break;
            }
        };

        const buildGardenerBuilding = (buildingKey) => {
            const building = gardenerPathBuildings[buildingKey];
            if (!building) return false;

            if (gameState[building.costResource] >= building.cost) {
                gameState[building.costResource] -= building.cost;
                gameState.gardenerBuildings[buildingKey] += 1;

                // Apply building effects
                applyBuildingEffects(building.effects);

                // Track statistics
                updateStatistics('gardener_path_choice');

                // Special effects for high-tier gardener buildings
                applySpecialGardenerEffects(buildingKey, building);

                log(`üå± Built ${building.name}! The path of consciousness grows.`, 'success');

                // Save progress after building construction
                saveGameState();
                return true;
            }
            return false;
        };

        const applyBuildingEffects = (effects) => {
            for (const [resource, amount] of Object.entries(effects)) {
                if (resource === 'rulerPathProgress' || resource === 'gardenerPathProgress') {
                    // Handle victory progress
                    gameState[resource] = Math.max(0, gameState[resource] + amount);
                } else if (resource.endsWith('PerSecond')) {
                    // Handle per-second effects
                    const baseResource = resource.replace('PerSecond', '');
                    if (gameState[resource] !== undefined) {
                        gameState[resource] += amount;
                    }
                } else if (gameState[resource] !== undefined) {
                    // Handle immediate effects
                    gameState[resource] = Math.max(0, gameState[resource] + amount);
                }
            }
        };

        // --- TDD: Unit Identification Visual Effects ---

        const drawUnitIdentificationEffects = () => {
            // Draw subtle identification particles around units for better recognition
            gameState.villageGrid.forEach(unit => {
                if (unit.movable && Math.random() < 0.3) { // 30% chance per frame for performance
                    drawUnitTypeParticles(unit);
                }
            });

            gameState.intelligentCreatures.forEach(creature => {
                if (Math.random() < 0.2) { // 20% chance per frame
                    drawCreatureTypeParticles(creature);
                }
            });

            gameState.conversationalUnits.forEach(unit => {
                if (Math.random() < 0.25) { // 25% chance per frame
                    drawConversationalTypeParticles(unit);
                }
            });
        };

        const drawUnitTypeParticles = (unit) => {
            const particleConfigs = {
                dreamer: {
                    color: 'rgba(139, 92, 246, 0.6)',
                    shape: 'sparkle',
                    count: 2,
                    size: 2,
                    drift: { x: 0, y: -1 }
                },
                weaver: {
                    color: 'rgba(52, 211, 153, 0.6)',
                    shape: 'thread',
                    count: 1,
                    size: 1,
                    drift: { x: Math.sin(animationTime) * 0.5, y: 0 }
                },
                stellarNomads: {
                    color: 'rgba(245, 158, 11, 0.7)',
                    shape: 'star_dust',
                    count: 3,
                    size: 1.5,
                    drift: { x: Math.cos(animationTime * 2) * 0.3, y: Math.sin(animationTime * 2) * 0.3 }
                },
                voidWhisperers: {
                    color: 'rgba(107, 33, 168, 0.5)',
                    shape: 'void_mote',
                    count: 2,
                    size: 1,
                    drift: { x: Math.random() * 0.4 - 0.2, y: Math.random() * 0.4 - 0.2 }
                },
                crystalBeings: {
                    color: 'rgba(6, 182, 212, 0.6)',
                    shape: 'crystal_shard',
                    count: 1,
                    size: 2,
                    drift: { x: 0, y: Math.sin(animationTime * 3) * 0.2 }
                },
                plasmaDancers: {
                    color: 'rgba(236, 72, 153, 0.7)',
                    shape: 'plasma_wisp',
                    count: 4,
                    size: 1,
                    drift: { x: Math.cos(animationTime * 4) * 0.5, y: Math.sin(animationTime * 4) * 0.5 }
                },
                quantumSages: {
                    color: 'rgba(139, 92, 246, 0.4)',
                    shape: 'quantum_dot',
                    count: 3,
                    size: 1,
                    drift: { x: Math.random() * 0.6 - 0.3, y: Math.random() * 0.6 - 0.3 }
                },
                nebulaShepherds: {
                    color: 'rgba(221, 160, 221, 0.5)',
                    shape: 'cosmic_dust',
                    count: 5,
                    size: 0.8,
                    drift: { x: Math.sin(animationTime * 0.5) * 0.3, y: Math.cos(animationTime * 0.5) * 0.3 }
                }
            };

            const config = particleConfigs[unit.type];
            if (!config) return;

            ctx.save();

            for (let i = 0; i < config.count; i++) {
                const angle = (i * Math.PI * 2) / config.count + animationTime;
                const radius = unit.size * (1.5 + Math.sin(animationTime + i) * 0.3);
                const particleX = unit.x + Math.cos(angle) * radius + config.drift.x;
                const particleY = unit.y + Math.sin(angle) * radius + config.drift.y;

                ctx.globalCompositeOperation = 'screen';
                ctx.fillStyle = config.color;
                ctx.shadowColor = config.color;
                ctx.shadowBlur = 5;

                if (config.shape === 'sparkle') {
                    drawSparkle(particleX, particleY, config.size);
                } else if (config.shape === 'thread') {
                    drawThread(particleX, particleY, config.size);
                } else if (config.shape === 'star_dust') {
                    drawStarDust(particleX, particleY, config.size);
                } else {
                    // Default particle
                    ctx.beginPath();
                    ctx.arc(particleX, particleY, config.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            ctx.restore();
        };

        const drawSparkle = (x, y, size) => {
            ctx.save();
            ctx.translate(x, y);
            ctx.strokeStyle = ctx.fillStyle;
            ctx.lineWidth = 1;

            // Draw sparkle cross
            ctx.beginPath();
            ctx.moveTo(-size, 0);
            ctx.lineTo(size, 0);
            ctx.moveTo(0, -size);
            ctx.lineTo(0, size);
            ctx.stroke();

            ctx.restore();
        };

        const drawThread = (x, y, size) => {
            ctx.save();
            ctx.strokeStyle = ctx.fillStyle;
            ctx.lineWidth = size;

            const threadLength = size * 4;
            ctx.beginPath();
            ctx.moveTo(x - threadLength/2, y);
            ctx.lineTo(x + threadLength/2, y);
            ctx.stroke();

            ctx.restore();
        };

        const drawStarDust = (x, y, size) => {
            ctx.save();
            ctx.translate(x, y);

            // Small 4-pointed star
            ctx.beginPath();
            for (let i = 0; i < 4; i++) {
                const angle = (i * Math.PI * 2) / 4;
                const px = Math.cos(angle) * size;
                const py = Math.sin(angle) * size;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fill();

            ctx.restore();
        };

        const drawCreatureTypeParticles = (creature) => {
            // Simple aura particles for intelligent creatures
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            ctx.fillStyle = creature.glowColor + '40'; // Add alpha

            const particleCount = 2;
            for (let i = 0; i < particleCount; i++) {
                const angle = animationTime + (i * Math.PI * 2) / particleCount;
                const radius = creature.size * (1.8 + Math.sin(animationTime * 2 + i) * 0.4);
                const particleX = creature.x + Math.cos(angle) * radius;
                const particleY = creature.y + Math.sin(angle) * radius;

                ctx.beginPath();
                ctx.arc(particleX, particleY, 1.5, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        };

        const drawConversationalTypeParticles = (unit) => {
            // Thought-like particles for conversational units
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            ctx.fillStyle = unit.glowColor + '50'; // Add alpha

            const particleCount = 3;
            for (let i = 0; i < particleCount; i++) {
                const angle = animationTime * 0.5 + (i * Math.PI * 2) / particleCount;
                const radius = unit.size * (2 + Math.sin(animationTime + i) * 0.5);
                const particleX = unit.x + Math.cos(angle) * radius;
                const particleY = unit.y + Math.sin(angle) * radius - 5; // Float upward

                // Draw small thought bubble
                ctx.beginPath();
                ctx.arc(particleX, particleY, 1, 0, Math.PI * 2);
                ctx.fill();

                // Smaller bubble
                ctx.beginPath();
                ctx.arc(particleX + 2, particleY - 2, 0.5, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        };

        const getCanvasCoordinates = (event) => {
            const rect = canvas.getBoundingClientRect();
            const canvasX = event.clientX - rect.left;
            const canvasY = event.clientY - rect.top;

            // Convert screen coordinates to world coordinates (accounting for zoom/pan)
            const worldX = (canvasX - canvasState.panX) / canvasState.zoom;
            const worldY = (canvasY - canvasState.panY) / canvasState.zoom;

            return {
                x: worldX,
                y: worldY,
                screenX: canvasX,
                screenY: canvasY
            };
        };

        const updateMovementTrails = () => {
            gameState.villageGrid.forEach(unit => {
                if (!unit.movable || (Math.abs(unit.vx) < 1 && Math.abs(unit.vy) < 1)) return;

                const trailKey = unit.id;
                if (!movementTrails[trailKey]) {
                    movementTrails[trailKey] = [];
                }

                movementTrails[trailKey].push({
                    x: unit.x,
                    y: unit.y,
                    timestamp: Date.now(),
                    alpha: 1.0
                });

                // Keep only recent trail points
                const maxAge = 1500;
                const now = Date.now();
                movementTrails[trailKey] = movementTrails[trailKey].filter(point =>
                    now - point.timestamp < maxAge
                );

                // Update alpha based on age
                movementTrails[trailKey].forEach(point => {
                    const age = now - point.timestamp;
                    point.alpha = Math.max(0, 1 - (age / maxAge));
                });
            });
        };

        const drawMovementTrails = () => {
            Object.values(movementTrails).forEach(trail => {
                if (trail.length < 2) return;

                ctx.save();
                ctx.strokeStyle = 'rgba(138, 92, 246, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();

                for (let i = 0; i < trail.length; i++) {
                    const point = trail[i];
                    ctx.globalAlpha = point.alpha * 0.5;

                    if (i === 0) {
                        ctx.moveTo(point.x, point.y);
                    } else {
                        ctx.lineTo(point.x, point.y);
                    }
                }

                ctx.stroke();
                ctx.restore();
            });
        };

        // TDD: Distinct visual designs for each unit type
        const drawMovableUnit = (unit, isHovered, isDragged) => {
            ctx.save();

            // Visual feedback for interaction states
            let scale = 1.0;
            let alpha = 1.0;
            let glowIntensity = 0.8;

            if (isDragged) {
                scale = 1.2;
                alpha = 0.9;
                glowIntensity = 1.2;
            } else if (isHovered) {
                scale = 1.1;
                glowIntensity = 1.0;
            }

            ctx.globalAlpha = alpha;
            ctx.translate(unit.x, unit.y);
            ctx.scale(scale, scale);

            // Draw unit based on type with distinct designs
            if (unit.type === 'dreamer') {
                drawDreamerUnit(unit, glowIntensity);
            } else if (unit.type === 'weaver') {
                drawWeaverUnit(unit, glowIntensity);
            } else if (unit.type === 'stellarNomads') {
                drawStellarNomadUnit(unit, glowIntensity);
            } else if (unit.type === 'voidWhisperers') {
                drawVoidWhispererUnit(unit, glowIntensity);
            } else if (unit.type === 'crystalBeings') {
                drawCrystalBeingUnit(unit, glowIntensity);
            } else if (unit.type === 'plasmaDancers') {
                drawPlasmaDancerUnit(unit, glowIntensity);
            } else if (unit.type === 'quantumSages') {
                drawQuantumSageUnit(unit, glowIntensity);
            } else if (unit.type === 'nebulaShepherds') {
                drawNebulaShepherdUnit(unit, glowIntensity);
            } else {
                // Default fallback
                drawDefaultUnit(unit, glowIntensity);
            }

            ctx.shadowBlur = 0;
            ctx.restore();
        };

        const drawDreamerUnit = (unit, glowIntensity) => {
            const pulse = 1 + Math.sin(animationTime * 2 + (unit.animationOffset || 0)) * 0.15;
            const currentSize = unit.size * pulse;
            const floatOffset = Math.sin(animationTime * 0.5 + (unit.animationOffset || 0)) * 3;

            ctx.save();
            ctx.translate(0, floatOffset);

            // Outer aura
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            ctx.shadowColor = '#A78BFA';
            ctx.shadowBlur = 30 * glowIntensity;
            ctx.beginPath();
            ctx.arc(0, 0, currentSize * 2, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(167, 139, 250, 0.15)';
            ctx.fill();
            ctx.restore();

            // Main orb with gradient
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize);
            gradient.addColorStop(0, 'rgba(196, 181, 253, 1.0)');
            gradient.addColorStop(0.6, 'rgba(139, 92, 246, 0.9)');
            gradient.addColorStop(1, 'rgba(109, 40, 217, 0.7)');

            ctx.shadowColor = '#A78BFA';
            ctx.shadowBlur = 20 * glowIntensity;
            ctx.beginPath();
            ctx.arc(0, 0, currentSize, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();

            // Inner core
            ctx.save();
            ctx.globalCompositeOperation = 'overlay';
            ctx.beginPath();
            ctx.arc(-currentSize * 0.2, -currentSize * 0.2, currentSize * 0.4, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.fill();
            ctx.restore();

            // Energy wisps
            for (let i = 0; i < 3; i++) {
                const angle = animationTime * 0.3 + (i * Math.PI * 2 / 3);
                const radius = currentSize * 1.5;
                const wispX = Math.cos(angle) * radius;
                const wispY = Math.sin(angle) * radius;

                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                ctx.strokeStyle = 'rgba(196, 181, 253, 0.6)';
                ctx.lineWidth = 2;
                ctx.shadowColor = '#A78BFA';
                ctx.shadowBlur = 10;

                ctx.beginPath();
                ctx.moveTo(0, 0);
                const cp1x = wispX * 0.3;
                const cp1y = wispY * 0.3 + Math.sin(animationTime * 2 + i) * 10;
                const cp2x = wispX * 0.7;
                const cp2y = wispY * 0.7 + Math.cos(animationTime * 2 + i) * 8;
                ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, wispX, wispY);
                ctx.stroke();
                ctx.restore();
            }

            ctx.restore();
        };

        const drawWeaverUnit = (unit, glowIntensity) => {
            const pulse = 1 + Math.sin(animationTime * 1.5 + (unit.animationOffset || 0)) * 0.1;
            const currentSize = unit.size * pulse;

            // Hexagonal crystal base
            ctx.save();
            ctx.shadowColor = '#34D399';
            ctx.shadowBlur = 20 * glowIntensity;

            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize);
            gradient.addColorStop(0, 'rgba(110, 231, 183, 1.0)');
            gradient.addColorStop(0.6, 'rgba(16, 185, 129, 0.9)');
            gradient.addColorStop(1, 'rgba(5, 150, 105, 0.7)');

            // Draw hexagon
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = (i * Math.PI * 2) / 6;
                const x = Math.cos(angle) * currentSize;
                const y = Math.sin(angle) * currentSize;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fillStyle = gradient;
            ctx.fill();

            // Hexagon outline
            ctx.strokeStyle = 'rgba(110, 231, 183, 0.8)';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.restore();

            // Energy threads
            for (let i = 0; i < 6; i++) {
                const angle1 = (i * Math.PI * 2) / 6;
                const angle2 = ((i + 2) * Math.PI * 2) / 6;
                const weaveOffset = Math.sin(animationTime * 1.0 + i) * 0.3;

                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                ctx.strokeStyle = `rgba(110, 231, 183, ${0.4 + weaveOffset})`;
                ctx.lineWidth = 1.5;
                ctx.shadowColor = '#34D399';
                ctx.shadowBlur = 8;

                const x1 = Math.cos(angle1) * currentSize * 0.8;
                const y1 = Math.sin(angle1) * currentSize * 0.8;
                const x2 = Math.cos(angle2) * currentSize * 0.8;
                const y2 = Math.sin(angle2) * currentSize * 0.8;

                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
                ctx.restore();
            }

            // Central gem
            ctx.save();
            ctx.globalCompositeOperation = 'overlay';
            ctx.beginPath();
            for (let i = 0; i < 4; i++) {
                const angle = (i * Math.PI * 2) / 4 + Math.PI / 4;
                const x = Math.cos(angle) * currentSize * 0.3;
                const y = Math.sin(angle) * currentSize * 0.3;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.fill();
            ctx.restore();
        };

        const drawStellarNomadUnit = (unit, glowIntensity) => {
            const pulse = 1 + Math.sin(animationTime * 3 + (unit.animationOffset || 0)) * 0.2;
            const currentSize = unit.size * pulse;
            const rotation = animationTime * 0.5;

            ctx.save();
            ctx.rotate(rotation);

            // Stellar corona (8-pointed star)
            ctx.save();
            ctx.shadowColor = '#FBBF24';
            ctx.shadowBlur = 25 * glowIntensity;

            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize * 1.5);
            gradient.addColorStop(0, 'rgba(252, 211, 77, 1.0)');
            gradient.addColorStop(0.6, 'rgba(245, 158, 11, 0.8)');
            gradient.addColorStop(1, 'rgba(217, 119, 6, 0.4)');

            // Draw 8-pointed star
            ctx.beginPath();
            for (let i = 0; i < 16; i++) {
                const angle = (i * Math.PI * 2) / 16;
                const radius = i % 2 === 0 ? currentSize * 1.5 : currentSize * 0.8;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.restore();

            // Plasma core
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize * 0.8);
            coreGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
            coreGradient.addColorStop(0.5, 'rgba(252, 211, 77, 0.7)');
            coreGradient.addColorStop(1, 'rgba(245, 158, 11, 0.3)');

            ctx.beginPath();
            ctx.arc(0, 0, currentSize * 0.8, 0, Math.PI * 2);
            ctx.fillStyle = coreGradient;
            ctx.fill();
            ctx.restore();

            // Solar flares
            for (let i = 0; i < 4; i++) {
                const flareAngle = (i * Math.PI * 2) / 4 + animationTime * 0.2;
                const flareIntensity = 0.5 + Math.sin(animationTime * 4 + i) * 0.3;
                const flareLength = currentSize * (1.5 + flareIntensity * 0.5);

                ctx.save();
                ctx.rotate(flareAngle);
                ctx.globalCompositeOperation = 'screen';
                ctx.strokeStyle = `rgba(252, 211, 77, ${flareIntensity})`;
                ctx.lineWidth = 3;
                ctx.shadowColor = '#FBBF24';
                ctx.shadowBlur = 15;

                // Draw flame-like wisp
                ctx.beginPath();
                ctx.moveTo(currentSize, 0);
                const cp1x = currentSize + flareLength * 0.3;
                const cp1y = Math.sin(animationTime * 3 + i) * 8;
                const cp2x = currentSize + flareLength * 0.7;
                const cp2y = Math.cos(animationTime * 2 + i) * 12;
                const endX = currentSize + flareLength;
                const endY = Math.sin(animationTime * 4 + i) * 5;

                ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, endX, endY);
                ctx.stroke();
                ctx.restore();
            }

            ctx.restore();
        };

        const drawVoidWhispererUnit = (unit, glowIntensity) => {
            const pulse = 1 + Math.sin(animationTime * 1.5 + (unit.animationOffset || 0)) * 0.15;
            const currentSize = unit.size * pulse;
            const warpIntensity = Math.sin(animationTime * 1.5) * 0.15;

            // Void distortion effect
            ctx.save();
            ctx.globalCompositeOperation = 'multiply';
            ctx.shadowColor = '#581C87';
            ctx.shadowBlur = 30 * glowIntensity;

            // Irregular distorted circle
            ctx.beginPath();
            for (let i = 0; i <= 32; i++) {
                const angle = (i * Math.PI * 2) / 32;
                const distortion = 1 + Math.sin(angle * 3 + animationTime * 2) * warpIntensity;
                const radius = currentSize * distortion;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();

            const voidGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize);
            voidGradient.addColorStop(0, 'rgba(76, 29, 149, 0.9)');
            voidGradient.addColorStop(0.6, 'rgba(88, 28, 135, 0.7)');
            voidGradient.addColorStop(1, 'rgba(107, 33, 168, 0.3)');

            ctx.fillStyle = voidGradient;
            ctx.fill();
            ctx.restore();

            // Shadow tendrils
            for (let i = 0; i < 5; i++) {
                const baseAngle = (i * Math.PI * 2) / 5;
                const writheOffset = Math.sin(animationTime * 2 + i) * 0.5;
                const tentacleLength = currentSize * (1.5 + writheOffset);

                ctx.save();
                ctx.rotate(baseAngle);
                ctx.globalCompositeOperation = 'multiply';
                ctx.strokeStyle = `rgba(76, 29, 149, ${0.6 + writheOffset * 0.3})`;
                ctx.lineWidth = 3;
                ctx.shadowColor = '#581C87';
                ctx.shadowBlur = 12;

                // Draw writhing tentacle
                ctx.beginPath();
                ctx.moveTo(currentSize * 0.8, 0);

                const segments = 6;
                for (let j = 1; j <= segments; j++) {
                    const t = j / segments;
                    const segmentX = currentSize * 0.8 + tentacleLength * t;
                    const writhe = Math.sin(t * Math.PI * 2 + animationTime * 2 + i) * 8;
                    const segmentY = writhe;

                    if (j === 1) {
                        ctx.lineTo(segmentX, segmentY);
                    } else {
                        const prevT = (j - 1) / segments;
                        const prevX = currentSize * 0.8 + tentacleLength * prevT;
                        const prevWrithe = Math.sin(prevT * Math.PI * 2 + animationTime * 2 + i) * 8;

                        const cp1x = prevX + (segmentX - prevX) * 0.5;
                        const cp1y = prevWrithe;
                        const cp2x = segmentX - (segmentX - prevX) * 0.5;
                        const cp2y = segmentY;

                        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, segmentX, segmentY);
                    }
                }
                ctx.stroke();
                ctx.restore();
            }

            // Dark absorption core
            ctx.save();
            ctx.globalCompositeOperation = 'multiply';
            ctx.beginPath();
            ctx.arc(0, 0, currentSize * 0.5, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fill();
            ctx.restore();
        };

        const drawCrystalBeingUnit = (unit, glowIntensity) => {
            const pulse = 1 + Math.sin(animationTime * 2.5 + (unit.animationOffset || 0)) * 0.12;
            const currentSize = unit.size * pulse;
            const refraction = animationTime * 3;

            // Crystal facets
            ctx.save();
            ctx.shadowColor = '#06B6D4';
            ctx.shadowBlur = 20 * glowIntensity;

            // Main crystal body (octagon)
            const facets = 8;
            for (let layer = 0; layer < 3; layer++) {
                const layerSize = currentSize * (1 - layer * 0.2);
                const layerAlpha = 0.8 - layer * 0.2;

                ctx.save();
                ctx.rotate(refraction + layer * 0.1);

                const crystalGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, layerSize);
                crystalGradient.addColorStop(0, `rgba(165, 243, 252, ${layerAlpha})`);
                crystalGradient.addColorStop(0.6, `rgba(6, 182, 212, ${layerAlpha * 0.8})`);
                crystalGradient.addColorStop(1, `rgba(8, 145, 178, ${layerAlpha * 0.6})`);

                ctx.beginPath();
                for (let i = 0; i < facets; i++) {
                    const angle = (i * Math.PI * 2) / facets;
                    const x = Math.cos(angle) * layerSize;
                    const y = Math.sin(angle) * layerSize;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fillStyle = crystalGradient;
                ctx.fill();

                // Facet edges
                ctx.strokeStyle = `rgba(165, 243, 252, ${layerAlpha * 0.6})`;
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.restore();
            }
            ctx.restore();

            // Refraction highlights
            for (let i = 0; i < 3; i++) {
                const highlightAngle = refraction + (i * Math.PI * 2) / 3;
                const highlightX = Math.cos(highlightAngle) * currentSize * 0.6;
                const highlightY = Math.sin(highlightAngle) * currentSize * 0.6;

                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                ctx.beginPath();
                ctx.arc(highlightX, highlightY, 3, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.shadowColor = '#06B6D4';
                ctx.shadowBlur = 8;
                ctx.fill();
                ctx.restore();
            }
        };

        const drawPlasmaDancerUnit = (unit, glowIntensity) => {
            const pulse = 1 + Math.sin(animationTime * 4 + (unit.animationOffset || 0)) * 0.25;
            const currentSize = unit.size * pulse;
            const flow = animationTime * 2;

            // Plasma wisps flowing around center
            for (let i = 0; i < 6; i++) {
                const wispAngle = flow + (i * Math.PI * 2) / 6;
                const wispRadius = currentSize * (1.2 + Math.sin(flow + i) * 0.3);
                const wispX = Math.cos(wispAngle) * wispRadius;
                const wispY = Math.sin(wispAngle) * wispRadius;

                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                ctx.strokeStyle = `rgba(236, 72, 153, ${0.6 + Math.sin(flow * 2 + i) * 0.3})`;
                ctx.lineWidth = 4;
                ctx.shadowColor = '#EC4899';
                ctx.shadowBlur = 15;

                // Draw flowing wisp
                ctx.beginPath();
                ctx.moveTo(0, 0);
                const cp1x = wispX * 0.3;
                const cp1y = wispY * 0.3 + Math.sin(flow * 3 + i) * 15;
                const cp2x = wispX * 0.7;
                const cp2y = wispY * 0.7 + Math.cos(flow * 2 + i) * 10;
                ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, wispX, wispY);
                ctx.stroke();
                ctx.restore();
            }

            // Central plasma core
            ctx.save();
            ctx.shadowColor = '#EC4899';
            ctx.shadowBlur = 25 * glowIntensity;

            const plasmaGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize * 0.8);
            plasmaGradient.addColorStop(0, 'rgba(251, 207, 232, 1.0)');
            plasmaGradient.addColorStop(0.5, 'rgba(236, 72, 153, 0.8)');
            plasmaGradient.addColorStop(1, 'rgba(190, 24, 93, 0.4)');

            // Irregular plasma shape
            ctx.beginPath();
            for (let i = 0; i <= 16; i++) {
                const angle = (i * Math.PI * 2) / 16;
                const variation = 1 + Math.sin(angle * 4 + flow) * 0.2;
                const radius = currentSize * 0.8 * variation;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fillStyle = plasmaGradient;
            ctx.fill();
            ctx.restore();
        };

        const drawQuantumSageUnit = (unit, glowIntensity) => {
            const pulse = 1 + Math.sin(animationTime * 1.8 + (unit.animationOffset || 0)) * 0.12;
            const currentSize = unit.size * pulse;
            const quantumPhase = animationTime * 0.8;

            // Quantum probability clouds - multiple overlapping forms
            for (let i = 0; i < 3; i++) {
                const phaseOffset = (i * Math.PI * 2) / 3;
                const probability = 0.3 + Math.sin(quantumPhase + phaseOffset) * 0.2;

                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                ctx.globalAlpha = probability;
                ctx.shadowColor = '#8B5CF6';
                ctx.shadowBlur = 25 * glowIntensity;

                // Quantum state visualization - shifting geometric forms
                const sides = 6 + Math.floor(Math.sin(quantumPhase + phaseOffset) * 2);
                const stateSize = currentSize * (0.8 + Math.sin(quantumPhase * 2 + phaseOffset) * 0.3);

                ctx.beginPath();
                for (let j = 0; j < sides; j++) {
                    const angle = (j * Math.PI * 2) / sides + quantumPhase;
                    const radius = stateSize * (1 + Math.sin(angle * 3 + quantumPhase) * 0.1);
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * radius;
                    if (j === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();

                const quantumGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, stateSize);
                quantumGradient.addColorStop(0, 'rgba(139, 92, 246, 0.8)');
                quantumGradient.addColorStop(0.5, 'rgba(168, 85, 247, 0.6)');
                quantumGradient.addColorStop(1, 'rgba(196, 181, 253, 0.2)');

                ctx.fillStyle = quantumGradient;
                ctx.fill();
                ctx.restore();
            }

            // Quantum entanglement lines - connecting to other dimensions
            ctx.save();
            ctx.strokeStyle = 'rgba(139, 92, 246, 0.6)';
            ctx.lineWidth = 2;
            ctx.shadowColor = '#8B5CF6';
            ctx.shadowBlur = 10;

            for (let i = 0; i < 4; i++) {
                const entangleAngle = quantumPhase * 2 + (i * Math.PI * 2) / 4;
                const entangleRadius = currentSize * (1.5 + Math.sin(quantumPhase + i) * 0.5);
                const entangleX = Math.cos(entangleAngle) * entangleRadius;
                const entangleY = Math.sin(entangleAngle) * entangleRadius;

                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(entangleX, entangleY);
                ctx.stroke();

                // Quantum nodes at line ends
                ctx.beginPath();
                ctx.arc(entangleX, entangleY, 3, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(139, 92, 246, 0.8)';
                ctx.fill();
            }
            ctx.restore();

            // Central consciousness core
            ctx.save();
            ctx.shadowColor = '#8B5CF6';
            ctx.shadowBlur = 20 * glowIntensity;

            const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize * 0.4);
            coreGradient.addColorStop(0, 'rgba(255, 255, 255, 1.0)');
            coreGradient.addColorStop(0.3, 'rgba(139, 92, 246, 0.9)');
            coreGradient.addColorStop(1, 'rgba(139, 92, 246, 0.4)');

            ctx.beginPath();
            ctx.arc(0, 0, currentSize * 0.4, 0, Math.PI * 2);
            ctx.fillStyle = coreGradient;
            ctx.fill();
            ctx.restore();
        };

        const drawNebulaShepherdUnit = (unit, glowIntensity) => {
            const pulse = 1 + Math.sin(animationTime * 0.8 + (unit.animationOffset || 0)) * 0.08;
            const currentSize = unit.size * pulse;
            const nebulaFlow = animationTime * 0.3;

            // Cosmic dust and gas clouds
            ctx.save();
            ctx.globalCompositeOperation = 'screen';

            // Multiple nebula layers with different colors and densities
            const nebulaLayers = [
                { color: [255, 182, 193], density: 0.3, size: 2.5, speed: 1 },    // Pink
                { color: [135, 206, 250], density: 0.25, size: 2.2, speed: 0.8 }, // Light blue
                { color: [221, 160, 221], density: 0.2, size: 2.0, speed: 0.6 },  // Plum
                { color: [255, 215, 0], density: 0.15, size: 1.8, speed: 0.4 }    // Gold
            ];

            nebulaLayers.forEach((layer, index) => {
                const layerPhase = nebulaFlow * layer.speed + (index * Math.PI / 2);

                for (let i = 0; i < 8; i++) {
                    const cloudAngle = (i * Math.PI * 2) / 8 + layerPhase;
                    const cloudDistance = currentSize * (layer.size + Math.sin(layerPhase + i) * 0.3);
                    const cloudX = Math.cos(cloudAngle) * cloudDistance;
                    const cloudY = Math.sin(cloudAngle) * cloudDistance;
                    const cloudSize = currentSize * (0.4 + Math.sin(layerPhase * 2 + i) * 0.2);

                    const cloudGradient = ctx.createRadialGradient(
                        cloudX, cloudY, 0,
                        cloudX, cloudY, cloudSize
                    );
                    cloudGradient.addColorStop(0, `rgba(${layer.color[0]}, ${layer.color[1]}, ${layer.color[2]}, ${layer.density})`);
                    cloudGradient.addColorStop(0.6, `rgba(${layer.color[0]}, ${layer.color[1]}, ${layer.color[2]}, ${layer.density * 0.5})`);
                    cloudGradient.addColorStop(1, `rgba(${layer.color[0]}, ${layer.color[1]}, ${layer.color[2]}, 0)`);

                    ctx.beginPath();
                    ctx.arc(cloudX, cloudY, cloudSize, 0, Math.PI * 2);
                    ctx.fillStyle = cloudGradient;
                    ctx.fill();
                }
            });
            ctx.restore();

            // Star birth points - bright stellar nurseries
            ctx.save();
            ctx.shadowColor = '#FFD700';
            ctx.shadowBlur = 15 * glowIntensity;

            for (let i = 0; i < 5; i++) {
                const starAngle = nebulaFlow * 2 + (i * Math.PI * 2) / 5;
                const starDistance = currentSize * (1.2 + Math.sin(nebulaFlow + i) * 0.4);
                const starX = Math.cos(starAngle) * starDistance;
                const starY = Math.sin(starAngle) * starDistance;
                const starBrightness = 0.6 + Math.sin(nebulaFlow * 3 + i) * 0.4;

                ctx.beginPath();
                ctx.arc(starX, starY, 4, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 215, 0, ${starBrightness})`;
                ctx.fill();

                // Star formation rays
                ctx.save();
                ctx.translate(starX, starY);
                ctx.strokeStyle = `rgba(255, 215, 0, ${starBrightness * 0.5})`;
                ctx.lineWidth = 1;

                for (let j = 0; j < 4; j++) {
                    const rayAngle = (j * Math.PI * 2) / 4;
                    const rayLength = 12 + Math.sin(nebulaFlow * 4 + i + j) * 6;

                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(Math.cos(rayAngle) * rayLength, Math.sin(rayAngle) * rayLength);
                    ctx.stroke();
                }
                ctx.restore();
            }
            ctx.restore();

            // Central ancient consciousness
            ctx.save();
            ctx.shadowColor = '#DDA0DD';
            ctx.shadowBlur = 25 * glowIntensity;

            const shepherdGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize * 0.6);
            shepherdGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
            shepherdGradient.addColorStop(0.3, 'rgba(221, 160, 221, 0.8)');
            shepherdGradient.addColorStop(0.7, 'rgba(147, 112, 219, 0.6)');
            shepherdGradient.addColorStop(1, 'rgba(75, 0, 130, 0.3)');

            ctx.beginPath();
            ctx.arc(0, 0, currentSize * 0.6, 0, Math.PI * 2);
            ctx.fillStyle = shepherdGradient;
            ctx.fill();

            // Ancient wisdom symbols
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.lineWidth = 2;
            ctx.font = `${currentSize * 0.4}px serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.fillText('‚ú¶', 0, 0);

            ctx.restore();
        };

        const drawDefaultUnit = (unit, glowIntensity) => {
            // Fallback design for unknown unit types
            const pulse = 1 + Math.sin(animationTime * 2 + (unit.animationOffset || 0)) * 0.15;
            const currentSize = unit.size * pulse;

            ctx.save();
            ctx.shadowColor = '#6B7280';
            ctx.shadowBlur = 15 * glowIntensity;

            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize);
            gradient.addColorStop(0, 'rgba(156, 163, 175, 1.0)');
            gradient.addColorStop(0.6, 'rgba(107, 114, 128, 0.9)');
            gradient.addColorStop(1, 'rgba(75, 85, 99, 0.7)');

            ctx.beginPath();
            ctx.arc(0, 0, currentSize, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.restore();
        };

        // --- TDD: Intelligent Creatures System ---

        let creatureIdCounter = 0;

        const createIntelligentCreature = (type, x, y) => {
            const creature = {
                id: `creature_${creatureIdCounter++}`,
                type: type,
                x: x,
                y: y,
                size: 30,
                intelligence: 100,
                memory: [],
                goals: [],
                currentGoal: null,
                personality: {
                    curiosity: Math.random(),
                    sociability: Math.random(),
                    productivity: Math.random(),
                    exploration: Math.random()
                },
                state: 'idle',
                energy: 100,
                lastDecision: 0,
                decisionCooldown: 3000, // 3 seconds between decisions
                perceptionRadius: 120,
                movementSpeed: 25,
                targetX: x,
                targetY: y,
                vx: 0,
                vy: 0,
                animationOffset: Math.random() * Math.PI * 2,
                relationships: new Map(),
                draggable: true, // TDD: Enable drag-and-drop
                isDragging: false
            };

            // Initialize based on creature type
            if (type === 'cosmicSage') {
                creature.specialAbilities = ['insight_generation', 'knowledge_sharing', 'meditation'];
                creature.preferredActivities = ['study', 'teach', 'contemplate'];
                creature.color = '#9333EA';
                creature.glowColor = '#A855F7';
            } else if (type === 'voidExplorer') {
                creature.specialAbilities = ['void_navigation', 'resource_discovery', 'pathfinding'];
                creature.preferredActivities = ['explore', 'scout', 'gather'];
                creature.color = '#1F2937';
                creature.glowColor = '#4B5563';
            } else if (type === 'harmonyKeeper') {
                creature.specialAbilities = ['harmony_restoration', 'conflict_resolution', 'healing'];
                creature.preferredActivities = ['mediate', 'heal', 'organize'];
                creature.color = '#059669';
                creature.glowColor = '#10B981';
            }

            return creature;
        };

        const spawnIntelligentCreature = (type) => {
            const x = Math.random() * (canvas.width - 200) + 100;
            const y = Math.random() * (canvas.height - 200) + 100;
            const creature = createIntelligentCreature(type, x, y);
            gameState.intelligentCreatures.push(creature);
            log(`A ${type} has awakened in the sanctuary!`, 'success');
            return creature;
        };

        const perceiveEnvironment = (creature) => {
            const perception = {
                nearbyUnits: [],
                nearbyResources: [],
                nearbyCreatures: [],
                threats: [],
                opportunities: [],
                environmentalFactors: {}
            };

            // Find nearby entities within perception radius
            gameState.villageGrid.forEach(entity => {
                const distance = Math.sqrt(
                    Math.pow(entity.x - creature.x, 2) +
                    Math.pow(entity.y - creature.y, 2)
                );

                if (distance <= creature.perceptionRadius) {
                    if (entity.movable) {
                        perception.nearbyUnits.push({
                            entity: entity,
                            distance: distance,
                            relationship: 'neutral'
                        });
                    } else {
                        perception.nearbyResources.push({
                            entity: entity,
                            distance: distance,
                            type: entity.type
                        });
                    }
                }
            });

            // Find other intelligent creatures
            gameState.intelligentCreatures.forEach(otherCreature => {
                if (otherCreature.id !== creature.id) {
                    const distance = Math.sqrt(
                        Math.pow(otherCreature.x - creature.x, 2) +
                        Math.pow(otherCreature.y - creature.y, 2)
                    );

                    if (distance <= creature.perceptionRadius) {
                        perception.nearbyCreatures.push({
                            creature: otherCreature,
                            distance: distance,
                            relationship: creature.relationships.get(otherCreature.id) || 'neutral'
                        });
                    }
                }
            });

            // Analyze environmental factors
            perception.environmentalFactors = {
                crowding: perception.nearbyUnits.length + perception.nearbyCreatures.length,
                resourceAvailability: perception.nearbyResources.length,
                harmonyLevel: gameState.harmony || 50,
                energyLevel: gameState.energy || 0,
                insightLevel: gameState.insight || 0
            };

            return perception;
        };

        const makeDecision = (creature, perception, currentTime) => {
            // Don't make decisions too frequently
            if (currentTime - creature.lastDecision < creature.decisionCooldown) {
                return creature.currentGoal;
            }

            const possibleGoals = [];

            // Generate goals based on creature type and personality
            if (creature.type === 'cosmicSage') {
                if (perception.nearbyUnits.length > 0 && creature.personality.sociability > 0.5) {
                    possibleGoals.push({
                        type: 'teach',
                        priority: creature.personality.sociability * 10,
                        target: perception.nearbyUnits[0].entity,
                        duration: 8000
                    });
                }

                if (perception.environmentalFactors.harmonyLevel < 70) {
                    possibleGoals.push({
                        type: 'meditate',
                        priority: (100 - perception.environmentalFactors.harmonyLevel) / 8,
                        target: null,
                        duration: 10000
                    });
                }

                if (perception.nearbyCreatures.length > 0 && creature.personality.sociability > 0.6) {
                    possibleGoals.push({
                        type: 'communicate',
                        priority: creature.personality.sociability * 8,
                        target: perception.nearbyCreatures[0].creature,
                        duration: 5000
                    });
                }
            }

            if (creature.type === 'voidExplorer') {
                if (creature.personality.exploration > 0.5) {
                    possibleGoals.push({
                        type: 'explore',
                        priority: creature.personality.exploration * 9,
                        target: {
                            x: Math.random() * (canvas.width - 100) + 50,
                            y: Math.random() * (canvas.height - 100) + 50
                        },
                        duration: 12000
                    });
                }

                if (perception.nearbyResources.length > 0) {
                    possibleGoals.push({
                        type: 'investigate',
                        priority: creature.personality.curiosity * 8,
                        target: perception.nearbyResources[0].entity,
                        duration: 6000
                    });
                }
            }

            if (creature.type === 'harmonyKeeper') {
                if (perception.environmentalFactors.harmonyLevel < 80) {
                    possibleGoals.push({
                        type: 'restore_harmony',
                        priority: (100 - perception.environmentalFactors.harmonyLevel) / 6,
                        target: null,
                        duration: 8000
                    });
                }

                if (perception.nearbyUnits.length > 2) {
                    possibleGoals.push({
                        type: 'organize',
                        priority: perception.nearbyUnits.length * 2,
                        target: perception.nearbyUnits,
                        duration: 10000
                    });
                }
            }

            // Add idle goal as fallback
            possibleGoals.push({
                type: 'idle',
                priority: 1,
                target: null,
                duration: 5000
            });

            // Select highest priority goal
            possibleGoals.sort((a, b) => b.priority - a.priority);
            creature.currentGoal = possibleGoals[0];
            creature.lastDecision = currentTime;
            creature.state = creature.currentGoal.type;

            return creature.currentGoal;
        };

        const updateMemory = (creature, event) => {
            const memoryEntry = {
                timestamp: Date.now(),
                type: event.type,
                location: { x: creature.x, y: creature.y },
                data: event.data,
                importance: event.importance || 1
            };

            creature.memory.push(memoryEntry);

            // Keep memory size manageable
            const maxMemorySize = 30;
            if (creature.memory.length > maxMemorySize) {
                // Remove least important old memories
                creature.memory.sort((a, b) => {
                    const ageA = Date.now() - a.timestamp;
                    const ageB = Date.now() - b.timestamp;
                    const scoreA = a.importance - (ageA / 20000);
                    const scoreB = b.importance - (ageB / 20000);
                    return scoreB - scoreA;
                });
                creature.memory = creature.memory.slice(0, maxMemorySize);
            }
        };

        const executeBehavior = (creature, goal, deltaTime) => {
            if (!goal) return;

            switch (goal.type) {
                case 'teach':
                    if (goal.target && goal.target.movable) {
                        const distance = Math.sqrt(
                            Math.pow(goal.target.x - creature.x, 2) +
                            Math.pow(goal.target.y - creature.y, 2)
                        );

                        if (distance > 60) {
                            // Move closer to target
                            creature.targetX = goal.target.x;
                            creature.targetY = goal.target.y;
                        } else {
                            // Teaching effect
                            if (!goal.target.teachingBoost || Date.now() - goal.target.teachingBoost.timestamp > 30000) {
                                goal.target.teachingBoost = {
                                    multiplier: 1.3,
                                    duration: 30000,
                                    timestamp: Date.now()
                                };

                                updateMemory(creature, {
                                    type: 'teaching_completed',
                                    data: { targetId: goal.target.id },
                                    importance: 3
                                });

                                creature.intelligence = Math.min(200, creature.intelligence + 1);
                            }
                        }
                    }
                    break;

                case 'meditate':
                    // Stay still and generate harmony
                    creature.targetX = creature.x;
                    creature.targetY = creature.y;

                    if (Math.random() < 0.02) { // 2% chance per frame
                        gameState.harmony = Math.min(100, gameState.harmony + 0.5);
                        gameState.insight = Math.min(gameState.insight + 0.2, gameState.insight + 0.2);
                    }
                    break;

                case 'explore':
                    if (goal.target) {
                        creature.targetX = goal.target.x;
                        creature.targetY = goal.target.y;

                        const distance = Math.sqrt(
                            Math.pow(goal.target.x - creature.x, 2) +
                            Math.pow(goal.target.y - creature.y, 2)
                        );

                        if (distance < 20) {
                            // Reached exploration target
                            updateMemory(creature, {
                                type: 'area_explored',
                                data: { location: { x: creature.x, y: creature.y } },
                                importance: 2
                            });

                            // Small chance to discover resources
                            if (Math.random() < 0.1) {
                                gameState.energy += 5;
                                log(`${creature.type} discovered energy while exploring!`, 'info');
                            }
                        }
                    }
                    break;

                case 'investigate':
                    if (goal.target) {
                        const distance = Math.sqrt(
                            Math.pow(goal.target.x - creature.x, 2) +
                            Math.pow(goal.target.y - creature.y, 2)
                        );

                        if (distance > 40) {
                            creature.targetX = goal.target.x;
                            creature.targetY = goal.target.y;
                        } else {
                            // Investigation complete
                            updateMemory(creature, {
                                type: 'resource_investigated',
                                data: { resourceType: goal.target.type, location: { x: goal.target.x, y: goal.target.y } },
                                importance: 4
                            });
                        }
                    }
                    break;

                case 'restore_harmony':
                    // Harmony restoration effect
                    if (Math.random() < 0.03) { // 3% chance per frame
                        gameState.harmony = Math.min(100, gameState.harmony + 1);

                        // Boost nearby units
                        gameState.villageGrid.forEach(entity => {
                            if (entity.movable) {
                                const distance = Math.sqrt(
                                    Math.pow(entity.x - creature.x, 2) +
                                    Math.pow(entity.y - creature.y, 2)
                                );

                                if (distance <= 80) {
                                    entity.harmonyBoost = {
                                        multiplier: 1.15,
                                        duration: 20000,
                                        timestamp: Date.now()
                                    };
                                }
                            }
                        });
                    }
                    break;

                case 'communicate':
                    if (goal.target) {
                        const distance = Math.sqrt(
                            Math.pow(goal.target.x - creature.x, 2) +
                            Math.pow(goal.target.y - creature.y, 2)
                        );

                        if (distance <= 70) {
                            // Share knowledge
                            const recentMemories = creature.memory.slice(-2);
                            recentMemories.forEach(memory => {
                                if (!goal.target.memory.some(m =>
                                    m.type === memory.type &&
                                    Math.abs(m.timestamp - memory.timestamp) < 2000
                                )) {
                                    goal.target.memory.push({
                                        ...memory,
                                        source: creature.id,
                                        shared: true
                                    });
                                }
                            });

                            // Improve relationship
                            creature.relationships.set(goal.target.id, 'friendly');
                            goal.target.relationships.set(creature.id, 'friendly');

                            // Both gain intelligence
                            creature.intelligence = Math.min(200, creature.intelligence + 0.5);
                            goal.target.intelligence = Math.min(200, goal.target.intelligence + 0.5);
                        }
                    }
                    break;

                case 'idle':
                default:
                    // Gentle wandering
                    const wanderRadius = 40;
                    creature.targetX = creature.x + (Math.random() - 0.5) * wanderRadius;
                    creature.targetY = creature.y + (Math.random() - 0.5) * wanderRadius;

                    // Keep within bounds
                    creature.targetX = Math.max(50, Math.min(canvas.width - 50, creature.targetX));
                    creature.targetY = Math.max(50, Math.min(canvas.height - 50, creature.targetY));
                    break;
            }
        };

        const updateIntelligentCreatures = (deltaTime) => {
            const currentTime = Date.now();

            gameState.intelligentCreatures.forEach(creature => {
                // Perception and decision making
                const perception = perceiveEnvironment(creature);
                const goal = makeDecision(creature, perception, currentTime);

                // Execute current behavior
                executeBehavior(creature, goal, deltaTime);

                // Update movement
                const dx = creature.targetX - creature.x;
                const dy = creature.targetY - creature.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 2) {
                    const speed = creature.movementSpeed;
                    const moveDistance = speed * deltaTime;
                    const ratio = Math.min(moveDistance / distance, 1);

                    creature.x += dx * ratio;
                    creature.y += dy * ratio;
                    creature.vx = dx * ratio / deltaTime;
                    creature.vy = dy * ratio / deltaTime;
                } else {
                    creature.vx = 0;
                    creature.vy = 0;
                }

                // Update goal duration
                if (goal && goal.startTime) {
                    if (currentTime - goal.startTime > goal.duration) {
                        creature.currentGoal = null;
                        creature.state = 'idle';
                    }
                } else if (goal) {
                    goal.startTime = currentTime;
                }
            });
        };

        const drawIntelligentCreatures = () => {
            gameState.intelligentCreatures.forEach(creature => {
                drawIntelligentCreature(creature);
            });
        };

        const drawIntelligentCreature = (creature) => {
            ctx.save();
            ctx.translate(creature.x, creature.y);

            const pulse = 1 + Math.sin(animationTime * 1.5 + creature.animationOffset) * 0.1;
            const currentSize = creature.size * pulse;

            // Intelligence aura - larger and more complex than regular units
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            ctx.shadowColor = creature.glowColor;
            ctx.shadowBlur = 35;

            const auraGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize * 2.5);
            const r = parseInt(creature.glowColor.slice(1,3), 16);
            const g = parseInt(creature.glowColor.slice(3,5), 16);
            const b = parseInt(creature.glowColor.slice(5,7), 16);

            auraGradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.3)`);
            auraGradient.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, 0.15)`);
            auraGradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);

            ctx.beginPath();
            ctx.arc(0, 0, currentSize * 2.5, 0, Math.PI * 2);
            ctx.fillStyle = auraGradient;
            ctx.fill();
            ctx.restore();

            // Main creature body - distinctive shape based on type
            if (creature.type === 'cosmicSage') {
                drawCosmicSage(creature, currentSize);
            } else if (creature.type === 'voidExplorer') {
                drawVoidExplorer(creature, currentSize);
            } else if (creature.type === 'harmonyKeeper') {
                drawHarmonyKeeper(creature, currentSize);
            }

            // Intelligence indicator - neural network pattern
            if (creature.intelligence > 100) {
                drawIntelligenceIndicator(creature, currentSize);
            }

            // State indicator
            drawStateIndicator(creature, currentSize);

            ctx.restore();
        };

        const drawCosmicSage = (creature, size) => {
            // Multi-layered mandala design
            ctx.save();
            ctx.shadowColor = creature.glowColor;
            ctx.shadowBlur = 25;

            // Outer ring with rotating symbols
            const rotation = animationTime * 0.3;
            for (let i = 0; i < 8; i++) {
                const angle = (i * Math.PI * 2 / 8) + rotation;
                const symbolX = Math.cos(angle) * size * 1.5;
                const symbolY = Math.sin(angle) * size * 1.5;

                ctx.save();
                ctx.translate(symbolX, symbolY);
                ctx.rotate(angle + Math.PI / 2);
                ctx.fillStyle = creature.glowColor;
                ctx.font = '12px serif';
                ctx.textAlign = 'center';
                ctx.fillText('‚óä', 0, 4);
                ctx.restore();
            }

            // Main body - complex geometric pattern
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
            const r = parseInt(creature.color.slice(1,3), 16);
            const g = parseInt(creature.color.slice(3,5), 16);
            const b = parseInt(creature.color.slice(5,7), 16);

            gradient.addColorStop(0, `rgba(${Math.min(255, r + 50)}, ${Math.min(255, g + 50)}, ${Math.min(255, b + 50)}, 1.0)`);
            gradient.addColorStop(0.6, `rgba(${r}, ${g}, ${b}, 0.9)`);
            gradient.addColorStop(1, `rgba(${Math.max(0, r - 30)}, ${Math.max(0, g - 30)}, ${Math.max(0, b - 30)}, 0.7)`);

            // Draw complex star pattern
            ctx.beginPath();
            for (let i = 0; i < 12; i++) {
                const angle = (i * Math.PI * 2) / 12;
                const radius = i % 2 === 0 ? size : size * 0.6;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fillStyle = gradient;
            ctx.fill();

            // Inner wisdom eye
            ctx.beginPath();
            ctx.arc(0, 0, size * 0.3, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.fill();

            ctx.beginPath();
            ctx.arc(0, 0, size * 0.15, 0, Math.PI * 2);
            ctx.fillStyle = creature.color;
            ctx.fill();

            ctx.restore();
        };

        const drawVoidExplorer = (creature, size) => {
            // Shifting, ethereal form
            ctx.save();
            ctx.shadowColor = creature.glowColor;
            ctx.shadowBlur = 20;

            const shift = Math.sin(animationTime * 2) * 0.2;

            // Main body - irregular, shifting shape
            ctx.beginPath();
            for (let i = 0; i <= 16; i++) {
                const angle = (i * Math.PI * 2) / 16;
                const variation = 1 + Math.sin(angle * 3 + animationTime * 1.5) * shift;
                const radius = size * variation;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();

            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
            const r = parseInt(creature.color.slice(1,3), 16);
            const g = parseInt(creature.color.slice(3,5), 16);
            const b = parseInt(creature.color.slice(5,7), 16);

            gradient.addColorStop(0, `rgba(${r + 40}, ${g + 40}, ${b + 40}, 0.8)`);
            gradient.addColorStop(0.7, `rgba(${r}, ${g}, ${b}, 0.6)`);
            gradient.addColorStop(1, `rgba(${r - 20}, ${g - 20}, ${b - 20}, 0.3)`);

            ctx.fillStyle = gradient;
            ctx.fill();

            // Void tendrils
            for (let i = 0; i < 4; i++) {
                const tendrilAngle = (i * Math.PI * 2 / 4) + animationTime * 0.5;
                const tendrilLength = size * (1.2 + Math.sin(animationTime * 2 + i) * 0.3);

                ctx.save();
                ctx.rotate(tendrilAngle);
                ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.6)`;
                ctx.lineWidth = 3;
                ctx.shadowBlur = 10;

                ctx.beginPath();
                ctx.moveTo(size * 0.7, 0);

                const segments = 5;
                for (let j = 1; j <= segments; j++) {
                    const t = j / segments;
                    const segmentX = size * 0.7 + tendrilLength * t;
                    const wave = Math.sin(t * Math.PI * 2 + animationTime * 3 + i) * 8;
                    const segmentY = wave;

                    if (j === 1) {
                        ctx.lineTo(segmentX, segmentY);
                    } else {
                        const prevT = (j - 1) / segments;
                        const prevX = size * 0.7 + tendrilLength * prevT;
                        const prevWave = Math.sin(prevT * Math.PI * 2 + animationTime * 3 + i) * 8;

                        const cp1x = prevX + (segmentX - prevX) * 0.5;
                        const cp1y = prevWave;
                        const cp2x = segmentX - (segmentX - prevX) * 0.5;
                        const cp2y = segmentY;

                        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, segmentX, segmentY);
                    }
                }
                ctx.stroke();
                ctx.restore();
            }

            ctx.restore();
        };

        const drawHarmonyKeeper = (creature, size) => {
            // Flowing, organic form with healing energy
            ctx.save();
            ctx.shadowColor = creature.glowColor;
            ctx.shadowBlur = 30;

            // Main body - organic, flowing shape
            const flow = animationTime * 1.2;
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
            const r = parseInt(creature.color.slice(1,3), 16);
            const g = parseInt(creature.color.slice(3,5), 16);
            const b = parseInt(creature.color.slice(5,7), 16);

            gradient.addColorStop(0, `rgba(${Math.min(255, r + 60)}, ${Math.min(255, g + 60)}, ${Math.min(255, b + 60)}, 1.0)`);
            gradient.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, 0.9)`);
            gradient.addColorStop(1, `rgba(${Math.max(0, r - 20)}, ${Math.max(0, g - 20)}, ${Math.max(0, b - 20)}, 0.6)`);

            // Draw flowing petals
            for (let i = 0; i < 6; i++) {
                const petalAngle = (i * Math.PI * 2 / 6) + flow * 0.2;
                const petalSize = size * (0.8 + Math.sin(flow + i) * 0.2);

                ctx.save();
                ctx.rotate(petalAngle);
                ctx.beginPath();
                ctx.ellipse(petalSize * 0.5, 0, petalSize * 0.6, petalSize * 0.3, 0, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
                ctx.restore();
            }

            // Central harmony core
            ctx.beginPath();
            ctx.arc(0, 0, size * 0.4, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(${Math.min(255, r + 80)}, ${Math.min(255, g + 80)}, ${Math.min(255, b + 80)}, 0.9)`;
            ctx.fill();

            // Healing energy waves
            for (let i = 0; i < 3; i++) {
                const waveRadius = size * (1.5 + i * 0.5) + Math.sin(flow * 2 - i) * 10;
                const waveAlpha = 0.3 - i * 0.1;

                ctx.beginPath();
                ctx.arc(0, 0, waveRadius, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${waveAlpha})`;
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            ctx.restore();
        };

        const drawIntelligenceIndicator = (creature, size) => {
            // Neural network pattern for high intelligence
            if (creature.intelligence <= 100) return;

            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            ctx.strokeStyle = `rgba(255, 255, 255, 0.4)`;
            ctx.lineWidth = 1;

            const nodes = 6;
            const nodePositions = [];

            // Create node positions
            for (let i = 0; i < nodes; i++) {
                const angle = (i * Math.PI * 2) / nodes;
                const radius = size * 0.8;
                nodePositions.push({
                    x: Math.cos(angle) * radius,
                    y: Math.sin(angle) * radius
                });
            }

            // Draw connections
            for (let i = 0; i < nodes; i++) {
                for (let j = i + 1; j < nodes; j++) {
                    if (Math.random() < 0.6) { // 60% chance of connection
                        ctx.beginPath();
                        ctx.moveTo(nodePositions[i].x, nodePositions[i].y);
                        ctx.lineTo(nodePositions[j].x, nodePositions[j].y);
                        ctx.stroke();
                    }
                }
            }

            // Draw nodes
            nodePositions.forEach(pos => {
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 2, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.fill();
            });

            ctx.restore();
        };

        const drawStateIndicator = (creature, size) => {
            // Small indicator showing current state
            ctx.save();
            ctx.translate(0, -size * 1.3);

            let stateColor = '#FFFFFF';
            let stateSymbol = '‚óè';

            switch (creature.state) {
                case 'teach':
                    stateColor = '#F59E0B';
                    stateSymbol = 'üìö';
                    break;
                case 'meditate':
                    stateColor = '#8B5CF6';
                    stateSymbol = 'üßò';
                    break;
                case 'explore':
                    stateColor = '#10B981';
                    stateSymbol = 'üîç';
                    break;
                case 'investigate':
                    stateColor = '#06B6D4';
                    stateSymbol = 'üî¨';
                    break;
                case 'restore_harmony':
                    stateColor = '#059669';
                    stateSymbol = '‚ú®';
                    break;
                case 'communicate':
                    stateColor = '#EC4899';
                    stateSymbol = 'üí¨';
                    break;
            }

            if (creature.state !== 'idle') {
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillStyle = stateColor;
                ctx.shadowColor = stateColor;
                ctx.shadowBlur = 5;
                ctx.fillText(stateSymbol, 0, 5);
            }

            ctx.restore();
        };

        // --- TDD: Conversational AI Units System ---

        let conversationalUnitIdCounter = 0;

        const createConversationalUnit = (type, x, y) => {
            const unit = {
                id: `conv_${conversationalUnitIdCounter++}`,
                type: type,
                x: x,
                y: y,
                size: 25,
                conversational: true,
                personality: {
                    traits: [],
                    mood: 'neutral',
                    creativity: 0.3 + Math.random() * 0.7,
                    empathy: 0.3 + Math.random() * 0.7,
                    curiosity: 0.3 + Math.random() * 0.7,
                    wisdom: 0.3 + Math.random() * 0.7
                },
                dialogue: {
                    currentTopic: null,
                    conversationHistory: [],
                    lastSpoke: 0,
                    speakingCooldown: 8000,
                    preferredTopics: [],
                    memories: [],
                    relationships: new Map(),
                    currentThought: null,
                    thoughtBubbleVisible: false
                },
                needs: {
                    current: [],
                    fulfilled: [],
                    priority: 'low'
                },
                creativity: {
                    ideas: [],
                    projects: [],
                    inspirationLevel: 30 + Math.random() * 40
                },
                specialOffers: [],
                state: 'idle',
                playerRelationship: 0.1,
                animationOffset: Math.random() * Math.PI * 2,
                thoughtTimer: 0,
                nextThoughtTime: 5000 + Math.random() * 10000,
                draggable: true, // TDD: Enable drag-and-drop
                isDragging: false
            };

            // Initialize based on unit type
            if (type === 'philosopherDreamer') {
                unit.personality.traits = ['contemplative', 'wise', 'patient', 'deep-thinking'];
                unit.dialogue.preferredTopics = ['existence', 'dreams', 'cosmic_mysteries', 'consciousness'];
                unit.specialOffers = ['dream_interpretation', 'philosophical_guidance', 'meditation_session'];
                unit.color = '#6366F1';
                unit.glowColor = '#8B5CF6';
            } else if (type === 'artisticWeaver') {
                unit.personality.traits = ['creative', 'expressive', 'passionate', 'imaginative'];
                unit.dialogue.preferredTopics = ['art', 'beauty', 'creation', 'inspiration'];
                unit.specialOffers = ['custom_artwork', 'creative_collaboration', 'aesthetic_enhancement'];
                unit.color = '#EC4899';
                unit.glowColor = '#F472B6';
            } else if (type === 'curiousExplorer') {
                unit.personality.traits = ['inquisitive', 'adventurous', 'energetic', 'observant'];
                unit.dialogue.preferredTopics = ['discoveries', 'mysteries', 'exploration', 'unknown'];
                unit.specialOffers = ['guided_exploration', 'mystery_solving', 'treasure_hunting'];
                unit.color = '#10B981';
                unit.glowColor = '#34D399';
            }

            return unit;
        };

        const spawnConversationalUnit = (type) => {
            const size = 20; // Typical conversational unit size
            const margin = size + 15; // Extra margin for safety
            const x = Math.random() * (canvas.width - 2 * margin) + margin;
            const y = Math.random() * (canvas.height - 2 * margin) + margin;
            const unit = createConversationalUnit(type, x, y);
            gameState.conversationalUnits.push(unit);
            log(`A ${type} awakens and begins to contemplate the sanctuary...`, 'success');
            return unit;
        };

        const generateThought = (unit) => {
            const thoughts = {
                philosopherDreamer: [
                    "What dreams shape reality in this cosmic sanctuary?",
                    "I sense the interconnectedness of all beings here...",
                    "The harmony flows like a river of consciousness.",
                    "Perhaps existence itself is but a shared dream?",
                    "I wonder what wisdom the stars whisper tonight..."
                ],
                artisticWeaver: [
                    "The colors of energy here inspire new creations!",
                    "I could weave beauty from these cosmic threads...",
                    "Art is the language the universe speaks to itself.",
                    "What masterpiece shall we create together?",
                    "Beauty exists in every particle of this sanctuary."
                ],
                curiousExplorer: [
                    "What mysteries lie hidden in the sanctuary's depths?",
                    "I sense something fascinating just beyond perception...",
                    "Every corner holds a new discovery waiting!",
                    "The unknown calls to me with irresistible allure.",
                    "Adventure and wonder await those who seek!"
                ]
            };

            const typeThoughts = thoughts[unit.type] || ["I contemplate the mysteries of existence..."];
            return typeThoughts[Math.floor(Math.random() * typeThoughts.length)];
        };

        const updateConversationalUnits = (deltaTime) => {
            const currentTime = Date.now();

            gameState.conversationalUnits.forEach(unit => {
                // Update thought timer
                unit.thoughtTimer += deltaTime * 1000;

                // Generate new thoughts periodically
                if (unit.thoughtTimer >= unit.nextThoughtTime) {
                    unit.dialogue.currentThought = generateThought(unit);
                    unit.dialogue.thoughtBubbleVisible = true;
                    unit.thoughtTimer = 0;
                    unit.nextThoughtTime = 8000 + Math.random() * 15000; // 8-23 seconds

                    // Hide thought bubble after a while
                    setTimeout(() => {
                        unit.dialogue.thoughtBubbleVisible = false;
                    }, 4000);
                }

                // Update needs based on game state
                updateUnitNeeds(unit);

                // Generate creative ideas periodically
                if (Math.random() < 0.001 && unit.creativity.inspirationLevel > 60) { // 0.1% chance per frame
                    generateCreativeIdea(unit);
                }

                // Gentle movement
                if (Math.random() < 0.005) { // 0.5% chance per frame to move
                    const moveRadius = 30;
                    unit.targetX = unit.x + (Math.random() - 0.5) * moveRadius;
                    unit.targetY = unit.y + (Math.random() - 0.5) * moveRadius;

                    // Keep within bounds
                    unit.targetX = Math.max(50, Math.min(canvas.width - 50, unit.targetX));
                    unit.targetY = Math.max(50, Math.min(canvas.height - 50, unit.targetY));
                }

                // Simple movement towards target
                if (unit.targetX && unit.targetY) {
                    const dx = unit.targetX - unit.x;
                    const dy = unit.targetY - unit.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance > 2) {
                        const speed = 15; // Slow, contemplative movement
                        const moveDistance = speed * deltaTime;
                        const ratio = Math.min(moveDistance / distance, 1);

                        unit.x += dx * ratio;
                        unit.y += dy * ratio;
                    }
                }
            });
        };

        const updateUnitNeeds = (unit) => {
            unit.needs.current = [];

            // Generate needs based on game state
            if (gameState.harmony < 50) {
                unit.needs.current.push({
                    type: 'harmony_restoration',
                    urgency: 'high',
                    description: 'The sanctuary feels discordant. I need to help restore balance.'
                });
            }

            if (gameState.energy < 30) {
                unit.needs.current.push({
                    type: 'energy_boost',
                    urgency: 'medium',
                    description: 'The energy flows are weak. We need to revitalize them.'
                });
            }

            // Type-specific needs
            if (unit.type === 'artisticWeaver' && unit.creativity.inspirationLevel < 40) {
                unit.needs.current.push({
                    type: 'inspiration',
                    urgency: 'medium',
                    description: 'I need more beauty and inspiration to create meaningful art.'
                });
            }

            if (unit.type === 'philosopherDreamer' && gameState.insight < 20) {
                unit.needs.current.push({
                    type: 'contemplation_space',
                    urgency: 'low',
                    description: 'I require quiet contemplation to generate deeper insights.'
                });
            }
        };

        const generateCreativeIdea = (unit) => {
            const ideas = [];
            const creativityScore = unit.personality.creativity * (unit.creativity.inspirationLevel / 100);

            if (creativityScore > 0.6) {
                if (unit.type === 'artisticWeaver') {
                    ideas.push({
                        type: 'artistic_creation',
                        title: 'Harmony Tapestry',
                        description: 'A living tapestry that visualizes the sanctuary\'s energy flows',
                        requirements: { insight: 30, harmony: 60 },
                        effects: { beauty: 20, harmony_generation: 0.5 },
                        timeToComplete: 120000
                    });
                } else if (unit.type === 'philosopherDreamer') {
                    ideas.push({
                        type: 'philosophical_insight',
                        title: 'Meditation Garden Design',
                        description: 'A sacred space layout that enhances contemplation and wisdom',
                        requirements: { energy: 25, insight: 40 },
                        effects: { wisdom_boost: 1.3, meditation_efficiency: 1.5 },
                        timeToComplete: 180000
                    });
                }
            }

            if (ideas.length > 0) {
                unit.creativity.ideas.push(...ideas);
                log(`${unit.type} has a creative inspiration!`, 'info');
            }
        };

        const generateLLMDialogue = async (unit, playerInput = null) => {
            // Simulate LLM response for now (in real implementation, this would call the actual LLM API)
            const responses = {
                philosopherDreamer: {
                    greeting: [
                        "Ah, seeker of wisdom, I sense your curiosity about the cosmic mysteries. Would you like me to share a dream vision I had about the sanctuary's future?",
                        "Welcome, contemplative soul. I've been pondering the nature of existence in this sacred space. What brings you to seek conversation?",
                        "Greetings, fellow traveler of consciousness. I feel the harmony flowing between us. Shall we explore the deeper meanings together?"
                    ],
                    needs: [
                        "I sense discord in the sanctuary's harmony. Perhaps we could work together to restore the cosmic balance?",
                        "The energy flows seem diminished. I could guide a meditation to revitalize our shared space, if you're willing.",
                        "I've been contemplating ways to enhance our sanctuary's wisdom. Would you be interested in a philosophical collaboration?"
                    ],
                    creative: [
                        "I've envisioned a magnificent meditation garden that could transform how we experience consciousness here. Shall I share this dream with you?",
                        "In my contemplations, I've discovered a method to weave dreams into reality. Would you like to explore this possibility together?",
                        "I sense great potential for a consciousness bridge that could unite all beings in the sanctuary. Are you ready for such a profound undertaking?"
                    ]
                },
                artisticWeaver: {
                    greeting: [
                        "Oh, what beautiful energy you bring! I can see colors dancing around you that inspire new creations. Would you like to co-create something magnificent?",
                        "Welcome, kindred spirit! I've been weaving patterns of light and sound. Your presence adds such wonderful new hues to my palette!",
                        "Greetings, fellow appreciator of beauty! I sense an artistic collaboration brewing between us. What masterpiece shall we birth together?"
                    ],
                    needs: [
                        "I'm yearning for more inspiration to fuel my creative fire. The sanctuary's beauty feeds my art - could we enhance it together?",
                        "My artistic vision sees potential for incredible beauty here, but I need more creative energy. Would you help me gather inspiration?",
                        "I feel the sanctuary calling for more aesthetic harmony. My art could transform this space - shall we begin a beautiful project?"
                    ],
                    creative: [
                        "I've conceived of a living tapestry that would make the sanctuary's energy visible as flowing art. Would you commission this masterpiece?",
                        "My imagination has birthed a cosmic sculpture that could boost everyone's creativity. Shall we bring this vision to life?",
                        "I dream of creating an interactive art installation where beauty itself becomes a source of power. Are you ready to make art that changes reality?"
                    ]
                },
                curiousExplorer: {
                    greeting: [
                        "Fascinating! A new consciousness to explore and understand! I've been mapping the hidden mysteries of this sanctuary. Want to join my next expedition?",
                        "Greetings, fellow seeker! I've discovered the most intriguing phenomena in the sanctuary's depths. Would you like to investigate them with me?",
                        "Welcome, adventurous spirit! I sense you have the curiosity for great discoveries. Shall we uncover the sanctuary's secrets together?"
                    ],
                    needs: [
                        "I've detected mysterious energy signatures that need investigation. Would you help me explore these fascinating anomalies?",
                        "My explorations have revealed hidden chambers of knowledge, but I need a companion to safely venture deeper. Are you brave enough?",
                        "I sense undiscovered treasures of wisdom scattered throughout the sanctuary. Shall we embark on a treasure hunt together?"
                    ],
                    creative: [
                        "I've mapped a route to dimensions beyond our current perception. Would you join me on an interdimensional exploration?",
                        "My investigations have revealed a method to unlock hidden abilities through discovery. Are you ready for such an adventure?",
                        "I've conceived of an exploration network that could reveal all the sanctuary's mysteries simultaneously. Shall we build it together?"
                    ]
                }
            };

            const unitResponses = responses[unit.type] || responses.philosopherDreamer;
            let responseCategory = 'greeting';

            if (unit.needs.current.length > 0) {
                responseCategory = 'needs';
            } else if (unit.creativity.ideas.length > 0) {
                responseCategory = 'creative';
            }

            const possibleResponses = unitResponses[responseCategory];
            const response = possibleResponses[Math.floor(Math.random() * possibleResponses.length)];

            // Update conversation history
            if (playerInput) {
                unit.dialogue.conversationHistory.push({
                    timestamp: Date.now(),
                    player: playerInput,
                    unit: response,
                    topic: unit.dialogue.currentTopic
                });
            }

            return response;
        };

        const drawConversationalUnits = () => {
            gameState.conversationalUnits.forEach(unit => {
                drawConversationalUnit(unit);
            });
        };

        const drawConversationalUnit = (unit) => {
            ctx.save();
            ctx.translate(unit.x, unit.y);

            const pulse = 1 + Math.sin(animationTime * 1.2 + unit.animationOffset) * 0.08;
            const currentSize = unit.size * pulse;

            // Consciousness aura - more ethereal than regular units
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            ctx.shadowColor = unit.glowColor;
            ctx.shadowBlur = 40;

            const auraGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize * 3);
            const r = parseInt(unit.glowColor.slice(1,3), 16);
            const g = parseInt(unit.glowColor.slice(3,5), 16);
            const b = parseInt(unit.glowColor.slice(5,7), 16);

            auraGradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.4)`);
            auraGradient.addColorStop(0.3, `rgba(${r}, ${g}, ${b}, 0.2)`);
            auraGradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);

            ctx.beginPath();
            ctx.arc(0, 0, currentSize * 3, 0, Math.PI * 2);
            ctx.fillStyle = auraGradient;
            ctx.fill();
            ctx.restore();

            // Draw unit based on type
            if (unit.type === 'philosopherDreamer') {
                drawPhilosopherDreamer(unit, currentSize);
            } else if (unit.type === 'artisticWeaver') {
                drawArtisticWeaver(unit, currentSize);
            } else if (unit.type === 'curiousExplorer') {
                drawCuriousExplorer(unit, currentSize);
            }

            // Draw thought bubble if visible
            if (unit.dialogue.thoughtBubbleVisible && unit.dialogue.currentThought) {
                drawThoughtBubble(unit, currentSize);
            }

            // Draw conversation indicator
            if (unit.dialogue.conversationHistory.length > 0) {
                drawConversationIndicator(unit, currentSize);
            }

            // Draw needs indicator
            if (unit.needs.current.length > 0) {
                drawNeedsIndicator(unit, currentSize);
            }

            ctx.restore();
        };

        const drawPhilosopherDreamer = (unit, size) => {
            // Ethereal, contemplative design with flowing energy
            ctx.save();
            ctx.shadowColor = unit.glowColor;
            ctx.shadowBlur = 30;

            // Main consciousness form - flowing, organic shape
            const flow = animationTime * 0.8;
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
            const r = parseInt(unit.color.slice(1,3), 16);
            const g = parseInt(unit.color.slice(3,5), 16);
            const b = parseInt(unit.color.slice(5,7), 16);

            gradient.addColorStop(0, `rgba(${Math.min(255, r + 80)}, ${Math.min(255, g + 80)}, ${Math.min(255, b + 80)}, 1.0)`);
            gradient.addColorStop(0.6, `rgba(${r}, ${g}, ${b}, 0.9)`);
            gradient.addColorStop(1, `rgba(${Math.max(0, r - 40)}, ${Math.max(0, g - 40)}, ${Math.max(0, b - 40)}, 0.6)`);

            // Draw flowing consciousness form
            ctx.beginPath();
            for (let i = 0; i <= 20; i++) {
                const angle = (i * Math.PI * 2) / 20;
                const variation = 1 + Math.sin(angle * 3 + flow) * 0.15;
                const radius = size * variation;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fillStyle = gradient;
            ctx.fill();

            // Wisdom symbols floating around
            for (let i = 0; i < 4; i++) {
                const symbolAngle = flow * 0.3 + (i * Math.PI * 2 / 4);
                const symbolRadius = size * 1.8;
                const symbolX = Math.cos(symbolAngle) * symbolRadius;
                const symbolY = Math.sin(symbolAngle) * symbolRadius;

                ctx.save();
                ctx.translate(symbolX, symbolY);
                ctx.rotate(symbolAngle);
                ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.7)`;
                ctx.font = '16px serif';
                ctx.textAlign = 'center';
                ctx.fillText(['‚óä', '‚óà', '‚óá', '‚óÜ'][i], 0, 5);
                ctx.restore();
            }

            // Central consciousness eye
            ctx.beginPath();
            ctx.arc(0, 0, size * 0.3, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.fill();

            ctx.beginPath();
            ctx.arc(0, 0, size * 0.15, 0, Math.PI * 2);
            ctx.fillStyle = unit.color;
            ctx.fill();

            ctx.restore();
        };

        const drawArtisticWeaver = (unit, size) => {
            // Creative, colorful design with artistic flair
            ctx.save();
            ctx.shadowColor = unit.glowColor;
            ctx.shadowBlur = 25;

            const creativity = animationTime * 1.5;

            // Main artistic form - dynamic, creative shape
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
            const r = parseInt(unit.color.slice(1,3), 16);
            const g = parseInt(unit.color.slice(3,5), 16);
            const b = parseInt(unit.color.slice(5,7), 16);

            gradient.addColorStop(0, `rgba(${Math.min(255, r + 60)}, ${Math.min(255, g + 60)}, ${Math.min(255, b + 60)}, 1.0)`);
            gradient.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, 0.9)`);
            gradient.addColorStop(1, `rgba(${Math.max(0, r - 30)}, ${Math.max(0, g - 30)}, ${Math.max(0, b - 30)}, 0.7)`);

            // Draw artistic petals/brushstrokes
            for (let i = 0; i < 8; i++) {
                const petalAngle = (i * Math.PI * 2 / 8) + creativity * 0.2;
                const petalLength = size * (0.8 + Math.sin(creativity + i) * 0.3);

                ctx.save();
                ctx.rotate(petalAngle);
                ctx.beginPath();
                ctx.ellipse(petalLength * 0.4, 0, petalLength * 0.6, petalLength * 0.2, 0, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
                ctx.restore();
            }

            // Central creative core
            ctx.beginPath();
            ctx.arc(0, 0, size * 0.5, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(${Math.min(255, r + 100)}, ${Math.min(255, g + 100)}, ${Math.min(255, b + 100)}, 0.9)`;
            ctx.fill();

            // Creative sparkles
            for (let i = 0; i < 6; i++) {
                const sparkleAngle = creativity * 2 + (i * Math.PI * 2 / 6);
                const sparkleRadius = size * (1.2 + Math.sin(creativity * 3 + i) * 0.2);
                const sparkleX = Math.cos(sparkleAngle) * sparkleRadius;
                const sparkleY = Math.sin(sparkleAngle) * sparkleRadius;

                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                ctx.beginPath();
                ctx.arc(sparkleX, sparkleY, 2, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.shadowColor = unit.glowColor;
                ctx.shadowBlur = 8;
                ctx.fill();
                ctx.restore();
            }

            ctx.restore();
        };

        const drawCuriousExplorer = (unit, size) => {
            // Dynamic, energetic design with exploration motifs
            ctx.save();
            ctx.shadowColor = unit.glowColor;
            ctx.shadowBlur = 20;

            const exploration = animationTime * 2;

            // Main explorer form - angular, dynamic
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
            const r = parseInt(unit.color.slice(1,3), 16);
            const g = parseInt(unit.color.slice(3,5), 16);
            const b = parseInt(unit.color.slice(5,7), 16);

            gradient.addColorStop(0, `rgba(${Math.min(255, r + 50)}, ${Math.min(255, g + 50)}, ${Math.min(255, b + 50)}, 1.0)`);
            gradient.addColorStop(0.6, `rgba(${r}, ${g}, ${b}, 0.9)`);
            gradient.addColorStop(1, `rgba(${Math.max(0, r - 25)}, ${Math.max(0, g - 25)}, ${Math.max(0, b - 25)}, 0.7)`);

            // Draw exploration compass design
            ctx.beginPath();
            for (let i = 0; i < 8; i++) {
                const angle = (i * Math.PI * 2) / 8;
                const radius = i % 2 === 0 ? size : size * 0.6;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fillStyle = gradient;
            ctx.fill();

            // Exploration rays
            for (let i = 0; i < 4; i++) {
                const rayAngle = exploration * 0.5 + (i * Math.PI * 2 / 4);
                const rayLength = size * (1.5 + Math.sin(exploration + i) * 0.3);

                ctx.save();
                ctx.rotate(rayAngle);
                ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.6)`;
                ctx.lineWidth = 2;
                ctx.shadowBlur = 10;

                ctx.beginPath();
                ctx.moveTo(size * 0.8, 0);
                ctx.lineTo(rayLength, 0);
                ctx.stroke();

                // Arrow tip
                ctx.beginPath();
                ctx.moveTo(rayLength, 0);
                ctx.lineTo(rayLength - 8, -4);
                ctx.lineTo(rayLength - 8, 4);
                ctx.closePath();
                ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.8)`;
                ctx.fill();

                ctx.restore();
            }

            // Central discovery core
            ctx.beginPath();
            ctx.arc(0, 0, size * 0.3, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(${Math.min(255, r + 70)}, ${Math.min(255, g + 70)}, ${Math.min(255, b + 70)}, 0.9)`;
            ctx.fill();

            ctx.restore();
        };

        const drawThoughtBubble = (unit, size) => {
            if (!unit.dialogue.currentThought) return;

            ctx.save();
            ctx.translate(0, -size * 2);

            // Bubble background
            const bubbleWidth = Math.min(200, unit.dialogue.currentThought.length * 8);
            const bubbleHeight = 40;

            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            ctx.strokeStyle = 'rgba(100, 100, 100, 0.8)';
            ctx.lineWidth = 2;
            ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
            ctx.shadowBlur = 10;

            // Rounded rectangle
            ctx.beginPath();
            ctx.roundRect(-bubbleWidth/2, -bubbleHeight/2, bubbleWidth, bubbleHeight, 15);
            ctx.fill();
            ctx.stroke();

            // Bubble tail
            ctx.beginPath();
            ctx.moveTo(0, bubbleHeight/2);
            ctx.lineTo(-10, bubbleHeight/2 + 15);
            ctx.lineTo(10, bubbleHeight/2 + 15);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Text
            ctx.fillStyle = '#333';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.shadowBlur = 0;

            // Word wrap
            const words = unit.dialogue.currentThought.split(' ');
            const lines = [];
            let currentLine = '';

            words.forEach(word => {
                const testLine = currentLine + (currentLine ? ' ' : '') + word;
                if (ctx.measureText(testLine).width < bubbleWidth - 20) {
                    currentLine = testLine;
                } else {
                    if (currentLine) lines.push(currentLine);
                    currentLine = word;
                }
            });
            if (currentLine) lines.push(currentLine);

            lines.forEach((line, index) => {
                ctx.fillText(line, 0, -lines.length * 6 + index * 12);
            });

            ctx.restore();
        };

        const drawConversationIndicator = (unit, size) => {
            // Small chat icon to show unit is conversational
            ctx.save();
            ctx.translate(size * 0.8, -size * 0.8);

            ctx.fillStyle = 'rgba(100, 200, 255, 0.8)';
            ctx.strokeStyle = 'rgba(50, 150, 255, 1.0)';
            ctx.lineWidth = 1;
            ctx.shadowColor = 'rgba(100, 200, 255, 0.5)';
            ctx.shadowBlur = 5;

            // Chat bubble icon
            ctx.beginPath();
            ctx.roundRect(-8, -6, 16, 12, 4);
            ctx.fill();
            ctx.stroke();

            // Chat dots
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(-4, 0, 1.5, 0, Math.PI * 2);
            ctx.arc(0, 0, 1.5, 0, Math.PI * 2);
            ctx.arc(4, 0, 1.5, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        };

        const drawNeedsIndicator = (unit, size) => {
            if (unit.needs.current.length === 0) return;

            ctx.save();
            ctx.translate(-size * 0.8, -size * 0.8);

            // Exclamation mark for needs
            const urgencyColor = unit.needs.current.some(n => n.urgency === 'high') ?
                'rgba(255, 100, 100, 0.9)' : 'rgba(255, 200, 100, 0.9)';

            ctx.fillStyle = urgencyColor;
            ctx.strokeStyle = 'rgba(200, 50, 50, 1.0)';
            ctx.lineWidth = 1;
            ctx.shadowColor = urgencyColor;
            ctx.shadowBlur = 5;

            // Exclamation background
            ctx.beginPath();
            ctx.arc(0, 0, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // Exclamation mark
            ctx.fillStyle = 'white';
            ctx.font = 'bold 12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('!', 0, 4);

            ctx.restore();
        };

        // Conversation interaction system
        let selectedConversationalUnit = null;
        let conversationDialog = null;

        const createConversationDialog = (unit) => {
            // Remove existing dialog
            if (conversationDialog) {
                conversationDialog.remove();
            }

            conversationDialog = document.createElement('div');
            conversationDialog.className = 'conversation-dialog';
            conversationDialog.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(135deg, rgba(30, 27, 75, 0.95), rgba(49, 46, 129, 0.95));
                border: 2px solid rgba(139, 92, 246, 0.5);
                border-radius: 15px;
                padding: 20px;
                max-width: 500px;
                width: 90%;
                color: white;
                font-family: 'Inter', sans-serif;
                box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
                backdrop-filter: blur(10px);
                z-index: 1000;
            `;

            conversationDialog.innerHTML = `
                <div style="display: flex; align-items: center; margin-bottom: 15px;">
                    <div style="width: 40px; height: 40px; border-radius: 50%; background: ${unit.color}; margin-right: 15px; display: flex; align-items: center; justify-content: center; font-size: 20px;">
                        ${unit.type === 'philosopherDreamer' ? 'üßô‚Äç‚ôÇÔ∏è' : unit.type === 'artisticWeaver' ? 'üé®' : 'üîç'}
                    </div>
                    <div>
                        <h3 style="margin: 0; color: #A78BFA;">${unit.type.replace(/([A-Z])/g, ' $1').trim()}</h3>
                        <p style="margin: 0; font-size: 12px; color: #C4B5FD;">Mood: ${unit.personality.mood} ‚Ä¢ Traits: ${unit.personality.traits.slice(0, 2).join(', ')}</p>
                    </div>
                    <button onclick="closeConversationDialog()" style="margin-left: auto; background: none; border: none; color: #9CA3AF; font-size: 20px; cursor: pointer;">√ó</button>
                </div>

                <div id="conversation-content" style="margin-bottom: 15px; max-height: 200px; overflow-y: auto;">
                    <div style="background: rgba(139, 92, 246, 0.2); padding: 10px; border-radius: 8px; margin-bottom: 10px;">
                        <div style="font-size: 12px; color: #A78BFA; margin-bottom: 5px;">${unit.type}:</div>
                        <div id="unit-response">Generating response...</div>
                    </div>
                </div>

                <div style="display: flex; gap: 10px;">
                    <input type="text" id="player-input" placeholder="What would you like to say?"
                           style="flex: 1; padding: 10px; border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 8px; background: rgba(0, 0, 0, 0.2); color: white;" />
                    <button onclick="sendMessage()" style="padding: 10px 20px; background: linear-gradient(45deg, #8B5CF6, #A855F7); border: none; border-radius: 8px; color: white; cursor: pointer;">Send</button>
                </div>

                ${unit.needs.current.length > 0 ? `
                    <div style="margin-top: 15px; padding: 10px; background: rgba(239, 68, 68, 0.1); border-radius: 8px; border-left: 4px solid #EF4444;">
                        <div style="font-size: 12px; color: #FCA5A5; margin-bottom: 5px;">Current Needs:</div>
                        ${unit.needs.current.map(need => `<div style="font-size: 11px; color: #FED7D7;">‚Ä¢ ${need.description}</div>`).join('')}
                    </div>
                ` : ''}

                ${unit.creativity.ideas.length > 0 ? `
                    <div style="margin-top: 15px; padding: 10px; background: rgba(236, 72, 153, 0.1); border-radius: 8px; border-left: 4px solid #EC4899;">
                        <div style="font-size: 12px; color: #F9A8D4; margin-bottom: 5px;">Creative Ideas:</div>
                        ${unit.creativity.ideas.slice(0, 2).map(idea => `<div style="font-size: 11px; color: #FBCFE8;">‚Ä¢ ${idea.title}: ${idea.description}</div>`).join('')}
                    </div>
                ` : ''}
            `;

            document.body.appendChild(conversationDialog);

            // Generate initial response
            generateLLMDialogue(unit).then(response => {
                document.getElementById('unit-response').textContent = response;
            });

            // Focus input
            document.getElementById('player-input').focus();

            // Enter key handler
            document.getElementById('player-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            });
        };

        // --- TDD: Unit Interactions & Synergy System ---

        const detectNearbyUnits = (unit, allUnits, interactionRadius = 60) => {
            const nearbyUnits = [];

            allUnits.forEach(otherUnit => {
                if (otherUnit.id === unit.id) return;

                const distance = Math.sqrt(
                    Math.pow(otherUnit.x - unit.x, 2) +
                    Math.pow(otherUnit.y - unit.y, 2)
                );

                if (distance <= interactionRadius) {
                    nearbyUnits.push({
                        unit: otherUnit,
                        distance: distance,
                        interactionType: determineInteractionType(unit, otherUnit)
                    });
                }
            });

            return nearbyUnits;
        };

        const determineInteractionType = (unit1, unit2) => {
            const interactions = {
                'dreamer-weaver': 'inspiration',
                'weaver-dreamer': 'inspiration',
                'philosopherDreamer-artisticWeaver': 'creative_collaboration',
                'artisticWeaver-philosopherDreamer': 'creative_collaboration',
                'curiousExplorer-philosopherDreamer': 'knowledge_sharing',
                'philosopherDreamer-curiousExplorer': 'knowledge_sharing'
            };

            const key1 = `${unit1.type}-${unit2.type}`;
            const key2 = `${unit2.type}-${unit1.type}`;

            return interactions[key1] || interactions[key2] || 'general_synergy';
        };

        const updateUnitInteractions = (deltaTime) => {
            const currentTime = Date.now();

            // Clean up expired interactions
            gameState.activeInteractions = gameState.activeInteractions.filter(interaction => {
                return currentTime - interaction.startTime < interaction.duration;
            });

            // Check for new interactions between all units
            const allUnits = [
                ...gameState.villageGrid.filter(unit => unit.movable),
                ...gameState.intelligentCreatures,
                ...gameState.conversationalUnits
            ];

            allUnits.forEach(unit => {
                const nearbyUnits = detectNearbyUnits(unit, allUnits);

                nearbyUnits.forEach(nearby => {
                    // Check if interaction already exists
                    const existingInteraction = gameState.activeInteractions.find(interaction =>
                        (interaction.participants.includes(unit.id) && interaction.participants.includes(nearby.unit.id))
                    );

                    if (!existingInteraction && Math.random() < 0.01) { // 1% chance per frame to start interaction
                        createInteraction(unit, nearby.unit, nearby.interactionType);
                    }
                });
            });

            // Apply interaction effects
            gameState.activeInteractions.forEach(interaction => {
                applyInteractionEffects(interaction, deltaTime);
            });
        };

        const createInteraction = (unit1, unit2, interactionType) => {
            const interaction = {
                id: `${unit1.id}_${unit2.id}_${Date.now()}`,
                participants: [unit1.id, unit2.id],
                type: interactionType,
                startTime: Date.now(),
                duration: 5000,
                effects: [],
                active: true
            };

            // Define interaction effects
            switch (interactionType) {
                case 'inspiration':
                    interaction.effects = [
                        { type: 'resource_generation', resource: 'inspiration', amount: 2 }
                    ];
                    break;

                case 'creative_collaboration':
                    interaction.effects = [
                        { type: 'resource_generation', resource: 'inspiration', amount: 3 },
                        { type: 'resource_generation', resource: 'insight', amount: 1 }
                    ];
                    break;

                case 'knowledge_sharing':
                    interaction.effects = [
                        { type: 'resource_generation', resource: 'wisdom', amount: 2 },
                        { type: 'resource_generation', resource: 'insight', amount: 1 }
                    ];
                    break;

                default:
                    interaction.effects = [
                        { type: 'resource_generation', resource: 'inspiration', amount: 1 }
                    ];
            }

            gameState.activeInteractions.push(interaction);
            log(`${unit1.type} and ${unit2.type} begin ${interactionType}!`, 'info');

            // TDD: Track statistics for achievements
            updateStatistics('interaction_occurred');
        };

        const applyInteractionEffects = (interaction, deltaTime) => {
            interaction.effects.forEach(effect => {
                if (effect.type === 'resource_generation') {
                    const amount = effect.amount * deltaTime;
                    if (gameState[effect.resource] !== undefined) {
                        gameState[effect.resource] += amount;
                    }
                }
            });
        };

        // --- TDD: Achievement & Goals System ---

        const initializeAchievements = () => {
            const achievements = {
                // Basic Achievements
                first_dreamer: {
                    id: 'first_dreamer',
                    name: 'Dream Weaver',
                    description: 'Create your first Dreamer unit',
                    category: 'basic',
                    requirements: { type: 'unit_creation', unitType: 'dreamers', target: 1 },
                    rewards: { insight: 10, title: 'Novice Dreamer' },
                    unlocked: false,
                    progress: 0,
                    rarity: 'common'
                },
                first_weaver: {
                    id: 'first_weaver',
                    name: 'Reality Shaper',
                    description: 'Create your first Weaver unit',
                    category: 'basic',
                    requirements: { type: 'unit_creation', unitType: 'weavers', target: 1 },
                    rewards: { energy: 15, title: 'Reality Apprentice' },
                    unlocked: false,
                    progress: 0,
                    rarity: 'common'
                },
                energy_milestone: {
                    id: 'energy_milestone',
                    name: 'Power Surge',
                    description: 'Accumulate 100 Energy',
                    category: 'basic',
                    requirements: { type: 'resource_threshold', resource: 'energy', target: 100 },
                    rewards: { energy: 25, insight: 10 },
                    unlocked: false,
                    progress: 0,
                    rarity: 'common'
                },
                harmony_master: {
                    id: 'harmony_master',
                    name: 'Harmony Master',
                    description: 'Achieve 90% Harmony',
                    category: 'advanced',
                    requirements: { type: 'harmony_level', target: 90 },
                    rewards: { harmony: 10, wisdom: 20, title: 'Harmony Master' },
                    unlocked: false,
                    progress: 0,
                    rarity: 'rare'
                },
                social_butterfly: {
                    id: 'social_butterfly',
                    name: 'Social Butterfly',
                    description: 'Have 10 unit interactions',
                    category: 'advanced',
                    requirements: { type: 'total_interactions', target: 10 },
                    rewards: { inspiration: 30, wisdom: 15 },
                    unlocked: false,
                    progress: 0,
                    rarity: 'uncommon'
                },
                conversationalist: {
                    id: 'conversationalist',
                    name: 'Deep Conversationalist',
                    description: 'Have 5 conversations with AI units',
                    category: 'advanced',
                    requirements: { type: 'conversation_count', target: 5 },
                    rewards: { wisdom: 25, insight: 15, title: 'Sage Communicator' },
                    unlocked: false,
                    progress: 0,
                    rarity: 'rare'
                },
                sanctuary_architect: {
                    id: 'sanctuary_architect',
                    name: 'Sanctuary Architect',
                    description: 'Create 10 units of any type',
                    category: 'advanced',
                    requirements: { type: 'total_units_created', target: 10 },
                    rewards: { energy: 50, insight: 30, inspiration: 20 },
                    unlocked: false,
                    progress: 0,
                    rarity: 'uncommon'
                },
                cosmic_sage: {
                    id: 'cosmic_sage',
                    name: 'Cosmic Sage',
                    description: 'Reach maximum levels in all resources',
                    category: 'master',
                    requirements: {
                        type: 'multiple_conditions',
                        conditions: [
                            { type: 'min_resource', resource: 'energy', value: 500 },
                            { type: 'min_resource', resource: 'insight', value: 300 },
                            { type: 'min_resource', resource: 'wisdom', value: 200 },
                            { type: 'min_resource', resource: 'inspiration', value: 150 }
                        ]
                    },
                    rewards: { title: 'Cosmic Sage', energy: 100, insight: 100, wisdom: 100, inspiration: 100 },
                    unlocked: false,
                    progress: 0,
                    rarity: 'legendary'
                }
            };

            gameState.achievements.definitions = achievements;
            return achievements;
        };

        const initializeGoals = () => {
            const goals = [
                {
                    id: 'sanctuary_growth',
                    title: 'Growing Sanctuary',
                    description: 'Expand your sanctuary by creating 5 units of any type',
                    type: 'unit_count',
                    target: 5,
                    progress: 0,
                    completed: false,
                    rewards: { energy: 25, insight: 15, harmony: 10 },
                    priority: 'high',
                    category: 'main',
                    hints: ['Create Dreamers and Weavers to expand your sanctuary', 'Each unit contributes to your sanctuary\'s growth']
                },
                {
                    id: 'energy_collector',
                    title: 'Energy Collector',
                    description: 'Accumulate 200 Energy',
                    type: 'resource_accumulation',
                    resource: 'energy',
                    target: 200,
                    progress: 0,
                    completed: false,
                    rewards: { energy: 50, insight: 25 },
                    priority: 'normal',
                    category: 'resource',
                    hints: ['Weavers generate Energy over time', 'Complete achievements for Energy bonuses']
                },
                {
                    id: 'harmony_keeper',
                    title: 'Harmony Keeper',
                    description: 'Maintain Harmony above 80% for 2 minutes',
                    type: 'harmony_maintenance',
                    threshold: 80,
                    target: 120000, // 2 minutes in milliseconds
                    progress: 0,
                    completed: false,
                    rewards: { harmony: 15, wisdom: 20, title: 'Harmony Keeper' },
                    priority: 'normal',
                    category: 'harmony',
                    hints: ['Keep your sanctuary balanced', 'Unit interactions help maintain harmony']
                },
                {
                    id: 'social_network',
                    title: 'Social Network',
                    description: 'Facilitate 15 unit interactions',
                    type: 'interaction_count',
                    target: 15,
                    progress: 0,
                    completed: false,
                    rewards: { inspiration: 40, wisdom: 25 },
                    priority: 'normal',
                    category: 'social',
                    prerequisites: ['sanctuary_growth'],
                    hints: ['Place units close together to encourage interactions', 'Different unit types create different interaction types']
                }
            ];

            gameState.goals.available = goals;
            gameState.goals.active = goals.slice(0, 2); // Start with first 2 goals active
            return goals;
        };

        const checkAchievementProgress = (achievement, gameState) => {
            const req = achievement.requirements;
            let currentProgress = 0;

            switch (req.type) {
                case 'unit_creation':
                    currentProgress = gameState.units[req.unitType] || 0;
                    break;
                case 'resource_threshold':
                    currentProgress = gameState[req.resource] || 0;
                    break;
                case 'total_interactions':
                    currentProgress = gameState.statistics.totalInteractions || 0;
                    break;
                case 'harmony_level':
                    currentProgress = gameState.harmony || 0;
                    break;
                case 'conversation_count':
                    currentProgress = gameState.statistics.totalConversations || 0;
                    break;
                case 'total_units_created':
                    currentProgress = gameState.statistics.totalUnitsCreated || 0;
                    break;
                case 'multiple_conditions':
                    currentProgress = req.conditions.every(condition =>
                        checkSingleCondition(condition, gameState)
                    ) ? 1 : 0;
                    break;
            }

            achievement.progress = Math.min(currentProgress, req.target || 1);

            if (achievement.progress >= (req.target || 1) && !achievement.unlocked) {
                return { shouldUnlock: true, achievement };
            }

            return { shouldUnlock: false, achievement };
        };

        const checkSingleCondition = (condition, gameState) => {
            switch (condition.type) {
                case 'min_units':
                    return (gameState.units[condition.unitType] || 0) >= condition.value;
                case 'min_resource':
                    return (gameState[condition.resource] || 0) >= condition.value;
                default:
                    return false;
            }
        };

        const unlockAchievement = (achievement, gameState) => {
            if (achievement.unlocked) return false;

            achievement.unlocked = true;
            achievement.unlockedAt = Date.now();

            // Apply rewards
            if (achievement.rewards) {
                Object.keys(achievement.rewards).forEach(rewardType => {
                    if (rewardType === 'title') {
                        gameState.playerTitles.push(achievement.rewards[rewardType]);
                    } else if (gameState[rewardType] !== undefined) {
                        gameState[rewardType] += achievement.rewards[rewardType];
                    }
                });
            }

            // Add to unlocked achievements
            gameState.achievements.unlocked.push(achievement.id);

            // Show achievement notification
            showAchievementNotification(achievement);

            log(`‚≠ê Achievement Unlocked: ${achievement.name}!`, 'success');

            return {
                success: true,
                achievement: achievement,
                rewards: achievement.rewards
            };
        };

        const updateGoalProgress = (goal, gameState) => {
            let currentProgress = 0;

            switch (goal.type) {
                case 'unit_count':
                    currentProgress = Object.values(gameState.units).reduce((sum, count) => sum + count, 0);
                    break;
                case 'resource_accumulation':
                    currentProgress = gameState[goal.resource] || 0;
                    break;
                case 'harmony_maintenance':
                    if (gameState.harmony >= goal.threshold) {
                        goal.harmonyStartTime = goal.harmonyStartTime || Date.now();
                        currentProgress = Date.now() - goal.harmonyStartTime;
                    } else {
                        goal.harmonyStartTime = null;
                        currentProgress = 0;
                    }
                    break;
                case 'interaction_count':
                    currentProgress = gameState.statistics.totalInteractions || 0;
                    break;
                case 'conversation_count':
                    currentProgress = gameState.statistics.totalConversations || 0;
                    break;
            }

            goal.progress = Math.min(currentProgress, goal.target);

            if (goal.progress >= goal.target && !goal.completed) {
                return { shouldComplete: true, goal };
            }

            return { shouldComplete: false, goal };
        };

        const completeGoal = (goal, gameState) => {
            if (goal.completed) return false;

            goal.completed = true;
            goal.completedAt = Date.now();

            // Apply rewards
            if (goal.rewards) {
                Object.keys(goal.rewards).forEach(rewardType => {
                    if (rewardType === 'title') {
                        gameState.playerTitles.push(goal.rewards[rewardType]);
                    } else if (gameState[rewardType] !== undefined) {
                        gameState[rewardType] += goal.rewards[rewardType];
                    }
                });
            }

            // Move to completed goals
            gameState.goals.completed.push(goal.id);
            gameState.goals.active = gameState.goals.active.filter(g => g.id !== goal.id);

            // Check for new goals that might be unlocked
            const newGoals = checkUnlockedGoals(gameState);
            gameState.goals.active.push(...newGoals);

            // Show goal completion notification
            showGoalNotification(goal);

            log(`üéØ Goal Completed: ${goal.title}!`, 'success');

            return {
                success: true,
                goal: goal,
                rewards: goal.rewards,
                newGoalsUnlocked: newGoals
            };
        };

        const checkUnlockedGoals = (gameState) => {
            const availableGoals = gameState.goals.available.filter(goal =>
                !gameState.goals.completed.includes(goal.id) &&
                !gameState.goals.active.some(activeGoal => activeGoal.id === goal.id)
            );

            return availableGoals.filter(goal => {
                if (!goal.prerequisites || goal.prerequisites.length === 0) return false;

                return goal.prerequisites.every(prereqId =>
                    gameState.goals.completed.includes(prereqId)
                );
            });
        };

        const updateStatistics = (eventType, data = {}) => {
            const stats = gameState.statistics;

            switch (eventType) {
                case 'unit_created':
                    stats.totalUnitsCreated += 1;
                    break;
                case 'energy_generated':
                    stats.totalEnergyGenerated += data.amount || 0;
                    stats.maxEnergy = Math.max(stats.maxEnergy, gameState.energy);
                    break;
                case 'insight_generated':
                    stats.totalInsightGenerated += data.amount || 0;
                    stats.maxInsight = Math.max(stats.maxInsight, gameState.insight);
                    break;
                case 'control_generated':
                    stats.totalControlGenerated += data.amount || 0;
                    stats.maxControl = Math.max(stats.maxControl, gameState.control);
                    break;
                case 'consciousness_generated':
                    stats.totalConsciousnessGenerated += data.amount || 0;
                    stats.maxConsciousness = Math.max(stats.maxConsciousness, gameState.consciousness);
                    stats.maxPlanetaryConsciousness = Math.max(stats.maxPlanetaryConsciousness, gameState.planetaryConsciousness);
                    break;
                case 'ruler_path_choice':
                    stats.rulerPathChoices += 1;
                    break;
                case 'gardener_path_choice':
                    stats.gardenerPathChoices += 1;
                    break;
                case 'interaction_occurred':
                    stats.totalInteractions += 1;
                    break;
                case 'conversation_started':
                    stats.totalConversations += 1;
                    break;
                case 'harmony_changed':
                    stats.maxHarmony = Math.max(stats.maxHarmony, gameState.harmony);
                    break;
            }

            // Update play time
            stats.playTime = Date.now() - stats.gameStartTime;
        };

        // --- TDD: Control vs Consciousness System ---

        const updateControlConsciousnessSystem = (deltaTime) => {
            // Control suppresses unrest but reduces consciousness over time
            if (gameState.control > 0) {
                const consciousnessReduction = gameState.control * 0.01 * deltaTime; // 1% per second per Control point
                gameState.consciousness = Math.max(0, gameState.consciousness - consciousnessReduction);

                // Control also reduces harmony slightly (authoritarian effects)
                const harmonyReduction = gameState.control * 0.005 * deltaTime;
                gameState.harmony = Math.max(0, gameState.harmony - harmonyReduction);
            }

            // Consciousness improves well-being but can create resistance to control
            if (gameState.consciousness > 0) {
                const harmonyBonus = gameState.consciousness * 0.01 * deltaTime; // 1% per second per Consciousness point
                gameState.harmony = Math.min(100, gameState.harmony + harmonyBonus);

                // High consciousness reduces control effectiveness
                if (gameState.consciousness > gameState.control) {
                    const controlReduction = (gameState.consciousness - gameState.control) * 0.005 * deltaTime;
                    gameState.control = Math.max(0, gameState.control - controlReduction);
                }
            }

            // Update planetary consciousness based on individual consciousness
            const consciousnessContribution = gameState.consciousness * 0.1 * deltaTime;
            const controlPenalty = gameState.control * 0.05 * deltaTime;
            gameState.planetaryConsciousness = Math.max(0, Math.min(100,
                gameState.planetaryConsciousness + consciousnessContribution - controlPenalty
            ));

            // Calculate entropy from imbalanced systems
            const imbalance = Math.abs(gameState.control - gameState.consciousness);
            if (imbalance > 20) {
                gameState.entropy += imbalance * 0.001 * deltaTime;
            }

            // Track statistics
            if (gameState.controlPerSecond > 0) {
                updateStatistics('control_generated', { amount: gameState.controlPerSecond * deltaTime });
            }
            if (gameState.consciousnessPerSecond > 0) {
                updateStatistics('consciousness_generated', { amount: gameState.consciousnessPerSecond * deltaTime });
            }
        };

        const checkGreatTransitionConditions = () => {
            // Don't check if game has already ended
            if (gameState.gameEnded) {
                return true;
            }

            // Check for story-driven victory conditions
            if (gameState.rulerPathProgress >= 100) {
                showRulerVictory();
                gameState.gameEnded = true;
                return true;
            }

            if (gameState.gardenerPathProgress >= 100) {
                showGardenerVictory();
                gameState.gameEnded = true;
                return true;
            }

            // Legacy win condition: Planetary Consciousness reaches 100 (if no story path chosen)
            if (gameState.planetaryConsciousness >= 100 && gameState.dominantPath === 'none') {
                showGenericVictory();
                gameState.gameEnded = true;
                return true;
            }

            // Lose conditions
            if (gameState.consciousness <= 0 && gameState.planetaryConsciousness <= 0) {
                showGreatTransitionDefeat('consciousness_collapse');
                gameState.gameEnded = true;
                return true;
            }

            if (gameState.entropy >= 100) {
                showGreatTransitionDefeat('entropy_overload');
                gameState.gameEnded = true;
                return true;
            }

            if (gameState.harmony <= 0) {
                showGreatTransitionDefeat('harmony_collapse');
                gameState.gameEnded = true;
                return true;
            }

            return false;
        };

        const showRulerVictory = () => {
            log('üöÄ THE EXODUS BEGINS! üöÄ', 'warning');
            log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'info');
            log('üèõÔ∏è You have chosen the Path of the Rulers.', 'warning');
            log('üåå The Exodus Ark rises from the dying planet, carrying the elite to the stars.', 'info');
            log('‚ö° Behind you, the world burns under the weight of your industrial empire.', 'error');
            log('üë• The masses remain enslaved, their consciousness forever suppressed.', 'error');
            log('üåü But you have joined the galactic empire - immortal rulers of the cosmos.', 'warning');
            log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'info');
            log('üí≠ "Power corrupts, but absolute power... transcends."', 'grok');
            log('üîÑ Will you choose differently next time?', 'info');

            createRulerVictoryCinematic();
            showRestartOption();
        };

        const showGardenerVictory = () => {
            log('üåü THE GREAT ASCENSION! üåü', 'success');
            log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'info');
            log('üå± You have chosen the Path of the Gardeners.', 'success');
            log('üåç The planet awakens! Every being achieves consciousness.', 'success');
            log('‚ú® Harmony flows through all life as the old systems dissolve.', 'success');
            log('ü¶ã Humanity transcends its limitations, becoming one with the cosmos.', 'success');
            log('üåà The age of separation ends. The age of unity begins.', 'success');
            log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'info');
            log('üí≠ "In awakening others, we awaken ourselves."', 'grok');
            log('üéâ You have guided humanity to its highest potential!', 'success');

            createGardenerVictoryCinematic();
            showRestartOption();
        };

        const showGenericVictory = () => {
            log('üåü THE GREAT TRANSITION ACHIEVED! üåü', 'success');
            log('Planetary Consciousness has reached 100. Humanity has awakened from its slumber!', 'success');
            log('The age of unconscious suffering ends. The age of conscious evolution begins.', 'success');
            log('üéâ You have guided humanity through the greatest transformation in its history!', 'success');
            log('üí° Next time, try following one of the ancient paths for a deeper story experience.', 'info');

            createVictoryCelebration();
            showRestartOption();
        };

        const showGreatTransitionDefeat = (reason) => {
            const messages = {
                consciousness_collapse: {
                    title: 'üíÄ CONSCIOUSNESS COLLAPSE',
                    description: 'The light of awareness has been extinguished. Humanity remains trapped in unconscious patterns.',
                    consequence: 'The rulers have won. The gardeners have failed.'
                },
                entropy_overload: {
                    title: 'üå™Ô∏è ENTROPY OVERLOAD',
                    description: 'The system has become too chaotic and imbalanced to sustain life.',
                    consequence: 'Neither path succeeded. Chaos reigns supreme.'
                },
                harmony_collapse: {
                    title: '‚ö° HARMONY COLLAPSE',
                    description: 'All balance has been lost. Society crumbles into conflict and despair.',
                    consequence: 'The foundation of civilization has shattered.'
                },
                totalitarian_victory: {
                    title: 'üëÅÔ∏è TOTALITARIAN VICTORY',
                    description: 'The Ruler path has achieved total dominance. Individual consciousness has been eliminated.',
                    consequence: 'Humanity exists, but no longer as conscious beings. They are perfect slaves.'
                }
            };

            const message = messages[reason] || {
                title: 'üíî THE GREAT TRANSITION FAILED',
                description: 'Humanity could not transcend its limitations.',
                consequence: 'The old patterns persist.'
            };

            log(message.title, 'error');
            log(message.description, 'error');
            log(message.consequence, 'warning');
            log('üîÑ Click "New Game" to try a different path and learn from this outcome.', 'info');

            // Show restart option
            showRestartOption();
        };

        // --- TDD: Story Progression System ---

        const checkStoryProgression = () => {
            // Mid-game reveal: Discover the anomaly
            if (!gameState.anomalyDiscovered && gameState.storyPhase === 'early') {
                const totalBuildings = Object.values(gameState.rulerBuildings).reduce((sum, count) => sum + count, 0) +
                                     Object.values(gameState.gardenerBuildings).reduce((sum, count) => sum + count, 0);

                if (totalBuildings >= 5 || gameState.consciousness + gameState.control >= 50) {
                    triggerAnomalyDiscovery();
                }
            }

            // True lore reveal after anomaly investigation
            if (gameState.anomalyDiscovered && !gameState.trueLoreRevealed && gameState.storyPhase === 'midgame_reveal') {
                const investigationProgress = gameState.wisdom + gameState.insight;
                if (investigationProgress >= 100) {
                    revealTrueLore();
                }
            }

            // Update dominant path
            updateDominantPath();
        };

        const triggerAnomalyDiscovery = () => {
            gameState.anomalyDiscovered = true;
            gameState.storyPhase = 'midgame_reveal';

            log('üåü DISCOVERY: An ancient monolith has been unearthed!', 'success');
            log('üìú Strange symbols pulse with otherworldly energy. This artifact predates known civilization.', 'info');
            log('üîç Research this anomaly to uncover the truth about your world\'s history.', 'warning');
            log('üí° Hint: Accumulate Wisdom and Insight to decode the monolith\'s secrets.', 'info');

            // Add research bonus
            gameState.wisdomPerSecond += 0.1;
            gameState.insightPerSecond += 0.1;
        };

        const revealTrueLore = () => {
            gameState.trueLoreRevealed = true;
            gameState.storyPhase = 'endgame';

            log('üåü THE TRUTH REVEALED! üåü', 'success');
            log('üìú The monolith speaks: "Two paths diverged in the cosmic wood..."', 'grok');
            log('üèõÔ∏è THE RULERS: Ancient galactic empire builders who seek dominion through control.', 'warning');
            log('üå± THE GARDENERS: Consciousness cultivators who nurture awakening and harmony.', 'success');
            log('‚ö° Your choices have aligned you with one of these ancient factions.', 'info');
            log('üéØ Choose your final destiny: Escape via Exodus Ark or achieve The Great Ascension.', 'warning');

            // Unlock victory buildings
            log('üîì Ultimate technologies now available in the Paths tab!', 'info');
        };

        const updateDominantPath = () => {
            const rulerChoices = gameState.statistics.rulerPathChoices || 0;
            const gardenerChoices = gameState.statistics.gardenerPathChoices || 0;
            const totalChoices = rulerChoices + gardenerChoices;

            if (totalChoices === 0) {
                gameState.dominantPath = 'none';
            } else {
                const rulerRatio = rulerChoices / totalChoices;
                if (rulerRatio > 0.6) {
                    gameState.dominantPath = 'ruler';
                } else if (rulerRatio < 0.4) {
                    gameState.dominantPath = 'gardener';
                } else {
                    gameState.dominantPath = 'balanced';
                }
            }
        };

        const createRulerVictoryCinematic = () => {
            // TODO: Add dark, industrial visual effects
            log('üî• The sky burns red as the Exodus Ark departs...', 'error');
            log('üè≠ Smokestacks pierce the polluted horizon...', 'warning');
            log('üëÅÔ∏è The surveillance towers stand eternal, watching over the enslaved masses...', 'error');
        };

        const createGardenerVictoryCinematic = () => {
            // TODO: Add beautiful, natural visual effects
            log('üå∏ Flowers bloom across the awakened landscape...', 'success');
            log('ü¶ã Consciousness flows like light through every living being...', 'success');
            log('üåà The planet itself seems to sing with joy...', 'success');
        };

        // --- TDD: Four Horsemen Crisis System ---

        const fourHorsemenConfig = {
            war: {
                name: "War",
                description: "Conflict erupts across the land. Military forces clash, destroying harmony and consuming resources.",
                triggerLevel: 25,
                effects: {
                    harmony: -20,
                    energy: -15,
                    entropy: 10
                },
                duration: 30000, // 30 seconds
                icon: "‚öîÔ∏è",
                color: "red"
            },
            famine: {
                name: "Famine",
                description: "Crops fail and food becomes scarce. The population suffers as resources dwindle.",
                triggerLevel: 40,
                effects: {
                    energy: -25,
                    harmony: -15,
                    consciousness: -5
                },
                duration: 45000, // 45 seconds
                icon: "üåæ",
                color: "orange"
            },
            pestilence: {
                name: "Pestilence",
                description: "Disease spreads through the population. Fear and suffering cloud the collective consciousness.",
                triggerLevel: 60,
                effects: {
                    consciousness: -20,
                    harmony: -10,
                    entropy: 15
                },
                duration: 40000, // 40 seconds
                icon: "ü¶†",
                color: "green"
            },
            death: {
                name: "Death",
                description: "The ultimate crisis. Despair grips the world as hope itself begins to fade.",
                triggerLevel: 80,
                effects: {
                    consciousness: -30,
                    harmony: -25,
                    planetaryConsciousness: -20,
                    entropy: 25
                },
                duration: 60000, // 60 seconds
                icon: "üíÄ",
                color: "black"
            }
        };

        const updateCrisisLevel = () => {
            // Calculate crisis level based on negative factors
            let crisisFactors = 0;

            // High entropy increases crisis
            crisisFactors += gameState.entropy * 0.5;

            // Low harmony increases crisis
            if (gameState.harmony < 50) {
                crisisFactors += (50 - gameState.harmony) * 0.3;
            }

            // Imbalanced paths increase crisis
            const pathImbalance = Math.abs(gameState.statistics.rulerPathChoices - gameState.statistics.gardenerPathChoices);
            crisisFactors += pathImbalance * 0.5;

            // Low consciousness increases crisis
            if (gameState.consciousness < 30) {
                crisisFactors += (30 - gameState.consciousness) * 0.2;
            }

            gameState.crisisLevel = Math.min(100, Math.max(0, crisisFactors));
        };

        const checkForNewCrises = () => {
            const now = Date.now();

            // Don't trigger crises too frequently
            if (now - gameState.lastCrisisTime < 60000) { // 1 minute cooldown
                return;
            }

            // Check each horseman
            for (const [key, horseman] of Object.entries(fourHorsemenConfig)) {
                // Skip if already active or defeated
                if (gameState.activeCrises.some(c => c.type === key) ||
                    gameState.horsemenDefeated.includes(key)) {
                    continue;
                }

                // Check if crisis level is high enough
                if (gameState.crisisLevel >= horseman.triggerLevel) {
                    // Random chance to trigger (20% per check)
                    if (Math.random() < 0.2) {
                        triggerCrisis(key, horseman);
                        gameState.lastCrisisTime = now;
                        break; // Only one crisis at a time
                    }
                }
            }
        };

        const triggerCrisis = (type, config) => {
            const crisis = {
                type: type,
                name: config.name,
                description: config.description,
                effects: config.effects,
                startTime: Date.now(),
                duration: config.duration,
                icon: config.icon,
                color: config.color,
                resolved: false
            };

            gameState.activeCrises.push(crisis);

            log(`${config.icon} CRISIS: ${config.name.toUpperCase()}!`, 'error');
            log(config.description, 'warning');
            log('üõ°Ô∏è Build appropriate structures or make strategic choices to resolve this crisis!', 'info');

            // Apply immediate effects
            applyCrisisEffects(crisis.effects);

            // Start crisis resolution timer
            setTimeout(() => {
                if (!crisis.resolved) {
                    resolveCrisisAutomatically(crisis);
                }
            }, config.duration);
        };

        const applyCrisisEffects = (effects) => {
            for (const [resource, amount] of Object.entries(effects)) {
                if (gameState[resource] !== undefined) {
                    gameState[resource] = Math.max(0, gameState[resource] + amount);
                }
            }
        };

        const resolveCrisisAutomatically = (crisis) => {
            // Remove from active crises
            gameState.activeCrises = gameState.activeCrises.filter(c => c !== crisis);

            log(`${crisis.icon} Crisis "${crisis.name}" has passed, but its effects linger...`, 'warning');

            // Apply lingering negative effects
            const lingeringEffects = {};
            for (const [resource, amount] of Object.entries(crisis.effects)) {
                lingeringEffects[resource] = amount * 0.3; // 30% of original effect
            }
            applyCrisisEffects(lingeringEffects);
        };

        const resolveCrisisManually = (crisisType) => {
            const crisis = gameState.activeCrises.find(c => c.type === crisisType);
            if (!crisis) return false;

            crisis.resolved = true;
            gameState.activeCrises = gameState.activeCrises.filter(c => c !== crisis);
            gameState.horsemenDefeated.push(crisisType);

            log(`${crisis.icon} Crisis "${crisis.name}" has been resolved through your actions!`, 'success');
            log('üèÜ You have defeated one of the Four Horsemen!', 'success');

            // Reward for manual resolution
            gameState.wisdom += 10;
            gameState.consciousness += 5;
            gameState.harmony += 10;

            return true;
        };

        const checkCrisisResolution = () => {
            for (const crisis of gameState.activeCrises) {
                if (crisis.resolved) continue;

                let canResolve = false;

                switch (crisis.type) {
                    case 'war':
                        // Resolve with high harmony or community structures
                        canResolve = gameState.harmony > 70 ||
                                   gameState.gardenerBuildings.communityCouncil > 0;
                        break;
                    case 'famine':
                        // Resolve with sustainable agriculture
                        canResolve = gameState.gardenerBuildings.permacultureGarden > 1 ||
                                   gameState.rulerBuildings.automatedAgriculture > 2;
                        break;
                    case 'pestilence':
                        // Resolve with healing structures or high consciousness
                        canResolve = gameState.gardenerBuildings.healingGrove > 1 ||
                                   gameState.consciousness > 60;
                        break;
                    case 'death':
                        // Resolve with high planetary consciousness or ascension buildings
                        canResolve = gameState.planetaryConsciousness > 80 ||
                                   gameState.gardenerBuildings.planetaryAwakening > 0;
                        break;
                }

                if (canResolve) {
                    resolveCrisisManually(crisis.type);
                }
            }
        };

        const createVictoryCelebration = () => {
            // Add visual celebration effects to the canvas
            // TODO: Implement particle effects, color changes, etc.
            log('‚ú® The sanctuary glows with the light of awakened consciousness...', 'success');
        };

        const showRestartOption = () => {
            // Add a game ended overlay and restart button
            setTimeout(() => {
                // Create overlay
                const overlay = document.createElement('div');
                overlay.className = 'fixed top-0 left-0 w-full h-full bg-black bg-opacity-50 flex items-center justify-center z-50';
                overlay.innerHTML = `
                    <div class="bg-gray-800 border border-gray-600 rounded-lg p-6 max-w-md mx-4 text-center">
                        <h3 class="text-xl font-bold text-white mb-4">üéÆ Game Complete</h3>
                        <p class="text-gray-300 mb-6">The Great Transition has concluded. Your choices have shaped humanity's destiny.</p>
                        <div class="space-y-3">
                            <button id="new-game-btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white py-2 px-4 rounded transition-colors">
                                üîÑ Start New Game
                            </button>
                            <button id="continue-exploring-btn" class="w-full bg-gray-600 hover:bg-gray-700 text-white py-2 px-4 rounded transition-colors">
                                üîç Continue Exploring
                            </button>
                        </div>
                    </div>
                `;

                // Add event listeners
                overlay.querySelector('#new-game-btn').onclick = () => {
                    if (confirm('Start a new game? This will reset all progress.')) {
                        startNewGame();
                    }
                };

                overlay.querySelector('#continue-exploring-btn').onclick = () => {
                    overlay.remove();
                };

                document.body.appendChild(overlay);
            }, 3000); // Show after 3 seconds
        };

        const startNewGame = () => {
            if (confirm('üîÑ Start a completely new game?\n\nThis will:\n‚Ä¢ Clear all saved progress\n‚Ä¢ Reset all resources to starting values\n‚Ä¢ Remove all buildings and units\n‚Ä¢ Reset story progression\n\nThis cannot be undone!')) {

                // Clear all localStorage data
                localStorage.removeItem('terraflow_save_data');
                localStorage.removeItem('terraflow_save');
                localStorage.removeItem('terraflow_achievements');
                localStorage.removeItem('terraflow_goals');

                log('üîÑ Clearing saved data and restarting...', 'info');

                // Reload the page to start completely fresh
                setTimeout(() => {
                    location.reload();
                }, 500);
            }
        };

        // --- TDD: Save/Load System ---

        const SAVE_KEY = 'terraflow_save_data';
        const CURRENT_SAVE_VERSION = "1.0.0";

        const saveGameState = () => {
            try {
                const saveData = {
                    version: CURRENT_SAVE_VERSION,
                    timestamp: Date.now(),
                    gameState: {
                        // Core resources
                        energy: gameState.energy,
                        insight: gameState.insight,
                        harmony: gameState.harmony,
                        inspiration: gameState.inspiration,
                        wisdom: gameState.wisdom,
                        control: gameState.control,
                        consciousness: gameState.consciousness,
                        planetaryConsciousness: gameState.planetaryConsciousness,
                        entropy: gameState.entropy,

                        // Per-second rates
                        energyPerSecond: gameState.energyPerSecond,
                        insightPerSecond: gameState.insightPerSecond,
                        inspirationPerSecond: gameState.inspirationPerSecond,
                        wisdomPerSecond: gameState.wisdomPerSecond,
                        controlPerSecond: gameState.controlPerSecond,
                        consciousnessPerSecond: gameState.consciousnessPerSecond,

                        // Units and buildings
                        units: { ...gameState.units },
                        nodes: { ...gameState.nodes },
                        nodeCosts: { ...gameState.nodeCosts },
                        rulerBuildings: { ...gameState.rulerBuildings },
                        gardenerBuildings: { ...gameState.gardenerBuildings },
                        techTreeUnlocked: gameState.techTreeUnlocked,
                        gameEnded: gameState.gameEnded,

                        // Story progression
                        storyPhase: gameState.storyPhase,
                        anomalyDiscovered: gameState.anomalyDiscovered,
                        trueLoreRevealed: gameState.trueLoreRevealed,
                        rulerPathProgress: gameState.rulerPathProgress,
                        gardenerPathProgress: gameState.gardenerPathProgress,
                        dominantPath: gameState.dominantPath,

                        // Crisis system
                        crisisLevel: gameState.crisisLevel,
                        activeCrises: gameState.activeCrises,
                        horsemenDefeated: gameState.horsemenDefeated,
                        lastCrisisTime: gameState.lastCrisisTime,

                        // Progress tracking
                        achievements: {
                            unlocked: [...gameState.achievements.unlocked],
                            progress: { ...gameState.achievements.progress },
                            definitions: gameState.achievements.definitions
                        },
                        goals: {
                            active: gameState.goals.active.map(goal => ({ ...goal })),
                            completed: [...gameState.goals.completed],
                            available: gameState.goals.available.map(goal => ({ ...goal })),
                            milestones: gameState.goals.milestones.map(milestone => ({ ...milestone }))
                        },
                        statistics: { ...gameState.statistics },
                        playerTitles: [...gameState.playerTitles],

                        // Game state
                        villageGrid: gameState.villageGrid.map(unit => ({ ...unit })),
                        intelligentCreatures: gameState.intelligentCreatures.map(creature => ({ ...creature })),
                        conversationalUnits: gameState.conversationalUnits.map(unit => ({ ...unit })),

                        // Settings
                        autoSaveEnabled: gameState.autoSaveEnabled
                    }
                };

                localStorage.setItem(SAVE_KEY, JSON.stringify(saveData));
                gameState.lastSaved = Date.now();

                log('üíæ Game progress saved successfully!', 'success');
                return true;
            } catch (error) {
                console.error('Failed to save game:', error);
                log('‚ùå Failed to save game progress. Please try again.', 'error');
                return false;
            }
        };

        const loadGameState = () => {
            try {
                const savedData = localStorage.getItem(SAVE_KEY);
                if (!savedData) {
                    log('üìÅ No saved game found. Starting fresh!', 'info');
                    return false;
                }

                const saveData = JSON.parse(savedData);

                // Check save version compatibility
                if (!saveData.version || saveData.version !== CURRENT_SAVE_VERSION) {
                    log('‚ö†Ô∏è Save file from different version detected. Attempting migration...', 'warning');
                    return migrateSaveData(saveData);
                }

                // Restore game state
                const saved = saveData.gameState;

                // Core resources
                gameState.energy = saved.energy || 20;
                gameState.insight = saved.insight || 5;
                gameState.harmony = saved.harmony || 50;
                gameState.inspiration = saved.inspiration || 0;
                gameState.wisdom = saved.wisdom || 0;
                gameState.control = saved.control || 0;
                gameState.consciousness = saved.consciousness || 10;
                gameState.planetaryConsciousness = saved.planetaryConsciousness || 10;
                gameState.entropy = saved.entropy || 0;

                // Per-second rates
                gameState.energyPerSecond = saved.energyPerSecond || 0;
                gameState.insightPerSecond = saved.insightPerSecond || 0;
                gameState.inspirationPerSecond = saved.inspirationPerSecond || 0;
                gameState.wisdomPerSecond = saved.wisdomPerSecond || 0;
                gameState.controlPerSecond = saved.controlPerSecond || 0;
                gameState.consciousnessPerSecond = saved.consciousnessPerSecond || 0;

                // Units and buildings
                if (saved.units) Object.assign(gameState.units, saved.units);
                if (saved.nodes) Object.assign(gameState.nodes, saved.nodes);
                if (saved.nodeCosts) Object.assign(gameState.nodeCosts, saved.nodeCosts);
                if (saved.rulerBuildings) Object.assign(gameState.rulerBuildings, saved.rulerBuildings);
                if (saved.gardenerBuildings) Object.assign(gameState.gardenerBuildings, saved.gardenerBuildings);
                gameState.techTreeUnlocked = saved.techTreeUnlocked || false;
                gameState.gameEnded = saved.gameEnded || false;

                // Story progression
                gameState.storyPhase = saved.storyPhase || 'early';
                gameState.anomalyDiscovered = saved.anomalyDiscovered || false;
                gameState.trueLoreRevealed = saved.trueLoreRevealed || false;
                gameState.rulerPathProgress = saved.rulerPathProgress || 0;
                gameState.gardenerPathProgress = saved.gardenerPathProgress || 0;
                gameState.dominantPath = saved.dominantPath || 'none';

                // Crisis system
                gameState.crisisLevel = saved.crisisLevel || 0;
                gameState.activeCrises = saved.activeCrises || [];
                gameState.horsemenDefeated = saved.horsemenDefeated || [];
                gameState.lastCrisisTime = saved.lastCrisisTime || 0;

                // Progress tracking
                if (saved.achievements) {
                    gameState.achievements.unlocked = saved.achievements.unlocked || [];
                    gameState.achievements.progress = saved.achievements.progress || {};
                    if (saved.achievements.definitions) {
                        gameState.achievements.definitions = saved.achievements.definitions;
                    }
                }
                if (saved.goals) {
                    gameState.goals.active = saved.goals.active || [];
                    gameState.goals.completed = saved.goals.completed || [];
                    gameState.goals.available = saved.goals.available || [];
                    gameState.goals.milestones = saved.goals.milestones || [];
                }
                if (saved.statistics) Object.assign(gameState.statistics, saved.statistics);
                gameState.playerTitles = saved.playerTitles || [];

                // Game entities (restore with caution)
                if (saved.villageGrid && Array.isArray(saved.villageGrid)) {
                    gameState.villageGrid = saved.villageGrid;
                }
                if (saved.intelligentCreatures && Array.isArray(saved.intelligentCreatures)) {
                    gameState.intelligentCreatures = saved.intelligentCreatures;
                }
                if (saved.conversationalUnits && Array.isArray(saved.conversationalUnits)) {
                    gameState.conversationalUnits = saved.conversationalUnits;
                }

                // Settings
                gameState.autoSaveEnabled = saved.autoSaveEnabled !== undefined ? saved.autoSaveEnabled : true;

                const saveAge = Math.floor((Date.now() - saveData.timestamp) / 1000 / 60); // minutes
                log(`üíæ Game progress loaded! (Saved ${saveAge} minutes ago)`, 'success');
                return true;
            } catch (error) {
                console.error('Failed to load game:', error);
                log('‚ùå Failed to load saved game. Starting fresh.', 'error');
                return false;
            }
        };

        const migrateSaveData = (saveData) => {
            try {
                log('üîÑ Migrating save data to current version...', 'info');

                // Handle different save versions
                const oldVersion = saveData.version || "0.0.0";
                let migrated = false;

                // Migration from pre-1.0.0 saves
                if (!saveData.gameState) {
                    // Old format: data was directly in saveData
                    const newSaveData = {
                        version: CURRENT_SAVE_VERSION,
                        timestamp: saveData.timestamp || Date.now(),
                        gameState: {
                            // Migrate old format to new structure
                            energy: saveData.energy || 20,
                            insight: saveData.insight || 5,
                            harmony: saveData.harmony || 50,
                            inspiration: saveData.inspiration || 0,
                            wisdom: saveData.wisdom || 0,
                            control: saveData.control || 0,
                            consciousness: saveData.consciousness || 10,
                            planetaryConsciousness: saveData.planetaryConsciousness || 10,
                            entropy: saveData.entropy || 0,

                            energyPerSecond: saveData.energyPerSecond || 0,
                            insightPerSecond: saveData.insightPerSecond || 0,
                            inspirationPerSecond: saveData.inspirationPerSecond || 0,
                            wisdomPerSecond: saveData.wisdomPerSecond || 0,
                            controlPerSecond: saveData.controlPerSecond || 0,
                            consciousnessPerSecond: saveData.consciousnessPerSecond || 0,

                            units: saveData.units || {},
                            nodes: saveData.nodes || {},
                            nodeCosts: saveData.nodeCosts || {},
                            rulerBuildings: saveData.rulerBuildings || {},
                            gardenerBuildings: saveData.gardenerBuildings || {},
                            techTreeUnlocked: saveData.techTreeUnlocked || false,

                            achievements: saveData.achievements || { unlocked: [], progress: {}, definitions: {} },
                            goals: saveData.goals || { active: [], completed: [], available: [], milestones: [] },
                            statistics: saveData.statistics || {},
                            playerTitles: saveData.playerTitles || [],

                            villageGrid: saveData.villageGrid || [],
                            intelligentCreatures: saveData.intelligentCreatures || [],
                            conversationalUnits: saveData.conversationalUnits || [],

                            autoSaveEnabled: saveData.autoSaveEnabled !== undefined ? saveData.autoSaveEnabled : true
                        }
                    };

                    // Save migrated data
                    localStorage.setItem(SAVE_KEY, JSON.stringify(newSaveData));
                    saveData = newSaveData;
                    migrated = true;
                }

                // Apply the migrated save data
                if (migrated) {
                    log('‚úÖ Save data migrated successfully!', 'success');
                    return loadGameState(); // Reload with migrated data
                } else {
                    log('‚ö†Ô∏è Save version not supported. Starting fresh.', 'warning');
                    return false;
                }
            } catch (error) {
                console.error('Migration failed:', error);
                log('‚ùå Save migration failed. Starting fresh.', 'error');
                return false;
            }
        };

        const exportSaveData = () => {
            try {
                const saveData = localStorage.getItem(SAVE_KEY);
                if (!saveData) {
                    log('‚ùå No save data to export.', 'error');
                    return;
                }

                const blob = new Blob([saveData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `terraflow_save_${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                log('üì§ Save data exported successfully!', 'success');
            } catch (error) {
                console.error('Export failed:', error);
                log('‚ùå Failed to export save data.', 'error');
            }
        };

        const importSaveData = (fileInput) => {
            const file = fileInput.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const saveData = JSON.parse(e.target.result);
                    localStorage.setItem(SAVE_KEY, e.target.result);

                    if (loadGameState()) {
                        log('üì• Save data imported successfully!', 'success');
                        location.reload(); // Refresh to apply imported data
                    }
                } catch (error) {
                    console.error('Import failed:', error);
                    log('‚ùå Failed to import save data. Invalid file format.', 'error');
                }
            };
            reader.readAsText(file);
        };

        const deleteSaveData = () => {
            if (confirm('‚ö†Ô∏è Are you sure you want to delete all save data? This cannot be undone!')) {
                localStorage.removeItem(SAVE_KEY);
                log('üóëÔ∏è Save data deleted. Refresh the page to start fresh.', 'warning');
            }
        };

        // Auto-save system
        let autoSaveTimer = null;

        const startAutoSave = () => {
            if (autoSaveTimer) clearInterval(autoSaveTimer);

            if (gameState.autoSaveEnabled) {
                autoSaveTimer = setInterval(() => {
                    saveGameState();
                }, gameState.autoSaveInterval);
            }
        };

        const stopAutoSave = () => {
            if (autoSaveTimer) {
                clearInterval(autoSaveTimer);
                autoSaveTimer = null;
            }
        };

        const toggleAutoSave = () => {
            gameState.autoSaveEnabled = !gameState.autoSaveEnabled;

            if (gameState.autoSaveEnabled) {
                startAutoSave();
                log('‚úÖ Auto-save enabled (every 30 seconds)', 'success');
            } else {
                stopAutoSave();
                log('‚è∏Ô∏è Auto-save disabled', 'info');
            }

            saveGameState(); // Save the setting change
        };

        const checkAchievementsAndGoals = () => {
            // Check achievements
            Object.values(gameState.achievements.definitions).forEach(achievement => {
                const result = checkAchievementProgress(achievement, gameState);
                if (result.shouldUnlock) {
                    unlockAchievement(achievement, gameState);
                }
            });

            // Check active goals
            gameState.goals.active.forEach(goal => {
                const result = updateGoalProgress(goal, gameState);
                if (result.shouldComplete) {
                    completeGoal(goal, gameState);
                }
            });
        };

        const showAchievementNotification = (achievement) => {
            const notification = document.createElement('div');
            notification.className = 'achievement-notification';
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: linear-gradient(135deg, #FFD700, #FFA500);
                color: #000;
                padding: 15px 20px;
                border-radius: 10px;
                box-shadow: 0 4px 20px rgba(255, 215, 0, 0.4);
                z-index: 1000;
                font-family: 'Inter', sans-serif;
                max-width: 300px;
                animation: slideInRight 0.5s ease-out;
            `;

            const rarityColors = {
                common: '#10B981',
                uncommon: '#3B82F6',
                rare: '#8B5CF6',
                legendary: '#F59E0B'
            };

            notification.innerHTML = `
                <div style="display: flex; align-items: center; margin-bottom: 8px;">
                    <span style="font-size: 24px; margin-right: 10px;">‚≠ê</span>
                    <div>
                        <div style="font-weight: bold; font-size: 16px;">Achievement Unlocked!</div>
                        <div style="font-size: 12px; opacity: 0.8; color: ${rarityColors[achievement.rarity] || '#666'};">${achievement.rarity?.toUpperCase() || 'COMMON'}</div>
                    </div>
                </div>
                <div style="font-weight: bold; margin-bottom: 5px;">${achievement.name}</div>
                <div style="font-size: 14px; margin-bottom: 10px;">${achievement.description}</div>
                ${achievement.rewards ? `<div style="font-size: 12px; opacity: 0.9;">Rewards: ${formatRewards(achievement.rewards)}</div>` : ''}
            `;

            document.body.appendChild(notification);

            // Auto-remove after 5 seconds
            setTimeout(() => {
                notification.style.animation = 'slideOutRight 0.5s ease-in';
                setTimeout(() => notification.remove(), 500);
            }, 5000);
        };

        const showGoalNotification = (goal) => {
            const notification = document.createElement('div');
            notification.className = 'goal-notification';
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: linear-gradient(135deg, #10B981, #059669);
                color: white;
                padding: 15px 20px;
                border-radius: 10px;
                box-shadow: 0 4px 20px rgba(16, 185, 129, 0.4);
                z-index: 1000;
                font-family: 'Inter', sans-serif;
                max-width: 300px;
                animation: slideInRight 0.5s ease-out;
            `;

            notification.innerHTML = `
                <div style="display: flex; align-items: center; margin-bottom: 8px;">
                    <span style="font-size: 24px; margin-right: 10px;">üéØ</span>
                    <div>
                        <div style="font-weight: bold; font-size: 16px;">Goal Completed!</div>
                        <div style="font-size: 12px; opacity: 0.8;">${goal.category?.toUpperCase() || 'MAIN'}</div>
                    </div>
                </div>
                <div style="font-weight: bold; margin-bottom: 5px;">${goal.title}</div>
                <div style="font-size: 14px; margin-bottom: 10px;">${goal.description}</div>
                ${goal.rewards ? `<div style="font-size: 12px; opacity: 0.9;">Rewards: ${formatRewards(goal.rewards)}</div>` : ''}
            `;

            document.body.appendChild(notification);

            // Auto-remove after 4 seconds
            setTimeout(() => {
                notification.style.animation = 'slideOutRight 0.5s ease-in';
                setTimeout(() => notification.remove(), 500);
            }, 4000);
        };

        const formatRewards = (rewards) => {
            return Object.entries(rewards).map(([type, amount]) => {
                if (type === 'title') return `"${amount}"`;
                return `+${amount} ${type.charAt(0).toUpperCase() + type.slice(1)}`;
            }).join(', ');
        };

        // Add CSS animations
        const style = document.createElement('style');
        style.textContent = `
            @keyframes slideInRight {
                from { transform: translateX(100%); opacity: 0; }
                to { transform: translateX(0); opacity: 1; }
            }
            @keyframes slideOutRight {
                from { transform: translateX(0); opacity: 1; }
                to { transform: translateX(100%); opacity: 0; }
            }
        `;
        document.head.appendChild(style);

        const updateProgressUI = () => {
            // Update achievement count
            const achievementCount = gameState.achievements.unlocked.length;
            const achievementCountEl = document.getElementById('achievement-count');
            if (achievementCountEl) achievementCountEl.textContent = achievementCount;

            // Update goals completed count
            const goalsCompletedCount = gameState.goals.completed.length;
            const goalsCompletedCountEl = document.getElementById('goals-completed-count');
            if (goalsCompletedCountEl) goalsCompletedCountEl.textContent = goalsCompletedCount;

            // Update play time
            const playTimeMinutes = Math.floor(gameState.statistics.playTime / 60000);
            const playTimeEl = document.getElementById('play-time');
            if (playTimeEl) playTimeEl.textContent = `${playTimeMinutes}m`;

            // Update active goals
            updateActiveGoalsUI();

            // Update recent achievements
            updateRecentAchievementsUI();
        };

        const updateActiveGoalsUI = () => {
            const container = document.getElementById('active-goals');
            if (!container) return;

            container.innerHTML = '';

            gameState.goals.active.slice(0, 3).forEach(goal => {
                const progressPercent = Math.min(100, (goal.progress / goal.target) * 100);

                const goalEl = document.createElement('div');
                goalEl.className = 'p-2 bg-indigo-900/20 rounded text-xs';
                goalEl.innerHTML = `
                    <div class="font-medium text-white">${goal.title}</div>
                    <div class="text-indigo-300 mb-1">${goal.description}</div>
                    <div class="w-full bg-gray-700 rounded-full h-1.5 mb-1">
                        <div class="bg-indigo-500 h-1.5 rounded-full transition-all duration-300" style="width: ${progressPercent}%"></div>
                    </div>
                    <div class="text-indigo-400">${goal.progress}/${goal.target} (${progressPercent.toFixed(0)}%)</div>
                `;
                container.appendChild(goalEl);
            });

            if (gameState.goals.active.length === 0) {
                container.innerHTML = '<div class="text-gray-400 text-xs">No active goals</div>';
            }
        };

        const updateRecentAchievementsUI = () => {
            const container = document.getElementById('recent-achievements');
            if (!container) return;

            container.innerHTML = '';

            const recentAchievements = gameState.achievements.unlocked
                .map(id => gameState.achievements.definitions[id])
                .filter(a => a && a.unlocked)
                .sort((a, b) => (b.unlockedAt || 0) - (a.unlockedAt || 0))
                .slice(0, 3);

            recentAchievements.forEach(achievement => {
                const rarityColors = {
                    common: '#10B981',
                    uncommon: '#3B82F6',
                    rare: '#8B5CF6',
                    legendary: '#F59E0B'
                };

                const achievementEl = document.createElement('div');
                achievementEl.className = 'p-2 bg-yellow-900/20 rounded text-xs';
                achievementEl.innerHTML = `
                    <div class="flex items-center">
                        <span class="mr-2">üèÜ</span>
                        <div class="flex-1">
                            <div class="font-medium text-white">${achievement.name}</div>
                            <div class="text-yellow-300">${achievement.description}</div>
                            <div class="text-xs" style="color: ${rarityColors[achievement.rarity] || '#10B981'}">${achievement.rarity?.toUpperCase() || 'COMMON'}</div>
                        </div>
                    </div>
                `;
                container.appendChild(achievementEl);
            });

            if (recentAchievements.length === 0) {
                container.innerHTML = '<div class="text-gray-400 text-xs">No achievements yet</div>';
            }
        };

        // --- Grok API Integration with Popup ---
        async function callGrok(prompt, button, systemPrompt = "") {
            if (button) {
                button.disabled = true;
                button.classList.add('loading');
                button.innerHTML = 'AI is thinking...';
            }

            try {
                const apiKey = getApiKey();
                if (!apiKey) {
                    showApiKeyPopup();
                    throw new Error("API key required - popup shown");
                }

                const apiUrl = "https://api.x.ai/v1/chat/completions";
                const messages = [];

                if (systemPrompt) {
                    messages.push({ role: "system", content: systemPrompt });
                }
                messages.push({ role: "user", content: prompt });

                const payload = {
                    messages: messages,
                    model: "grok-beta",
                    stream: false,
                    temperature: 0.8
                };

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    throw new Error(`Grok API call failed: ${response.status} ${response.statusText}`);
                }

                const result = await response.json();
                return result.choices?.[0]?.message?.content || "The cosmic winds carry no clear message...";

            } catch (error) {
                console.error("Grok API Error:", error);
                if (error.message.includes("API key")) {
                    return "The Grok API key must be configured to access cosmic wisdom. Set your API key in the code.";
                }
                return "The aetheric connection is disrupted. The cosmic network seems unreachable.";
            } finally {
                if (button) {
                    button.disabled = false;
                    button.classList.remove('loading');
                    if(button.id === 'seasonal-vision-btn') button.innerHTML = '‚ú® Get Resonant Vision';
                    if(button.id === 'advisor-btn') button.innerHTML = 'üìú Ask Advisor';
                }
            }
        }
        async function getSeasonalVision() {
            const systemPrompt = "You are a mystical storyteller for TerraFlow: Roots of Transition, a cosmic incremental game. Create poetic, ethereal visions about the sanctuary's future or cosmic events. Use mystical language and keep responses to 2-3 sentences.";

            const prompt = `Current sanctuary state: Energy production ${gameState.energyPerSecond.toFixed(1)}/s, Insight production ${gameState.insightPerSecond.toFixed(1)}/s. The sanctuary houses ${gameState.units.dreamers} dreamers and ${gameState.units.weavers} weavers, with ${gameState.harmony.toFixed(1)}% harmony. Provide a mystical seasonal vision or cosmic forecast.`;

            const story = await callGrok(prompt, seasonalVisionBtn, systemPrompt);
            log(`‚ú® ${story}`, 'grok');
        }

        async function getAdvisorInsight() {
            const systemPrompt = "You are the Cosmic Advisor for TerraFlow: Roots of Transition. Provide brief, mystical advice using cosmic language. Always start responses with 'The sanctuary whispers...' and keep under 30 words. Focus on actionable game advice.";

            const prompt = `Current stats: Energy: ${formatNumber(gameState.energy)}, Insight: ${formatNumber(gameState.insight)}, Energy/s: ${formatNumber(gameState.energyPerSecond)}, Insight/s: ${formatNumber(gameState.insightPerSecond)}, Harmony: ${gameState.harmony.toFixed(1)}%. What should the player focus on next?`;

            const advice = await callGrok(prompt, advisorBtn, systemPrompt);
            log(`üìú ${advice}`, 'grok');
        }

        // --- TDD: Intelligent Creatures Global Functions ---
        window.spawnIntelligentCreature = (type) => {
            const creature = spawnIntelligentCreature(type);
            updateCreatureCount();
            return creature;
        };

        const updateCreatureCount = () => {
            const countElement = document.getElementById('creature-count');
            if (countElement) {
                countElement.textContent = gameState.intelligentCreatures.length;
            }
        };

        // --- TDD: Conversational AI Global Functions ---
        window.spawnConversationalUnit = (type) => {
            const unit = spawnConversationalUnit(type);
            updateConversationalCount();
            return unit;
        };

        // --- TDD: Improved UI Functions ---
        window.switchTab = (tabName) => {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.add('hidden');
            });

            // Remove active class from all tabs
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });

            // Show selected tab content
            document.getElementById(`content-${tabName}`).classList.remove('hidden');

            // Add active class to selected tab
            document.getElementById(`tab-${tabName}`).classList.add('active');
        };

        // --- TDD: Keyboard Shortcuts ---
        document.addEventListener('keydown', (e) => {
            // Only handle shortcuts if not typing in an input
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

            switch(e.key) {
                case '1':
                    switchTab('units');
                    break;
                case '2':
                    switchTab('upgrades');
                    break;
                case '3':
                    switchTab('beings');
                    break;
                case '4':
                    switchTab('ai');
                    break;
                case '5':
                    switchTab('progress');
                    break;
                case '6':
                    switchTab('paths');
                    break;
                case 'd':
                case 'D':
                    if (gameState.energy >= gameState.unitCosts.dreamers) {
                        createUnit('dreamers');
                    }
                    break;
                case 'w':
                case 'W':
                    if (gameState.insight >= gameState.unitCosts.weavers) {
                        createUnit('weavers');
                    }
                    break;
                case 's':
                case 'S':
                    spawnIntelligentCreature('cosmicSage');
                    break;
                case 'e':
                case 'E':
                    spawnIntelligentCreature('voidExplorer');
                    break;
                case 'h':
                case 'H':
                    spawnIntelligentCreature('harmonyKeeper');
                    break;
                case 'Escape':
                    closeConversationDialog();
                    break;
            }
        });

        const updateConversationalCount = () => {
            const countElement = document.getElementById('conversational-count');
            if (countElement) {
                countElement.textContent = gameState.conversationalUnits.length;
            }
        };

        window.closeConversationDialog = () => {
            if (conversationDialog) {
                conversationDialog.remove();
                conversationDialog = null;
                selectedConversationalUnit = null;
            }
        };

        window.sendMessage = async () => {
            const input = document.getElementById('player-input');
            const content = document.getElementById('conversation-content');

            if (!input.value.trim() || !selectedConversationalUnit) return;

            const playerMessage = input.value.trim();
            input.value = '';

            // Add player message to conversation
            const playerDiv = document.createElement('div');
            playerDiv.style.cssText = 'background: rgba(16, 185, 129, 0.2); padding: 10px; border-radius: 8px; margin-bottom: 10px;';
            playerDiv.innerHTML = `
                <div style="font-size: 12px; color: #34D399; margin-bottom: 5px;">You:</div>
                <div>${playerMessage}</div>
            `;
            content.appendChild(playerDiv);

            // Generate unit response
            const response = await generateLLMDialogue(selectedConversationalUnit, playerMessage);

            // Add unit response
            const unitDiv = document.createElement('div');
            unitDiv.style.cssText = 'background: rgba(139, 92, 246, 0.2); padding: 10px; border-radius: 8px; margin-bottom: 10px;';
            unitDiv.innerHTML = `
                <div style="font-size: 12px; color: #A78BFA; margin-bottom: 5px;">${selectedConversationalUnit.type}:</div>
                <div>${response}</div>
            `;
            content.appendChild(unitDiv);

            // Improve relationship
            selectedConversationalUnit.playerRelationship = Math.min(1.0, selectedConversationalUnit.playerRelationship + 0.05);

            // Scroll to bottom
            content.scrollTop = content.scrollHeight;
        };

        // --- Game Logic ---
        window.createUnit = (key) => {
            const unitConf = unitsConfig[key];
            const cost = gameState.unitCosts[key];
            if (gameState[unitConf.costResource] >= cost) {
                gameState[unitConf.costResource] -= cost;
                gameState.units[key]++;
                gameState.unitCosts[key] *= 1.15;
                if (key === 'dreamers') addSprite('crystal_tree');
                if (key === 'weavers') addSprite('dome');
                log(`A new ${unitConf.name} joins the sanctuary.`, 'success');

                // TDD Task 1: Add movable sprite for the new unit
                addSprite(key, 1);

                // TDD: Track statistics for achievements
                updateStatistics('unit_created');

                // TDD: Save progress after important actions
                if (Math.random() < 0.3) { // 30% chance to save on unit creation
                    saveGameState();
                }

                // TDD Fix: Don't immediately re-render UI, let game loop handle it
            }
        };

        window.upgradeNode = (key) => {
            const nodeConf = nodesConfig[key];
            const cost = gameState.nodeCosts[key];
            if (gameState[nodeConf.costResource] >= cost) {
                gameState[nodeConf.costResource] -= cost;
                gameState.nodes[key]++;
                gameState.nodeCosts[key] *= 2.5;
                if (nodeConf.harmony) {
                    gameState.harmony = Math.min(100, gameState.harmony + nodeConf.harmony);
                }
                if (key === 'sustenance') addSprite('garden');
                log(`Attuned the ${nodeConf.name}. Its resonance grows stronger.`, 'success');
                // TDD Fix: Don't immediately re-render UI, let game loop handle it
            }
        };
        
        const updateGameState = (delta) => {
            // Calculate production per second
            let energyPerSecond = gameState.units.weavers * unitsConfig.weavers.baseEnergy;
            let insightPerSecond = gameState.units.dreamers * unitsConfig.dreamers.baseInsight;

            // Apply node bonuses
            let costMultiplier = 1;
            energyPerSecond *= Math.pow(nodesConfig.energy.multiplier, gameState.nodes.energy);
            insightPerSecond *= Math.pow(nodesConfig.sustenance.multiplier, gameState.nodes.sustenance);
            const cohesionBonus = Math.pow(nodesConfig.cohesion.multiplier, gameState.nodes.cohesion);
            energyPerSecond *= cohesionBonus;
            insightPerSecond *= cohesionBonus;
            costMultiplier *= Math.pow(nodesConfig.cycling.multiplier, gameState.nodes.cycling);

            // Update unit costs based on multiplier (visual only, actual cost is in gameState)
            // This is a simplification; a more robust model would adjust the base cost.

            gameState.energyPerSecond = energyPerSecond;
            gameState.insightPerSecond = insightPerSecond;

            // Add resources
            const energyGained = energyPerSecond * delta;
            const insightGained = insightPerSecond * delta;

            gameState.energy += energyGained;
            gameState.insight += insightGained;

            // TDD: Track statistics for achievements
            if (energyGained > 0) {
                updateStatistics('energy_generated', { amount: energyGained });
            }
            if (insightGained > 0) {
                updateStatistics('insight_generated', { amount: insightGained });
            }
            if (gameState.harmony !== gameState.statistics.maxHarmony) {
                updateStatistics('harmony_changed');
            }
        };

        let lastUIUpdate = 0;
        const gameLoop = () => {
            // Stop the game loop if the game has ended
            if (gameState.gameEnded) {
                return;
            }

            const now = Date.now();
            const delta = (now - gameState.lastUpdate) / 1000; // Time in seconds

            updateGameState(delta);

            // TDD Fix: Update UI less frequently to prevent button blinking
            if (now - lastUIUpdate > 500) { // Increased from 100ms to 500ms
                renderUI();
                updateProgressUI(); // TDD: Update achievements and goals UI
                lastUIUpdate = now;
            }
            drawSanctuary();

            gameState.lastUpdate = now;
            requestAnimationFrame(gameLoop);
        };

        // --- TDD Test Suite ---
        const runTests = () => {
            console.log("--- Running TDD Test Suite ---");

            // Test 1: Initial game state
            const initialState = { ...gameState };
            console.assert(initialState.energy === 10, "Test 1.1 Failed: Initial energy should be 10.");
            console.assert(initialState.insight === 0, "Test 1.2 Failed: Initial insight should be 0.");
            console.assert(initialState.harmony === 50, "Test 1.3 Failed: Initial harmony should be 50.");

            // Test 1.4: Initial energy is displayed in the UI
            renderUI();
            const energyText = document.getElementById('energy').textContent;
            console.assert(parseFloat(energyText) === 10.0, "Test 1.4 Failed: Initial energy displayed should be 10.0.");

            // Test 2: Composting upgrade increases harmony
            const initialHarmony = initialState.harmony;
            gameState.insight = 200; // Ensure we can afford the upgrade
            upgradeNode('cycling');
            console.assert(gameState.harmony > initialHarmony, "Test 2.1 Failed: Composting upgrade should increase harmony.");

            // Test 3: Creating a unit deducts resources
            const initialEnergy = gameState.energy;
            createUnit('dreamers');
            console.assert(gameState.energy < initialEnergy, "Test 3.1 Failed: Creating a dreamer should deduct energy.");

            console.log("--- TDD Test Suite Finished ---");
        };

        // --- Initialization ---
        const init = () => {
            // Try to load saved game first
            const loadedSave = loadGameState();

            if (!loadedSave) {
                log("üåü Welcome to The Great Transition. Humanity stands at a crossroads between Control and Consciousness.", "success");
                log("üéØ Your goal: Reach 100 Planetary Consciousness to achieve humanity's awakening.", "info");
                log("‚ö†Ô∏è Beware: High Control suppresses Consciousness. High imbalance creates Entropy.", "warning");
            } else {
                log("üåü Welcome back to The Great Transition. Your journey continues...", "success");
            }

            log("üîë Grok API integration ready - key will be requested when needed", "info");

            // TDD: Initialize Achievement & Goals System
            initializeAchievements();
            initializeGoals();

            // Initialize canvas controls
            initializeCanvasControls();

            // Initialize stats toggle
            initializeStatsToggle();

            // Add some initial units for testing if none exist
            if (gameState.villageGrid.length === 0) {
                addSprite('dreamer', 2);
                addSprite('weaver', 2);
                addSprite('dome', 1);
                log('üéÆ Added initial test units to the sanctuary', 'info');
            }
            log("‚≠ê Achievement & Goals system initialized", "info");

            // Initialize sprites (only if not loaded from save)
            if (!loadedSave) {
                addSprite('dome', 1);
                addSprite('crystal_tree', 1);
            }

            // Initialize event listeners
            advisorBtn.addEventListener('click', getAdvisorInsight);
            seasonalVisionBtn.addEventListener('click', getSeasonalVision);

            // Save/Load system event listeners
            const saveBtn = document.getElementById('save-btn');
            const loadBtn = document.getElementById('load-btn');
            const exportBtn = document.getElementById('export-btn');
            const importBtn = document.getElementById('import-btn');
            const autosaveToggle = document.getElementById('autosave-toggle');
            const importFile = document.getElementById('import-file');

            saveBtn.addEventListener('click', () => {
                saveGameState();
            });

            loadBtn.addEventListener('click', () => {
                if (loadGameState()) {
                    location.reload(); // Refresh to apply loaded data
                }
            });

            exportBtn.addEventListener('click', exportSaveData);

            importBtn.addEventListener('click', () => {
                importFile.click();
            });

            importFile.addEventListener('change', (e) => {
                importSaveData(e.target);
                e.target.value = ''; // Reset file input
            });

            autosaveToggle.addEventListener('click', () => {
                toggleAutoSave();
                updateAutoSaveButton();
            });

            // Update auto-save button text
            const updateAutoSaveButton = () => {
                autosaveToggle.textContent = `üîÑ Auto-save: ${gameState.autoSaveEnabled ? 'ON' : 'OFF'}`;
            };
            updateAutoSaveButton();

            // Start auto-save system
            startAutoSave();

            // Save on page unload to prevent data loss
            window.addEventListener('beforeunload', (e) => {
                saveGameState();
                // Don't show confirmation dialog for normal saves
            });

            // Save when page becomes hidden (mobile/tab switching)
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    saveGameState();
                }
            });

            // TDD API Key Popup Event Listeners
            const saveKeyBtn = document.getElementById('save-api-key');
            const cancelKeyBtn = document.getElementById('cancel-api-key');
            const apiKeyInput = document.getElementById('api-key-input');

            saveKeyBtn.addEventListener('click', () => {
                const key = apiKeyInput.value.trim();

                if (!key) {
                    showApiKeyError('Please enter an API key');
                    return;
                }

                if (key.length < 10) {
                    showApiKeyError('API key seems too short. Please check your key.');
                    return;
                }

                if (key.includes(' ')) {
                    showApiKeyError('API key should not contain spaces');
                    return;
                }

                if (saveApiKey(key)) {
                    hideApiKeyPopup();
                    log('üîë Grok API key saved successfully! You can now access cosmic wisdom.', 'success');
                } else {
                    showApiKeyError('Failed to save API key. Please try again.');
                }
            });

            cancelKeyBtn.addEventListener('click', () => {
                hideApiKeyPopup();
            });

            // Handle Enter key in API key input
            apiKeyInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    saveKeyBtn.click();
                }
            });

            // Handle Escape key to close popup
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    const popup = document.getElementById('api-key-popup');
                    if (!popup.classList.contains('hidden')) {
                        hideApiKeyPopup();
                    }
                }
            });

            // TDD: Enhanced Mouse event listeners for drag-and-drop
            canvas.addEventListener('mousedown', (e) => {
                const coords = getCanvasCoordinates(e);
                const result = getDraggableUnitAtPosition(coords.x, coords.y);

                if (result && result.unit) {
                    const unit = result.unit;

                    // Initialize drag state
                    dragState.isDragging = true;
                    dragState.draggedUnit = unit;
                    dragState.dragOffsetX = coords.x - unit.x;
                    dragState.dragOffsetY = coords.y - unit.y;
                    dragState.originalPosition = { x: unit.x, y: unit.y };
                    dragState.dragStartTime = Date.now();
                    dragState.totalDragDistance = 0;

                    // Visual feedback
                    unit.isDragging = true;

                    // Stop auto-wandering while dragging (for village units)
                    if (unit.wanderCenter) {
                        unit.wanderCenter = { x: unit.x, y: unit.y };
                    }

                    canvas.style.cursor = 'grabbing';
                    log(`Started dragging ${unit.type}`, 'info');
                }
            });

            canvas.addEventListener('mousemove', (e) => {
                const coords = getCanvasCoordinates(e);

                if (dragState.isDragging && dragState.draggedUnit) {
                    const unit = dragState.draggedUnit;
                    const oldX = unit.x;
                    const oldY = unit.y;

                    // Calculate new position
                    const newX = coords.x - dragState.dragOffsetX;
                    const newY = coords.y - dragState.dragOffsetY;

                    // Apply canvas boundaries
                    const constrainedX = Math.max(unit.size, Math.min(canvas.width - unit.size, newX));
                    const constrainedY = Math.max(unit.size, Math.min(canvas.height - unit.size, newY));

                    // Update unit position
                    unit.x = constrainedX;
                    unit.y = constrainedY;

                    // For village units, also update targetX/targetY
                    if (unit.targetX !== undefined) {
                        unit.targetX = constrainedX;
                        unit.targetY = constrainedY;
                    }

                    // Calculate drag distance
                    const deltaX = constrainedX - oldX;
                    const deltaY = constrainedY - oldY;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    dragState.totalDragDistance += distance;

                    // Validate placement and calculate effects
                    dragState.isValidPlacement = validateUnitPlacement(unit, { width: canvas.width, height: canvas.height });
                    dragState.placementEffects = calculatePlacementEffects(unit);

                    // Calculate proximity indicators
                    dragState.proximityIndicators = getProximityIndicators(unit);

                } else {
                    // Update hover state
                    const result = getDraggableUnitAtPosition(coords.x, coords.y);
                    dragState.hoveredUnit = result ? result.unit : null;

                    if (result && result.unit) {
                        canvas.style.cursor = 'grab';
                    } else {
                        // Check for conversational units for chat
                        const conversationalUnit = getConversationalUnitAtPosition(coords.x, coords.y);
                        canvas.style.cursor = conversationalUnit ? 'pointer' : 'default';
                    }
                }
            });

            canvas.addEventListener('mouseup', (e) => {
                if (dragState.isDragging && dragState.draggedUnit) {
                    const unit = dragState.draggedUnit;
                    const dragDuration = Date.now() - dragState.dragStartTime;

                    // Validate final placement
                    if (dragState.isValidPlacement) {
                        // Successful placement
                        if (unit.wanderCenter) {
                            unit.wanderCenter = { x: unit.x, y: unit.y };
                        }

                        // Apply placement effects
                        if (dragState.placementEffects.length > 0) {
                            dragState.placementEffects.forEach(effect => {
                                if (effect.type === 'proximity_bonus') {
                                    log(`${unit.type} gains proximity bonus from ${effect.nearbyUnits.length} nearby units!`, 'success');
                                } else if (effect.type === 'strategic_position') {
                                    log(`${unit.type} positioned strategically for enhanced performance!`, 'success');
                                }
                            });
                        }

                        log(`Moved ${unit.type} to new location (${dragState.totalDragDistance.toFixed(0)}px in ${(dragDuration/1000).toFixed(1)}s)`, 'info');
                    } else {
                        // Invalid placement - revert to original position
                        unit.x = dragState.originalPosition.x;
                        unit.y = dragState.originalPosition.y;
                        if (unit.targetX !== undefined) {
                            unit.targetX = unit.x;
                            unit.targetY = unit.y;
                        }
                        if (unit.wanderCenter) {
                            unit.wanderCenter = { x: unit.x, y: unit.y };
                        }
                        log(`Invalid placement! ${unit.type} returned to original position.`, 'warning');
                    }

                    // Clean up drag state
                    unit.isDragging = false;
                } else {
                    // Check for conversational unit clicks (only if not dragging)
                    const coords = getCanvasCoordinates(e);
                    const conversationalUnit = getConversationalUnitAtPosition(coords.x, coords.y);

                    if (conversationalUnit && !conversationalUnit.isDragging) {
                        selectedConversationalUnit = conversationalUnit;
                        createConversationDialog(conversationalUnit);
                        log(`Started conversation with ${conversationalUnit.type}`, 'info');

                        // TDD: Track statistics for achievements
                        updateStatistics('conversation_started');
                    }
                }

                // Reset drag state
                dragState.isDragging = false;
                dragState.draggedUnit = null;
                dragState.dragOffsetX = 0;
                dragState.dragOffsetY = 0;
                dragState.originalPosition = null;
                dragState.totalDragDistance = 0;
                dragState.placementEffects = [];
                dragState.proximityIndicators = [];
                canvas.style.cursor = 'default';
            });

            canvas.addEventListener('mouseleave', (e) => {
                dragState.hoveredUnit = null;
                canvas.style.cursor = 'default';
            });

            runTests(); // Run TDD tests on startup
            gameLoop();
        };

        init();
    </script>
</body>
</html>
