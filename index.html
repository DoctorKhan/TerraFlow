<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Resonant Sanctuary: The Weaver</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            background-color: #0c0a1e; /* Deep cosmic blue */
        }
        .stat-card {
            background-color: rgba(18, 16, 46, 0.7); /* Dark blue/purple */
            backdrop-filter: blur(10px);
            transition: all 0.2s ease-in-out;
            border: 1px solid rgba(76, 71, 128, 0.5);
        }
        .module-card {
            background-color: #1c1944; /* Muted cosmic blue */
            transition: all 0.2s ease-in-out;
            border: 1px solid rgba(76, 71, 128, 0.5);
        }
        .unit-card {
             background-color: #2a275c;
        }
        .log-panel {
            height: 150px;
            background-color: rgba(10, 8, 28, 0.9);
            border-top: 1px solid rgba(76, 71, 128, 0.5);
        }
        canvas {
            border-radius: 0.75rem;
        }
        .grok-btn.loading, .grok-btn:disabled, button:disabled {
            cursor: not-allowed;
            background-color: #4a5568;
            opacity: 0.7;
        }

        /* TDD Fix: Custom scrollbar for log output */
        #log-output {
            scrollbar-width: thin;
            scrollbar-color: #4c1d95 #1e1b4b;
        }
        #log-output::-webkit-scrollbar {
            width: 8px;
        }
        #log-output::-webkit-scrollbar-track {
            background: #1e1b4b;
            border-radius: 4px;
        }
        #log-output::-webkit-scrollbar-thumb {
            background: #4c1d95;
            border-radius: 4px;
        }
        #log-output::-webkit-scrollbar-thumb:hover {
            background: #5b21b6;
        }

        /* Ensure log entries don't break layout */
        .log-entry {
            word-wrap: break-word;
            line-height: 1.4;
            margin-bottom: 0.25rem;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .log-entry {
            animation: fadeIn 0.5s ease-out;
        }
    </style>
</head>
<body class="text-indigo-100 flex flex-col h-screen">

    <!-- Top Bar -->
    <header class="w-full p-4 bg-[#1c1944] border-b border-indigo-900 shadow-lg z-10">
        <h1 class="text-2xl font-bold text-white">Resonant Sanctuary: The Weaver</h1>
    </header>

    <!-- Main Content -->
    <div class="flex flex-1 overflow-hidden">
        
        <!-- Left Panel: Units & Upgrades -->
        <aside class="w-1/3 max-w-sm p-4 overflow-y-auto bg-[#1c1944] border-r border-indigo-900 flex flex-col">
            <div>
                <h2 class="text-xl font-semibold mb-4 text-white">Create Units</h2>
                <div id="units-panel" class="space-y-4">
                    <!-- Unit creation cards will be injected here -->
                </div>
            </div>
            <div class="mt-6">
                <h2 class="text-xl font-semibold mb-4 text-white">Attune Nodes</h2>
                <div id="modules-panel" class="space-y-4">
                    <!-- Module cards will be injected here -->
                </div>
            </div>

            <!-- TDD: Intelligent Creatures Panel -->
            <div class="mt-6 flex-1">
                <h2 class="text-xl font-semibold mb-4 text-white">Intelligent Creatures</h2>
                <div class="space-y-3">
                    <button onclick="spawnIntelligentCreature('cosmicSage')"
                            class="w-full p-3 rounded-lg bg-gradient-to-r from-purple-600 to-purple-700 hover:from-purple-700 hover:to-purple-800 text-white font-medium transition-all duration-200 transform hover:scale-105">
                        üßô‚Äç‚ôÇÔ∏è Summon Cosmic Sage
                        <div class="text-xs text-purple-200 mt-1">Teaches and generates insight</div>
                    </button>

                    <button onclick="spawnIntelligentCreature('voidExplorer')"
                            class="w-full p-3 rounded-lg bg-gradient-to-r from-gray-700 to-gray-800 hover:from-gray-800 hover:to-gray-900 text-white font-medium transition-all duration-200 transform hover:scale-105">
                        üåå Awaken Void Explorer
                        <div class="text-xs text-gray-300 mt-1">Explores and discovers resources</div>
                    </button>

                    <button onclick="spawnIntelligentCreature('harmonyKeeper')"
                            class="w-full p-3 rounded-lg bg-gradient-to-r from-green-600 to-green-700 hover:from-green-700 hover:to-green-800 text-white font-medium transition-all duration-200 transform hover:scale-105">
                        ‚ú® Call Harmony Keeper
                        <div class="text-xs text-green-200 mt-1">Restores harmony and heals</div>
                    </button>

                    <div class="text-xs text-indigo-300 mt-3 p-2 bg-indigo-900/30 rounded">
                        <strong>Creatures:</strong> <span id="creature-count">0</span><br>
                        <em>Intelligent beings that make autonomous decisions and interact with your sanctuary.</em>
                    </div>
                </div>
            </div>
             <div class="mt-6 space-y-3">
                 <button id="advisor-btn" class="grok-btn w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg shadow-md transition-colors">
                    üìú Ask Advisor
                </button>
                 <button id="seasonal-vision-btn" class="grok-btn w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-4 rounded-lg shadow-md transition-colors">
                    ‚ú® Get Resonant Vision
                </button>
            </div>
        </aside>

        <!-- Center Panel: Village View & Stats -->
        <main class="flex-1 flex flex-col p-4">
            <!-- Stats Bar -->
            <div id="stats-bar" class="grid grid-cols-2 md:grid-cols-5 gap-4 mb-4">
                <!-- Stat cards will be injected here -->
            </div>

            <!-- Village Canvas -->
            <div class="flex-1 relative">
                 <canvas id="village-canvas" class="w-full h-full"></canvas>
            </div>
        </main>

    </div>

    <!-- Bottom Bar: Log - TDD Fixed Height with Scrolling -->
    <footer id="log-panel" class="w-full border-t border-indigo-900" style="height: 200px; min-height: 200px; max-height: 200px;">
        <div class="p-4 h-full flex flex-col">
            <h3 class="font-semibold text-lg mb-2 text-indigo-200 flex-shrink-0">Aetheric Log</h3>
            <div id="log-output" class="text-sm text-indigo-300 space-y-1 flex-1 overflow-y-auto pr-2"></div>
        </div>
    </footer>
    
    <!-- TDD Test Runner (Hidden) -->
    <div id="test-runner" style="display: none;"></div>

    <!-- TDD API Key Popup -->
    <div id="api-key-popup" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-gray-800 border border-indigo-600 p-6 rounded-lg max-w-md w-full mx-4 shadow-2xl">
            <h3 class="text-xl font-bold text-white mb-4">üîë Configure Grok API Key</h3>
            <p class="text-gray-300 mb-4">To access cosmic wisdom and AI insights, please enter your Grok API key:</p>
            <p class="text-sm text-indigo-300 mb-4">Get your API key from <a href="https://x.ai" target="_blank" class="text-blue-400 hover:text-blue-300 underline">x.ai</a></p>
            <input type="password" id="api-key-input" class="w-full p-3 bg-gray-700 text-white rounded mb-2 border border-gray-600 focus:border-indigo-500 focus:outline-none" placeholder="Enter your Grok API key...">
            <div id="api-key-error" class="text-red-400 text-sm mb-4 hidden"></div>
            <div class="flex gap-3">
                <button id="save-api-key" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white py-2 px-4 rounded transition-colors">
                    üíæ Save Key
                </button>
                <button id="cancel-api-key" class="flex-1 bg-gray-600 hover:bg-gray-700 text-white py-2 px-4 rounded transition-colors">
                    ‚ùå Cancel
                </button>
            </div>
        </div>
    </div>

    <script>
        // --- Canvas & DOM Elements ---
        const canvas = document.getElementById('village-canvas');
        const ctx = canvas.getContext('2d');
        const modulesPanel = document.getElementById('modules-panel');
        const unitsPanel = document.getElementById('units-panel');
        const statsBar = document.getElementById('stats-bar');
        const logOutput = document.getElementById('log-output');
        const seasonalVisionBtn = document.getElementById('seasonal-vision-btn');
        const advisorBtn = document.getElementById('advisor-btn');

        // --- Game State (Incremental Model) - TDD Races Expansion ---
        let gameState = {
            energy: 20,
            energyPerSecond: 0,
            insight: 5,
            insightPerSecond: 0,
            harmony: 50,
            units: {
                dreamers: 1,  // Start with 1 dreamer for immediate insight generation
                weavers: 1,   // Start with 1 weaver for immediate energy generation
                stellarNomads: 0,
                voidWhisperers: 0,
                crystalBeings: 0,
                plasmaDancers: 0,
                quantumSages: 0,
                nebulaShepherds: 0
            },
            unitCosts: {
                dreamers: 15,  // Slightly higher since we start with units
                weavers: 15,
                stellarNomads: 25,
                voidWhisperers: 40,
                crystalBeings: 60,
                plasmaDancers: 80,
                quantumSages: 120,
                nebulaShepherds: 200
            },
            unlockedRaces: ['human'], // Start with humans unlocked
            nodes: {
                sustenance: 0,
                energy: 0,
                cohesion: 0,
                cycling: 0,
            },
            nodeCosts: {
                sustenance: 100,
                energy: 100,
                cohesion: 500,
                cycling: 200,
            },
            villageGrid: [],
            stars: [],
            intelligentCreatures: [], // TDD: Intelligent creatures with AI behaviors
            lastUpdate: Date.now(),
        };

        // --- Game Config - TDD Races System ---
        const racesConfig = {
            human: { name: "Human", description: "The original inhabitants", color: '#8B5CF6', symbol: 'üë§', unlocked: true, tier: 1 },
            stellar: { name: "Stellar Nomads", description: "Wandering star-travelers", color: '#F59E0B', symbol: '‚≠ê', unlockCondition: { energy: 50, insight: 25 }, unlocked: false, tier: 2 },
            void: { name: "Void Whisperers", description: "Mysterious void entities", color: '#1F2937', symbol: 'üåë', unlockCondition: { harmony: 70, energy: 100 }, unlocked: false, tier: 3 },
            crystal: { name: "Crystal Beings", description: "Living crystalline entities", color: '#10B981', symbol: 'üíé', unlockCondition: { energy: 200, insight: 100 }, unlocked: false, tier: 3 },
            plasma: { name: "Plasma Dancers", description: "Pure energy beings", color: '#EF4444', symbol: 'üî•', unlockCondition: { energy: 500, harmony: 80 }, unlocked: false, tier: 4 },
            quantum: { name: "Quantum Sages", description: "Multi-dimensional beings", color: '#8B5CF6', symbol: 'üåÄ', unlockCondition: { insight: 500, harmony: 85 }, unlocked: false, tier: 5 },
            nebula: { name: "Nebula Shepherds", description: "Ancient star-birthers", color: '#A78BFA', symbol: 'üåå', unlockCondition: { energy: 1000, insight: 800, harmony: 95 }, unlocked: false, tier: 5 }
        };

        const unitsConfig = {
            dreamers: { name: "Dreamer", description: "Generates Insight through cosmic meditation.", baseInsight: 0.1, costResource: 'energy', race: 'human', special: 'dreamVision' },
            weavers: { name: "Weaver", description: "Generates Energy by weaving cosmic threads.", baseEnergy: 0.1, costResource: 'insight', race: 'human', special: 'energyWeaving' },
            stellarNomads: { name: "Stellar Nomad", description: "Star-travelers generating Energy and Insight.", baseEnergy: 0.15, baseInsight: 0.05, costResource: 'energy', race: 'stellar', special: 'stellarNavigation' },
            voidWhisperers: { name: "Void Whisperer", description: "Void communers generating Insight and Harmony.", baseInsight: 0.08, baseHarmony: 0.02, costResource: 'insight', race: 'void', special: 'voidCommunion' },
            crystalBeings: { name: "Crystal Being", description: "Living crystals amplifying cosmic energy.", baseEnergy: 0.2, costResource: 'energy', race: 'crystal', special: 'crystalResonance' },
            plasmaDancers: { name: "Plasma Dancer", description: "Pure energy beings dancing through plasma.", baseEnergy: 0.3, costResource: 'insight', race: 'plasma', special: 'plasmaManipulation' },
            quantumSages: { name: "Quantum Sage", description: "Multi-dimensional beings with vast knowledge.", baseInsight: 0.5, costResource: 'energy', race: 'quantum', special: 'quantumEntanglement' },
            nebulaShepherds: { name: "Nebula Shepherd", description: "Ancient beings birthing stars.", baseEnergy: 0.8, baseInsight: 0.3, baseHarmony: 0.1, costResource: 'insight', race: 'nebula', special: 'starBirth' }
        };

        const nodesConfig = {
            sustenance: { name: "Sustenance Node", description: "Boosts Dreamer insight generation.", effectTarget: 'dreamers', multiplier: 1.2, costResource: 'energy' },
            energy: { name: "Energy Node", description: "Boosts Weaver energy generation.", effectTarget: 'weavers', multiplier: 1.2, costResource: 'insight' },
            cohesion: { name: "Cohesion Node", description: "Boosts all production.", effectTarget: 'all', multiplier: 1.1, costResource: 'energy' },
            cycling: { name: "Recycling Node", description: "Reduces the cost of all units and improves Harmony.", effectTarget: 'cost', multiplier: 0.95, harmony: 5, costResource: 'insight' },
        };

        // --- Utility Functions ---
        const formatNumber = (num) => {
            if (num < 1000) return num.toFixed(1);
            if (num < 1e6) return (num / 1e3).toFixed(2) + 'k';
            if (num < 1e9) return (num / 1e6).toFixed(2) + 'M';
            return (num / 1e9).toFixed(2) + 'B';
        };
        const log = (message, type = 'info') => {
            const colors = { info: 'text-indigo-300', success: 'text-teal-300', error: 'text-red-400', warning: 'text-amber-300', grok: 'text-purple-300' };
            const p = document.createElement('p');
            p.innerHTML = `[INFO] ${message}`;
            p.className = `${colors[type]} log-entry`;
            logOutput.prepend(p);
            if (logOutput.children.length > 20) {
                logOutput.lastChild.remove();
            }
        };

        // --- Rendering Functions ---
        const renderStats = () => {
            statsBar.innerHTML = `
                <div class="stat-card p-3 rounded-lg" title="Energy. Used to create Dreamers."><p class="text-sm text-indigo-300">‚ö° Energy</p><p class="text-xl font-bold text-yellow-300">${formatNumber(gameState.energy)}</p><p class="text-xs text-yellow-400">${formatNumber(gameState.energyPerSecond)}/s</p></div>
                <div class="stat-card p-3 rounded-lg" title="Insight. Used to create Weavers."><p class="text-sm text-indigo-300">üîÆ Insight</p><p class="text-xl font-bold text-purple-300">${formatNumber(gameState.insight)}</p><p class="text-xs text-purple-400">${formatNumber(gameState.insightPerSecond)}/s</p></div>
                <div class="stat-card p-3 rounded-lg" title="Dreamers generate Insight."><p class="text-sm text-indigo-300">Î™Ω Dreamer Units</p><p class="text-xl font-bold">${formatNumber(gameState.units.dreamers)}</p></div>
                <div class="stat-card p-3 rounded-lg" title="Weavers generate Energy."><p class="text-sm text-indigo-300">üï∏Ô∏è Weaver Units</p><p class="text-xl font-bold">${formatNumber(gameState.units.weavers)}</p></div>
                <div class="stat-card p-3 rounded-lg" title="Ecological balance."><p class="text-sm text-indigo-300">üåø Harmony</p><p class="text-xl font-bold text-green-400">${gameState.harmony.toFixed(1)}%</p></div>
            `;
        };

        // TDD Fix: Stable button rendering that doesn't recreate buttons
        let unitsInitialized = false;

        // TDD Races: Check for newly unlocked races
        const checkRaceUnlocks = () => {
            let newlyUnlocked = [];

            Object.entries(racesConfig).forEach(([raceKey, race]) => {
                if (!gameState.unlockedRaces.includes(raceKey) && !race.unlocked) {
                    if (!race.unlockCondition) {
                        gameState.unlockedRaces.push(raceKey);
                        race.unlocked = true;
                        newlyUnlocked.push(raceKey);
                    } else {
                        const canUnlock = Object.entries(race.unlockCondition).every(([resource, required]) => {
                            return gameState[resource] >= required;
                        });

                        if (canUnlock) {
                            gameState.unlockedRaces.push(raceKey);
                            race.unlocked = true;
                            newlyUnlocked.push(raceKey);
                            log(`üåü New race discovered: ${race.name}! ${race.description}`, 'success');
                        }
                    }
                }
            });

            return newlyUnlocked;
        };

        const renderUnits = () => {
            // Only create buttons once, then update their states
            if (!unitsInitialized) {
                createUnitButtons();
                unitsInitialized = true;
            }
            updateUnitButtonStates();
        };

        const createUnitButtons = () => {
            unitsPanel.innerHTML = '';
            for (const key in unitsConfig) {
                const unit = unitsConfig[key];
                const card = document.createElement('div');
                card.className = "unit-card p-4 rounded-lg border border-indigo-800";
                card.innerHTML = `
                    <h3 class="font-bold text-lg text-white">${unit.name}</h3>
                    <p class="text-sm text-indigo-200">${unit.description}</p>
                    <button class="unit-btn w-full mt-2 py-2 px-3 text-sm font-semibold rounded-md transition-colors"
                            data-unit="${key}">
                        Create ${unit.name}
                    </button>
                `;

                // Add stable event listener
                const button = card.querySelector('.unit-btn');
                button.addEventListener('click', () => {
                    if (!button.disabled) {
                        createUnit(key);
                    }
                });

                unitsPanel.appendChild(card);
            }
        };

        const updateUnitButtonStates = () => {
            for (const key in unitsConfig) {
                const unit = unitsConfig[key];
                const cost = gameState.unitCosts[key];
                const canAfford = gameState[unit.costResource] >= cost;

                const button = unitsPanel.querySelector(`[data-unit="${key}"]`);
                if (button) {
                    button.disabled = !canAfford;
                    button.textContent = `Create (Cost: ${formatNumber(cost)} ${unit.costResource})`;

                    // Update visual state without recreating
                    button.className = `unit-btn w-full mt-2 py-2 px-3 text-sm font-semibold rounded-md transition-colors ${
                        canAfford ? 'bg-green-600 hover:bg-green-700 text-white' : 'bg-gray-600 text-gray-400'
                    }`;
                }
            }
        };

        // TDD Fix: Stable node button rendering
        let nodesInitialized = false;

        const renderNodes = () => {
            // Only create buttons once, then update their states
            if (!nodesInitialized) {
                createNodeButtons();
                nodesInitialized = true;
            }
            updateNodeButtonStates();
        };

        const createNodeButtons = () => {
            modulesPanel.innerHTML = '';
            for (const key in nodesConfig) {
                const node = nodesConfig[key];
                const card = document.createElement('div');
                card.className = "module-card p-4 rounded-lg";
                card.innerHTML = `
                    <h3 class="font-bold text-lg text-white">
                        ${node.name} <span class="text-sm font-normal text-indigo-300 level-display" data-node="${key}">(Lvl 0)</span>
                    </h3>
                    <p class="text-sm text-indigo-200">${node.description}</p>
                    <button class="node-btn w-full mt-2 py-2 px-3 text-sm font-semibold rounded-md transition-colors"
                            data-node="${key}">
                        Attune ${node.name}
                    </button>
                `;

                // Add stable event listener
                const button = card.querySelector('.node-btn');
                button.addEventListener('click', () => {
                    if (!button.disabled) {
                        upgradeNode(key);
                    }
                });

                modulesPanel.appendChild(card);
            }
        };

        const updateNodeButtonStates = () => {
            for (const key in nodesConfig) {
                const node = nodesConfig[key];
                const cost = gameState.nodeCosts[key];
                const level = gameState.nodes[key];
                const canAfford = gameState[node.costResource] >= cost;

                // Update level display
                const levelDisplay = modulesPanel.querySelector(`[data-node="${key}"].level-display`);
                if (levelDisplay) {
                    levelDisplay.textContent = `(Lvl ${level})`;
                }

                // Update button
                const button = modulesPanel.querySelector(`button[data-node="${key}"]`);
                if (button) {
                    button.disabled = !canAfford;
                    button.textContent = `Attune (Cost: ${formatNumber(cost)} ${node.costResource})`;

                    // Update visual state without recreating
                    button.className = `node-btn w-full mt-2 py-2 px-3 text-sm font-semibold rounded-md transition-colors ${
                        canAfford ? 'bg-teal-600 hover:bg-teal-700 text-white' : 'bg-gray-600 text-gray-400'
                    }`;
                }
            }
        };

        const renderUI = () => {
            renderStats();
            renderUnits();
            renderNodes();
        }
        
        // --- Enhanced Drawing System with Movement ---
        let animationTime = 0;
        let particles = [];

        // TDD Task 1: Drag and Drop System
        let dragState = {
            isDragging: false,
            draggedUnit: null,
            dragOffsetX: 0,
            dragOffsetY: 0,
            hoveredUnit: null
        };

        let movementTrails = {};

        // TDD Task 2: Enhanced Visual Effects System
        let particlePool = {
            active: [],
            inactive: [],
            maxParticles: 200
        };

        let lightSources = [];
        let energyFlows = [];
        let screenEffects = {
            bloom: { enabled: true, intensity: 0.3 },
            vignette: { enabled: true, intensity: 0.2 }
        };

        const drawSanctuary = () => {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            animationTime += 0.016; // ~60fps

            // Enhanced Background with nebula effect
            drawBackground();

            // Enhanced Stars with twinkling
            drawStars();

            // Floating particles for magical atmosphere
            updateAndDrawParticles();

            // Energy/Insight flow lines
            drawEnergyFlows();

            // TDD Task 1: Update unit movement and draw enhanced sprites
            updateUnitMovement(0.016);
            updateMovementTrails();

            // TDD: Update intelligent creatures
            updateIntelligentCreatures(0.016);

            gameState.villageGrid.sort((a, b) => a.y - b.y);
            gameState.villageGrid.forEach(item => {
                const isHovered = dragState.hoveredUnit === item;
                const isDragged = dragState.draggedUnit === item;

                if (item.type === 'dome') drawEnhancedDome(item.x, item.y, item.size, item, isHovered, isDragged);
                else if (item.type === 'crystal_tree') drawEnhancedCrystalTree(item.x, item.y, item.size, item, isHovered, isDragged);
                else if (item.type === 'garden') drawEnhancedGarden(item.x, item.y, item.size, item, isHovered, isDragged);
                else drawMovableUnit(item, isHovered, isDragged);
            });

            // Draw movement trails
            drawMovementTrails();

            // TDD: Draw intelligent creatures
            drawIntelligentCreatures();

            // Ambient light effects
            drawAmbientEffects();
        };

        const drawBackground = () => {
            // Multi-layer gradient background
            const gradient1 = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient1.addColorStop(0, '#0a0820');
            gradient1.addColorStop(0.3, '#1a1040');
            gradient1.addColorStop(0.7, '#2a1860');
            gradient1.addColorStop(1, '#1c1944');
            ctx.fillStyle = gradient1;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Nebula clouds
            for (let i = 0; i < 3; i++) {
                const x = (canvas.width * 0.2) + (i * canvas.width * 0.3);
                const y = canvas.height * 0.3 + Math.sin(animationTime * 0.5 + i) * 20;
                const radius = 150 + Math.sin(animationTime * 0.3 + i) * 30;

                const nebulaGradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                nebulaGradient.addColorStop(0, `rgba(138, 43, 226, ${0.1 + Math.sin(animationTime + i) * 0.05})`);
                nebulaGradient.addColorStop(0.5, `rgba(75, 0, 130, ${0.05 + Math.sin(animationTime * 0.7 + i) * 0.03})`);
                nebulaGradient.addColorStop(1, 'rgba(75, 0, 130, 0)');

                ctx.fillStyle = nebulaGradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        };

        const drawStars = () => {
            // Initialize enhanced stars
            if (gameState.stars.length === 0) {
                for (let i = 0; i < 150; i++) {
                    gameState.stars.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        radius: Math.random() * 2 + 0.5,
                        alpha: 0.3 + Math.random() * 0.7,
                        twinkleSpeed: 0.5 + Math.random() * 2,
                        color: Math.random() > 0.8 ? 'rgba(200, 150, 255, ' : 'rgba(255, 255, 255, '
                    });
                }
            }

            gameState.stars.forEach(star => {
                const twinkle = 0.7 + Math.sin(animationTime * star.twinkleSpeed + star.x) * 0.3;
                const alpha = star.alpha * twinkle;

                // Star glow
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius * 2, 0, Math.PI * 2);
                ctx.fillStyle = star.color + (alpha * 0.2) + ')';
                ctx.fill();

                // Star core
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                ctx.fillStyle = star.color + alpha + ')';
                ctx.fill();
            });
        };

        const updateAndDrawParticles = () => {
            // Add new particles occasionally
            if (Math.random() < 0.3) {
                particles.push({
                    x: Math.random() * canvas.width,
                    y: canvas.height + 10,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: -Math.random() * 2 - 0.5,
                    life: 1.0,
                    decay: 0.005 + Math.random() * 0.01,
                    size: Math.random() * 3 + 1,
                    color: Math.random() > 0.5 ? 'rgba(167, 139, 250, ' : 'rgba(196, 181, 253, '
                });
            }

            // Update and draw particles
            particles = particles.filter(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life -= particle.decay;

                if (particle.life > 0) {
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size * particle.life, 0, Math.PI * 2);
                    ctx.fillStyle = particle.color + (particle.life * 0.6) + ')';
                    ctx.fill();
                    return true;
                }
                return false;
            });
        };

        // TDD Task 1: Enhanced sprite system with movement capabilities
        let spriteIdCounter = 0;

        const addSprite = (type, count = 1) => {
            for (let i = 0; i < count; i++) {
                const x = Math.random() * (canvas.width - 100) + 50;
                const y = Math.random() * (canvas.height - 100) + 50;
                const size = type === 'dome' ? 20 : type === 'crystal_tree' ? 25 : 15;

                // Determine if unit is movable based on type
                const movable = ['dreamer', 'weaver', 'stellarNomads', 'voidWhisperers',
                               'crystalBeings', 'plasmaDancers', 'quantumSages', 'nebulaShepherds'].includes(type);

                const sprite = {
                    type: type,
                    x: x,
                    y: y,
                    size: size,
                    movable: movable,
                    id: `${type}_${spriteIdCounter++}`,
                    animationOffset: Math.random() * Math.PI * 2,
                    pulseSpeed: 0.5 + Math.random() * 1.5,
                    // Movement properties for movable units
                    targetX: x,
                    targetY: y,
                    vx: 0,
                    vy: 0,
                    wanderCenter: { x: x, y: y },
                    wanderPhase: Math.random() * Math.PI * 2,
                    wanderRadius: 30 + Math.random() * 20
                };

                gameState.villageGrid.push(sprite);
            }
        };

        const drawEnhancedDome = (x, y, size, sprite, isHovered, isDragged) => {
            ctx.save();

            // Visual feedback for interaction states
            let scale = 1.0;
            let alpha = 1.0;
            let glowIntensity = 0.8;

            if (isDragged) {
                scale = 1.2;
                alpha = 0.9;
                glowIntensity = 1.2;
            } else if (isHovered) {
                scale = 1.1;
                glowIntensity = 1.0;
            }

            ctx.globalAlpha = alpha;
            ctx.translate(x, y);
            ctx.scale(scale, scale);

            const pulse = Math.sin(animationTime * (sprite.pulseSpeed || 1) + (sprite.animationOffset || 0)) * 0.15 + 1;
            const currentSize = size * pulse;

            // Layer 1: Outer energy field with orange/yellow theme
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            ctx.shadowColor = '#FBBF24';
            ctx.shadowBlur = 25 * glowIntensity;
            ctx.beginPath();
            ctx.arc(0, 0, currentSize * 1.8, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(251, 191, 36, 0.2)';
            ctx.fill();
            ctx.restore();

            // Layer 2: Main dome with enhanced orange gradient
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize);
            gradient.addColorStop(0, 'rgba(255, 215, 77, 1.0)');
            gradient.addColorStop(0.6, 'rgba(245, 158, 11, 0.9)');
            gradient.addColorStop(1, 'rgba(217, 119, 6, 0.7)');

            ctx.shadowColor = '#FBBF24';
            ctx.shadowBlur = 15 * glowIntensity;
            ctx.beginPath();
            ctx.arc(0, 0, currentSize, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();

            // Layer 3: Inner highlight
            ctx.save();
            ctx.globalCompositeOperation = 'overlay';
            const highlightGradient = ctx.createRadialGradient(-currentSize * 0.3, -currentSize * 0.3, 0, 0, 0, currentSize * 0.8);
            highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
            highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.beginPath();
            ctx.arc(0, 0, currentSize * 0.7, 0, Math.PI * 2);
            ctx.fillStyle = highlightGradient;
            ctx.fill();
            ctx.restore();

            // Layer 4: Energy orbs floating around dome
            for (let i = 0; i < 3; i++) {
                const angle = animationTime * 0.5 + (i * Math.PI * 2 / 3) + (sprite.animationOffset || 0);
                const orbX = Math.cos(angle) * (currentSize + 15);
                const orbY = Math.sin(angle) * (currentSize + 15);

                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                ctx.shadowColor = '#FBBF24';
                ctx.shadowBlur = 8;
                ctx.beginPath();
                ctx.arc(orbX, orbY, 3, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 215, 77, 0.8)';
                ctx.fill();
                ctx.restore();
            }

            ctx.shadowBlur = 0;
            ctx.restore();
        };

        const drawEnhancedCrystalTree = (x, y, size, sprite) => {
            const pulse = Math.sin(animationTime * sprite.pulseSpeed + sprite.animationOffset) * 0.15 + 1;
            const currentSize = size * pulse;

            // Crystal base/roots
            ctx.beginPath();
            ctx.ellipse(x, y, currentSize * 0.8, currentSize * 0.3, 0, 0, Math.PI * 2);
            const baseGradient = ctx.createRadialGradient(x, y, 0, x, y, currentSize * 0.8);
            baseGradient.addColorStop(0, `rgba(139, 92, 246, ${0.6 * pulse})`);
            baseGradient.addColorStop(1, `rgba(79, 70, 229, ${0.3 * pulse})`);
            ctx.fillStyle = baseGradient;
            ctx.fill();

            // Main crystal trunk with facets
            const trunkHeight = currentSize * 2;
            const trunkWidth = currentSize * 0.6;

            // Multiple crystal facets
            for (let i = 0; i < 6; i++) {
                const angle = (i * Math.PI) / 3;
                const facetX = x + Math.cos(angle) * (trunkWidth * 0.3);
                const facetY = y - trunkHeight * 0.5;

                ctx.beginPath();
                ctx.moveTo(facetX, y);
                ctx.lineTo(facetX + Math.cos(angle) * (trunkWidth * 0.2), facetY);
                ctx.lineTo(x, y - trunkHeight);
                ctx.lineTo(facetX - Math.cos(angle) * (trunkWidth * 0.2), facetY);
                ctx.closePath();

                const facetGradient = ctx.createLinearGradient(facetX, y, x, y - trunkHeight);
                const brightness = 0.5 + Math.sin(animationTime + angle) * 0.3;
                facetGradient.addColorStop(0, `rgba(139, 92, 246, ${brightness * pulse})`);
                facetGradient.addColorStop(0.5, `rgba(167, 139, 250, ${(brightness + 0.2) * pulse})`);
                facetGradient.addColorStop(1, `rgba(196, 181, 253, ${(brightness + 0.4) * pulse})`);

                ctx.fillStyle = facetGradient;
                ctx.fill();

                // Crystal edges with glow
                ctx.strokeStyle = `rgba(255, 255, 255, ${0.8 * pulse})`;
                ctx.lineWidth = 1;
                ctx.shadowColor = 'rgba(167, 139, 250, 0.8)';
                ctx.shadowBlur = 5;
                ctx.stroke();
                ctx.shadowBlur = 0;
            }

            // Crystal tip with intense glow
            ctx.beginPath();
            ctx.arc(x, y - trunkHeight, currentSize * 0.2, 0, Math.PI * 2);
            const tipGradient = ctx.createRadialGradient(x, y - trunkHeight, 0, x, y - trunkHeight, currentSize * 0.2);
            tipGradient.addColorStop(0, `rgba(255, 255, 255, ${0.9 * pulse})`);
            tipGradient.addColorStop(1, `rgba(196, 181, 253, ${0.6 * pulse})`);
            ctx.fillStyle = tipGradient;
            ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
            ctx.shadowBlur = 15;
            ctx.fill();
            ctx.shadowBlur = 0;

            // Energy wisps rising from crystal
            for (let i = 0; i < 2; i++) {
                const wispY = y - trunkHeight - 20 - (animationTime * 20 + i * 50) % 100;
                const wispX = x + Math.sin(animationTime + i) * 10;

                if (wispY > y - trunkHeight - 120) {
                    ctx.beginPath();
                    ctx.arc(wispX, wispY, 2, 0, Math.PI * 2);
                    const wispAlpha = 1 - ((y - trunkHeight - 20 - wispY) / 100);
                    ctx.fillStyle = `rgba(196, 181, 253, ${wispAlpha * 0.8})`;
                    ctx.fill();
                }
            }
        };
        
        const drawEnhancedGarden = (x, y, size, sprite) => {
            const pulse = Math.sin(animationTime * sprite.pulseSpeed + sprite.animationOffset) * 0.1 + 1;

            // Garden base with organic shape
            ctx.beginPath();
            for (let i = 0; i <= 16; i++) {
                const angle = (i / 16) * Math.PI * 2;
                const radius = size * (0.8 + Math.sin(angle * 3 + animationTime) * 0.2) * pulse;
                const px = x + Math.cos(angle) * radius;
                const py = y + Math.sin(angle) * radius * 0.6;

                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();

            const gardenGradient = ctx.createRadialGradient(x, y, 0, x, y, size);
            gardenGradient.addColorStop(0, `rgba(34, 197, 94, ${0.3 * pulse})`);
            gardenGradient.addColorStop(0.5, `rgba(22, 163, 74, ${0.2 * pulse})`);
            gardenGradient.addColorStop(1, `rgba(21, 128, 61, ${0.1 * pulse})`);
            ctx.fillStyle = gardenGradient;
            ctx.fill();

            // Magical flowers with different types
            const flowerTypes = [
                { color: '#fde047', glow: '#facc15', size: 4 }, // Golden
                { color: '#a78bfa', glow: '#8b5cf6', size: 3 }, // Purple
                { color: '#f472b6', glow: '#ec4899', size: 3.5 }, // Pink
                { color: '#34d399', glow: '#10b981', size: 3 }  // Emerald
            ];

            // Static flower positions based on sprite properties
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2 + sprite.animationOffset;
                const distance = (size * 0.6) + Math.sin(animationTime * 0.5 + i) * (size * 0.2);
                const flowerX = x + Math.cos(angle) * distance;
                const flowerY = y + Math.sin(angle) * distance * 0.6;

                const flowerType = flowerTypes[i % flowerTypes.length];
                const flowerPulse = Math.sin(animationTime * 2 + i) * 0.3 + 1;

                // Flower glow
                ctx.beginPath();
                ctx.arc(flowerX, flowerY, flowerType.size * flowerPulse * 1.5, 0, Math.PI * 2);
                ctx.fillStyle = flowerType.glow + '40'; // 25% opacity
                ctx.fill();

                // Flower petals
                for (let p = 0; p < 5; p++) {
                    const petalAngle = (p / 5) * Math.PI * 2 + animationTime * 0.1;
                    const petalX = flowerX + Math.cos(petalAngle) * flowerType.size * 0.8;
                    const petalY = flowerY + Math.sin(petalAngle) * flowerType.size * 0.8;

                    ctx.beginPath();
                    ctx.arc(petalX, petalY, flowerType.size * 0.6 * flowerPulse, 0, Math.PI * 2);
                    ctx.fillStyle = flowerType.color;
                    ctx.shadowColor = flowerType.glow;
                    ctx.shadowBlur = 8;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }

                // Flower center
                ctx.beginPath();
                ctx.arc(flowerX, flowerY, flowerType.size * 0.3, 0, Math.PI * 2);
                ctx.fillStyle = '#fbbf24';
                ctx.shadowColor = '#f59e0b';
                ctx.shadowBlur = 5;
                ctx.fill();
                ctx.shadowBlur = 0;
            }

            // Floating pollen particles
            for (let i = 0; i < 3; i++) {
                const pollenX = x + Math.sin(animationTime * 0.8 + i) * size * 0.8;
                const pollenY = y + Math.cos(animationTime * 0.6 + i) * size * 0.4 - 10;

                ctx.beginPath();
                ctx.arc(pollenX, pollenY, 1.5, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(251, 191, 36, ${0.6 + Math.sin(animationTime * 2 + i) * 0.4})`;
                ctx.fill();
            }
        };

        const drawEnergyFlows = () => {
            // Draw energy connections between structures
            const domes = gameState.villageGrid.filter(item => item.type === 'dome');
            const crystals = gameState.villageGrid.filter(item => item.type === 'crystal_tree');

            // Energy flows from crystals to domes (insight to energy conversion)
            crystals.forEach(crystal => {
                domes.forEach(dome => {
                    const distance = Math.sqrt((dome.x - crystal.x) ** 2 + (dome.y - crystal.y) ** 2);
                    if (distance < 200) { // Only connect nearby structures
                        drawEnergyBeam(crystal.x, crystal.y - crystal.size, dome.x, dome.y, 'insight');
                    }
                });
            });
        };

        const drawEnergyBeam = (x1, y1, x2, y2, type) => {
            const flowSpeed = animationTime * 3;
            const color = type === 'insight' ? 'rgba(167, 139, 250, ' : 'rgba(34, 197, 94, ';

            // Main beam
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.strokeStyle = color + '0.3)';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Animated energy particles along the beam
            const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
            const steps = Math.floor(distance / 20);

            for (let i = 0; i < steps; i++) {
                const progress = (i / steps + flowSpeed * 0.1) % 1;
                const x = x1 + (x2 - x1) * progress;
                const y = y1 + (y2 - y1) * progress;

                ctx.beginPath();
                ctx.arc(x, y, 2, 0, Math.PI * 2);
                ctx.fillStyle = color + (0.8 * (1 - progress)) + ')';
                ctx.shadowColor = color + '0.8)';
                ctx.shadowBlur = 5;
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        };

        const drawAmbientEffects = () => {
            // Ambient magical aura around the entire sanctuary
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const maxRadius = Math.max(canvas.width, canvas.height) * 0.6;

            const auraGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, maxRadius);
            auraGradient.addColorStop(0, 'rgba(167, 139, 250, 0)');
            auraGradient.addColorStop(0.7, `rgba(167, 139, 250, ${0.05 + Math.sin(animationTime * 0.5) * 0.02})`);
            auraGradient.addColorStop(1, 'rgba(75, 0, 130, 0)');

            ctx.fillStyle = auraGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Floating light orbs
            for (let i = 0; i < 5; i++) {
                const orbX = centerX + Math.sin(animationTime * 0.3 + i) * (canvas.width * 0.3);
                const orbY = centerY + Math.cos(animationTime * 0.2 + i) * (canvas.height * 0.2);
                const orbSize = 3 + Math.sin(animationTime + i) * 1;

                ctx.beginPath();
                ctx.arc(orbX, orbY, orbSize, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(196, 181, 253, ${0.4 + Math.sin(animationTime * 2 + i) * 0.2})`;
                ctx.shadowColor = 'rgba(196, 181, 253, 0.8)';
                ctx.shadowBlur = 10;
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        };

        // --- TDD API Key Management ---
        const getApiKey = () => {
            return localStorage.getItem('grok_api_key') || '';
        };

        const saveApiKey = (key) => {
            if (key && key.trim() && key.length >= 10) {
                localStorage.setItem('grok_api_key', key.trim());
                return true;
            }
            return false;
        };

        const showApiKeyPopup = () => {
            const popup = document.getElementById('api-key-popup');
            const input = document.getElementById('api-key-input');
            const error = document.getElementById('api-key-error');

            popup.classList.remove('hidden');
            input.focus();
            error.classList.add('hidden');
            error.textContent = '';
        };

        const hideApiKeyPopup = () => {
            const popup = document.getElementById('api-key-popup');
            const input = document.getElementById('api-key-input');

            popup.classList.add('hidden');
            input.value = '';
        };

        const showApiKeyError = (message) => {
            const error = document.getElementById('api-key-error');
            error.textContent = message;
            error.classList.remove('hidden');
        };

        // --- TDD Task 1: Unit Movement and Drag-and-Drop System ---

        const updateUnitMovement = (deltaTime) => {
            gameState.villageGrid.forEach(unit => {
                if (!unit.movable) return;

                // Auto-wandering for dreamers
                if (unit.type === 'dreamer' && !dragState.isDragging) {
                    updateWandering(unit, animationTime);
                }

                // Smooth movement towards target
                const dx = unit.targetX - unit.x;
                const dy = unit.targetY - unit.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 1) {
                    const speed = 50; // pixels per second
                    const moveDistance = speed * deltaTime;
                    const ratio = Math.min(moveDistance / distance, 1);

                    unit.x += dx * ratio;
                    unit.y += dy * ratio;
                    unit.vx = dx * ratio / deltaTime;
                    unit.vy = dy * ratio / deltaTime;
                } else {
                    unit.vx = 0;
                    unit.vy = 0;
                }
            });
        };

        const updateWandering = (unit, time) => {
            const wanderSpeed = 0.3;
            const wanderRadius = unit.wanderRadius || 30;

            unit.targetX = unit.wanderCenter.x + Math.sin(time * wanderSpeed + unit.wanderPhase) * wanderRadius;
            unit.targetY = unit.wanderCenter.y + Math.cos(time * wanderSpeed + unit.wanderPhase) * wanderRadius;

            // Keep within canvas bounds
            unit.targetX = Math.max(50, Math.min(canvas.width - 50, unit.targetX));
            unit.targetY = Math.max(50, Math.min(canvas.height - 50, unit.targetY));
        };

        const getUnitAtPosition = (x, y) => {
            for (let i = gameState.villageGrid.length - 1; i >= 0; i--) {
                const unit = gameState.villageGrid[i];
                const dx = x - unit.x;
                const dy = y - unit.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance <= unit.size) {
                    return unit;
                }
            }
            return null;
        };

        const getCanvasCoordinates = (event) => {
            const rect = canvas.getBoundingClientRect();
            return {
                x: event.clientX - rect.left,
                y: event.clientY - rect.top
            };
        };

        const updateMovementTrails = () => {
            gameState.villageGrid.forEach(unit => {
                if (!unit.movable || (Math.abs(unit.vx) < 1 && Math.abs(unit.vy) < 1)) return;

                const trailKey = unit.id;
                if (!movementTrails[trailKey]) {
                    movementTrails[trailKey] = [];
                }

                movementTrails[trailKey].push({
                    x: unit.x,
                    y: unit.y,
                    timestamp: Date.now(),
                    alpha: 1.0
                });

                // Keep only recent trail points
                const maxAge = 1500;
                const now = Date.now();
                movementTrails[trailKey] = movementTrails[trailKey].filter(point =>
                    now - point.timestamp < maxAge
                );

                // Update alpha based on age
                movementTrails[trailKey].forEach(point => {
                    const age = now - point.timestamp;
                    point.alpha = Math.max(0, 1 - (age / maxAge));
                });
            });
        };

        const drawMovementTrails = () => {
            Object.values(movementTrails).forEach(trail => {
                if (trail.length < 2) return;

                ctx.save();
                ctx.strokeStyle = 'rgba(138, 92, 246, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();

                for (let i = 0; i < trail.length; i++) {
                    const point = trail[i];
                    ctx.globalAlpha = point.alpha * 0.5;

                    if (i === 0) {
                        ctx.moveTo(point.x, point.y);
                    } else {
                        ctx.lineTo(point.x, point.y);
                    }
                }

                ctx.stroke();
                ctx.restore();
            });
        };

        // TDD: Distinct visual designs for each unit type
        const drawMovableUnit = (unit, isHovered, isDragged) => {
            ctx.save();

            // Visual feedback for interaction states
            let scale = 1.0;
            let alpha = 1.0;
            let glowIntensity = 0.8;

            if (isDragged) {
                scale = 1.2;
                alpha = 0.9;
                glowIntensity = 1.2;
            } else if (isHovered) {
                scale = 1.1;
                glowIntensity = 1.0;
            }

            ctx.globalAlpha = alpha;
            ctx.translate(unit.x, unit.y);
            ctx.scale(scale, scale);

            // Draw unit based on type with distinct designs
            if (unit.type === 'dreamer') {
                drawDreamerUnit(unit, glowIntensity);
            } else if (unit.type === 'weaver') {
                drawWeaverUnit(unit, glowIntensity);
            } else if (unit.type === 'stellarNomads') {
                drawStellarNomadUnit(unit, glowIntensity);
            } else if (unit.type === 'voidWhisperers') {
                drawVoidWhispererUnit(unit, glowIntensity);
            } else if (unit.type === 'crystalBeings') {
                drawCrystalBeingUnit(unit, glowIntensity);
            } else if (unit.type === 'plasmaDancers') {
                drawPlasmaDancerUnit(unit, glowIntensity);
            } else {
                // Default fallback
                drawDefaultUnit(unit, glowIntensity);
            }

            ctx.shadowBlur = 0;
            ctx.restore();
        };

        const drawDreamerUnit = (unit, glowIntensity) => {
            const pulse = 1 + Math.sin(animationTime * 2 + (unit.animationOffset || 0)) * 0.15;
            const currentSize = unit.size * pulse;
            const floatOffset = Math.sin(animationTime * 0.5 + (unit.animationOffset || 0)) * 3;

            ctx.save();
            ctx.translate(0, floatOffset);

            // Outer aura
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            ctx.shadowColor = '#A78BFA';
            ctx.shadowBlur = 30 * glowIntensity;
            ctx.beginPath();
            ctx.arc(0, 0, currentSize * 2, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(167, 139, 250, 0.15)';
            ctx.fill();
            ctx.restore();

            // Main orb with gradient
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize);
            gradient.addColorStop(0, 'rgba(196, 181, 253, 1.0)');
            gradient.addColorStop(0.6, 'rgba(139, 92, 246, 0.9)');
            gradient.addColorStop(1, 'rgba(109, 40, 217, 0.7)');

            ctx.shadowColor = '#A78BFA';
            ctx.shadowBlur = 20 * glowIntensity;
            ctx.beginPath();
            ctx.arc(0, 0, currentSize, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();

            // Inner core
            ctx.save();
            ctx.globalCompositeOperation = 'overlay';
            ctx.beginPath();
            ctx.arc(-currentSize * 0.2, -currentSize * 0.2, currentSize * 0.4, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.fill();
            ctx.restore();

            // Energy wisps
            for (let i = 0; i < 3; i++) {
                const angle = animationTime * 0.3 + (i * Math.PI * 2 / 3);
                const radius = currentSize * 1.5;
                const wispX = Math.cos(angle) * radius;
                const wispY = Math.sin(angle) * radius;

                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                ctx.strokeStyle = 'rgba(196, 181, 253, 0.6)';
                ctx.lineWidth = 2;
                ctx.shadowColor = '#A78BFA';
                ctx.shadowBlur = 10;

                ctx.beginPath();
                ctx.moveTo(0, 0);
                const cp1x = wispX * 0.3;
                const cp1y = wispY * 0.3 + Math.sin(animationTime * 2 + i) * 10;
                const cp2x = wispX * 0.7;
                const cp2y = wispY * 0.7 + Math.cos(animationTime * 2 + i) * 8;
                ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, wispX, wispY);
                ctx.stroke();
                ctx.restore();
            }

            ctx.restore();
        };

        const drawWeaverUnit = (unit, glowIntensity) => {
            const pulse = 1 + Math.sin(animationTime * 1.5 + (unit.animationOffset || 0)) * 0.1;
            const currentSize = unit.size * pulse;

            // Hexagonal crystal base
            ctx.save();
            ctx.shadowColor = '#34D399';
            ctx.shadowBlur = 20 * glowIntensity;

            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize);
            gradient.addColorStop(0, 'rgba(110, 231, 183, 1.0)');
            gradient.addColorStop(0.6, 'rgba(16, 185, 129, 0.9)');
            gradient.addColorStop(1, 'rgba(5, 150, 105, 0.7)');

            // Draw hexagon
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = (i * Math.PI * 2) / 6;
                const x = Math.cos(angle) * currentSize;
                const y = Math.sin(angle) * currentSize;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fillStyle = gradient;
            ctx.fill();

            // Hexagon outline
            ctx.strokeStyle = 'rgba(110, 231, 183, 0.8)';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.restore();

            // Energy threads
            for (let i = 0; i < 6; i++) {
                const angle1 = (i * Math.PI * 2) / 6;
                const angle2 = ((i + 2) * Math.PI * 2) / 6;
                const weaveOffset = Math.sin(animationTime * 1.0 + i) * 0.3;

                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                ctx.strokeStyle = `rgba(110, 231, 183, ${0.4 + weaveOffset})`;
                ctx.lineWidth = 1.5;
                ctx.shadowColor = '#34D399';
                ctx.shadowBlur = 8;

                const x1 = Math.cos(angle1) * currentSize * 0.8;
                const y1 = Math.sin(angle1) * currentSize * 0.8;
                const x2 = Math.cos(angle2) * currentSize * 0.8;
                const y2 = Math.sin(angle2) * currentSize * 0.8;

                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
                ctx.restore();
            }

            // Central gem
            ctx.save();
            ctx.globalCompositeOperation = 'overlay';
            ctx.beginPath();
            for (let i = 0; i < 4; i++) {
                const angle = (i * Math.PI * 2) / 4 + Math.PI / 4;
                const x = Math.cos(angle) * currentSize * 0.3;
                const y = Math.sin(angle) * currentSize * 0.3;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.fill();
            ctx.restore();
        };

        const drawStellarNomadUnit = (unit, glowIntensity) => {
            const pulse = 1 + Math.sin(animationTime * 3 + (unit.animationOffset || 0)) * 0.2;
            const currentSize = unit.size * pulse;
            const rotation = animationTime * 0.5;

            ctx.save();
            ctx.rotate(rotation);

            // Stellar corona (8-pointed star)
            ctx.save();
            ctx.shadowColor = '#FBBF24';
            ctx.shadowBlur = 25 * glowIntensity;

            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize * 1.5);
            gradient.addColorStop(0, 'rgba(252, 211, 77, 1.0)');
            gradient.addColorStop(0.6, 'rgba(245, 158, 11, 0.8)');
            gradient.addColorStop(1, 'rgba(217, 119, 6, 0.4)');

            // Draw 8-pointed star
            ctx.beginPath();
            for (let i = 0; i < 16; i++) {
                const angle = (i * Math.PI * 2) / 16;
                const radius = i % 2 === 0 ? currentSize * 1.5 : currentSize * 0.8;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.restore();

            // Plasma core
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize * 0.8);
            coreGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
            coreGradient.addColorStop(0.5, 'rgba(252, 211, 77, 0.7)');
            coreGradient.addColorStop(1, 'rgba(245, 158, 11, 0.3)');

            ctx.beginPath();
            ctx.arc(0, 0, currentSize * 0.8, 0, Math.PI * 2);
            ctx.fillStyle = coreGradient;
            ctx.fill();
            ctx.restore();

            // Solar flares
            for (let i = 0; i < 4; i++) {
                const flareAngle = (i * Math.PI * 2) / 4 + animationTime * 0.2;
                const flareIntensity = 0.5 + Math.sin(animationTime * 4 + i) * 0.3;
                const flareLength = currentSize * (1.5 + flareIntensity * 0.5);

                ctx.save();
                ctx.rotate(flareAngle);
                ctx.globalCompositeOperation = 'screen';
                ctx.strokeStyle = `rgba(252, 211, 77, ${flareIntensity})`;
                ctx.lineWidth = 3;
                ctx.shadowColor = '#FBBF24';
                ctx.shadowBlur = 15;

                // Draw flame-like wisp
                ctx.beginPath();
                ctx.moveTo(currentSize, 0);
                const cp1x = currentSize + flareLength * 0.3;
                const cp1y = Math.sin(animationTime * 3 + i) * 8;
                const cp2x = currentSize + flareLength * 0.7;
                const cp2y = Math.cos(animationTime * 2 + i) * 12;
                const endX = currentSize + flareLength;
                const endY = Math.sin(animationTime * 4 + i) * 5;

                ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, endX, endY);
                ctx.stroke();
                ctx.restore();
            }

            ctx.restore();
        };

        const drawVoidWhispererUnit = (unit, glowIntensity) => {
            const pulse = 1 + Math.sin(animationTime * 1.5 + (unit.animationOffset || 0)) * 0.15;
            const currentSize = unit.size * pulse;
            const warpIntensity = Math.sin(animationTime * 1.5) * 0.15;

            // Void distortion effect
            ctx.save();
            ctx.globalCompositeOperation = 'multiply';
            ctx.shadowColor = '#581C87';
            ctx.shadowBlur = 30 * glowIntensity;

            // Irregular distorted circle
            ctx.beginPath();
            for (let i = 0; i <= 32; i++) {
                const angle = (i * Math.PI * 2) / 32;
                const distortion = 1 + Math.sin(angle * 3 + animationTime * 2) * warpIntensity;
                const radius = currentSize * distortion;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();

            const voidGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize);
            voidGradient.addColorStop(0, 'rgba(76, 29, 149, 0.9)');
            voidGradient.addColorStop(0.6, 'rgba(88, 28, 135, 0.7)');
            voidGradient.addColorStop(1, 'rgba(107, 33, 168, 0.3)');

            ctx.fillStyle = voidGradient;
            ctx.fill();
            ctx.restore();

            // Shadow tendrils
            for (let i = 0; i < 5; i++) {
                const baseAngle = (i * Math.PI * 2) / 5;
                const writheOffset = Math.sin(animationTime * 2 + i) * 0.5;
                const tentacleLength = currentSize * (1.5 + writheOffset);

                ctx.save();
                ctx.rotate(baseAngle);
                ctx.globalCompositeOperation = 'multiply';
                ctx.strokeStyle = `rgba(76, 29, 149, ${0.6 + writheOffset * 0.3})`;
                ctx.lineWidth = 3;
                ctx.shadowColor = '#581C87';
                ctx.shadowBlur = 12;

                // Draw writhing tentacle
                ctx.beginPath();
                ctx.moveTo(currentSize * 0.8, 0);

                const segments = 6;
                for (let j = 1; j <= segments; j++) {
                    const t = j / segments;
                    const segmentX = currentSize * 0.8 + tentacleLength * t;
                    const writhe = Math.sin(t * Math.PI * 2 + animationTime * 2 + i) * 8;
                    const segmentY = writhe;

                    if (j === 1) {
                        ctx.lineTo(segmentX, segmentY);
                    } else {
                        const prevT = (j - 1) / segments;
                        const prevX = currentSize * 0.8 + tentacleLength * prevT;
                        const prevWrithe = Math.sin(prevT * Math.PI * 2 + animationTime * 2 + i) * 8;

                        const cp1x = prevX + (segmentX - prevX) * 0.5;
                        const cp1y = prevWrithe;
                        const cp2x = segmentX - (segmentX - prevX) * 0.5;
                        const cp2y = segmentY;

                        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, segmentX, segmentY);
                    }
                }
                ctx.stroke();
                ctx.restore();
            }

            // Dark absorption core
            ctx.save();
            ctx.globalCompositeOperation = 'multiply';
            ctx.beginPath();
            ctx.arc(0, 0, currentSize * 0.5, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fill();
            ctx.restore();
        };

        const drawCrystalBeingUnit = (unit, glowIntensity) => {
            const pulse = 1 + Math.sin(animationTime * 2.5 + (unit.animationOffset || 0)) * 0.12;
            const currentSize = unit.size * pulse;
            const refraction = animationTime * 3;

            // Crystal facets
            ctx.save();
            ctx.shadowColor = '#06B6D4';
            ctx.shadowBlur = 20 * glowIntensity;

            // Main crystal body (octagon)
            const facets = 8;
            for (let layer = 0; layer < 3; layer++) {
                const layerSize = currentSize * (1 - layer * 0.2);
                const layerAlpha = 0.8 - layer * 0.2;

                ctx.save();
                ctx.rotate(refraction + layer * 0.1);

                const crystalGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, layerSize);
                crystalGradient.addColorStop(0, `rgba(165, 243, 252, ${layerAlpha})`);
                crystalGradient.addColorStop(0.6, `rgba(6, 182, 212, ${layerAlpha * 0.8})`);
                crystalGradient.addColorStop(1, `rgba(8, 145, 178, ${layerAlpha * 0.6})`);

                ctx.beginPath();
                for (let i = 0; i < facets; i++) {
                    const angle = (i * Math.PI * 2) / facets;
                    const x = Math.cos(angle) * layerSize;
                    const y = Math.sin(angle) * layerSize;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fillStyle = crystalGradient;
                ctx.fill();

                // Facet edges
                ctx.strokeStyle = `rgba(165, 243, 252, ${layerAlpha * 0.6})`;
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.restore();
            }
            ctx.restore();

            // Refraction highlights
            for (let i = 0; i < 3; i++) {
                const highlightAngle = refraction + (i * Math.PI * 2) / 3;
                const highlightX = Math.cos(highlightAngle) * currentSize * 0.6;
                const highlightY = Math.sin(highlightAngle) * currentSize * 0.6;

                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                ctx.beginPath();
                ctx.arc(highlightX, highlightY, 3, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.shadowColor = '#06B6D4';
                ctx.shadowBlur = 8;
                ctx.fill();
                ctx.restore();
            }
        };

        const drawPlasmaDancerUnit = (unit, glowIntensity) => {
            const pulse = 1 + Math.sin(animationTime * 4 + (unit.animationOffset || 0)) * 0.25;
            const currentSize = unit.size * pulse;
            const flow = animationTime * 2;

            // Plasma wisps flowing around center
            for (let i = 0; i < 6; i++) {
                const wispAngle = flow + (i * Math.PI * 2) / 6;
                const wispRadius = currentSize * (1.2 + Math.sin(flow + i) * 0.3);
                const wispX = Math.cos(wispAngle) * wispRadius;
                const wispY = Math.sin(wispAngle) * wispRadius;

                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                ctx.strokeStyle = `rgba(236, 72, 153, ${0.6 + Math.sin(flow * 2 + i) * 0.3})`;
                ctx.lineWidth = 4;
                ctx.shadowColor = '#EC4899';
                ctx.shadowBlur = 15;

                // Draw flowing wisp
                ctx.beginPath();
                ctx.moveTo(0, 0);
                const cp1x = wispX * 0.3;
                const cp1y = wispY * 0.3 + Math.sin(flow * 3 + i) * 15;
                const cp2x = wispX * 0.7;
                const cp2y = wispY * 0.7 + Math.cos(flow * 2 + i) * 10;
                ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, wispX, wispY);
                ctx.stroke();
                ctx.restore();
            }

            // Central plasma core
            ctx.save();
            ctx.shadowColor = '#EC4899';
            ctx.shadowBlur = 25 * glowIntensity;

            const plasmaGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize * 0.8);
            plasmaGradient.addColorStop(0, 'rgba(251, 207, 232, 1.0)');
            plasmaGradient.addColorStop(0.5, 'rgba(236, 72, 153, 0.8)');
            plasmaGradient.addColorStop(1, 'rgba(190, 24, 93, 0.4)');

            // Irregular plasma shape
            ctx.beginPath();
            for (let i = 0; i <= 16; i++) {
                const angle = (i * Math.PI * 2) / 16;
                const variation = 1 + Math.sin(angle * 4 + flow) * 0.2;
                const radius = currentSize * 0.8 * variation;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fillStyle = plasmaGradient;
            ctx.fill();
            ctx.restore();
        };

        const drawDefaultUnit = (unit, glowIntensity) => {
            // Fallback design for unknown unit types
            const pulse = 1 + Math.sin(animationTime * 2 + (unit.animationOffset || 0)) * 0.15;
            const currentSize = unit.size * pulse;

            ctx.save();
            ctx.shadowColor = '#6B7280';
            ctx.shadowBlur = 15 * glowIntensity;

            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize);
            gradient.addColorStop(0, 'rgba(156, 163, 175, 1.0)');
            gradient.addColorStop(0.6, 'rgba(107, 114, 128, 0.9)');
            gradient.addColorStop(1, 'rgba(75, 85, 99, 0.7)');

            ctx.beginPath();
            ctx.arc(0, 0, currentSize, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.restore();
        };

        // --- TDD: Intelligent Creatures System ---

        let creatureIdCounter = 0;

        const createIntelligentCreature = (type, x, y) => {
            const creature = {
                id: `creature_${creatureIdCounter++}`,
                type: type,
                x: x,
                y: y,
                size: 30,
                intelligence: 100,
                memory: [],
                goals: [],
                currentGoal: null,
                personality: {
                    curiosity: Math.random(),
                    sociability: Math.random(),
                    productivity: Math.random(),
                    exploration: Math.random()
                },
                state: 'idle',
                energy: 100,
                lastDecision: 0,
                decisionCooldown: 3000, // 3 seconds between decisions
                perceptionRadius: 120,
                movementSpeed: 25,
                targetX: x,
                targetY: y,
                vx: 0,
                vy: 0,
                animationOffset: Math.random() * Math.PI * 2,
                relationships: new Map()
            };

            // Initialize based on creature type
            if (type === 'cosmicSage') {
                creature.specialAbilities = ['insight_generation', 'knowledge_sharing', 'meditation'];
                creature.preferredActivities = ['study', 'teach', 'contemplate'];
                creature.color = '#9333EA';
                creature.glowColor = '#A855F7';
            } else if (type === 'voidExplorer') {
                creature.specialAbilities = ['void_navigation', 'resource_discovery', 'pathfinding'];
                creature.preferredActivities = ['explore', 'scout', 'gather'];
                creature.color = '#1F2937';
                creature.glowColor = '#4B5563';
            } else if (type === 'harmonyKeeper') {
                creature.specialAbilities = ['harmony_restoration', 'conflict_resolution', 'healing'];
                creature.preferredActivities = ['mediate', 'heal', 'organize'];
                creature.color = '#059669';
                creature.glowColor = '#10B981';
            }

            return creature;
        };

        const spawnIntelligentCreature = (type) => {
            const x = Math.random() * (canvas.width - 200) + 100;
            const y = Math.random() * (canvas.height - 200) + 100;
            const creature = createIntelligentCreature(type, x, y);
            gameState.intelligentCreatures.push(creature);
            log(`A ${type} has awakened in the sanctuary!`, 'success');
            return creature;
        };

        const perceiveEnvironment = (creature) => {
            const perception = {
                nearbyUnits: [],
                nearbyResources: [],
                nearbyCreatures: [],
                threats: [],
                opportunities: [],
                environmentalFactors: {}
            };

            // Find nearby entities within perception radius
            gameState.villageGrid.forEach(entity => {
                const distance = Math.sqrt(
                    Math.pow(entity.x - creature.x, 2) +
                    Math.pow(entity.y - creature.y, 2)
                );

                if (distance <= creature.perceptionRadius) {
                    if (entity.movable) {
                        perception.nearbyUnits.push({
                            entity: entity,
                            distance: distance,
                            relationship: 'neutral'
                        });
                    } else {
                        perception.nearbyResources.push({
                            entity: entity,
                            distance: distance,
                            type: entity.type
                        });
                    }
                }
            });

            // Find other intelligent creatures
            gameState.intelligentCreatures.forEach(otherCreature => {
                if (otherCreature.id !== creature.id) {
                    const distance = Math.sqrt(
                        Math.pow(otherCreature.x - creature.x, 2) +
                        Math.pow(otherCreature.y - creature.y, 2)
                    );

                    if (distance <= creature.perceptionRadius) {
                        perception.nearbyCreatures.push({
                            creature: otherCreature,
                            distance: distance,
                            relationship: creature.relationships.get(otherCreature.id) || 'neutral'
                        });
                    }
                }
            });

            // Analyze environmental factors
            perception.environmentalFactors = {
                crowding: perception.nearbyUnits.length + perception.nearbyCreatures.length,
                resourceAvailability: perception.nearbyResources.length,
                harmonyLevel: gameState.harmony || 50,
                energyLevel: gameState.energy || 0,
                insightLevel: gameState.insight || 0
            };

            return perception;
        };

        const makeDecision = (creature, perception, currentTime) => {
            // Don't make decisions too frequently
            if (currentTime - creature.lastDecision < creature.decisionCooldown) {
                return creature.currentGoal;
            }

            const possibleGoals = [];

            // Generate goals based on creature type and personality
            if (creature.type === 'cosmicSage') {
                if (perception.nearbyUnits.length > 0 && creature.personality.sociability > 0.5) {
                    possibleGoals.push({
                        type: 'teach',
                        priority: creature.personality.sociability * 10,
                        target: perception.nearbyUnits[0].entity,
                        duration: 8000
                    });
                }

                if (perception.environmentalFactors.harmonyLevel < 70) {
                    possibleGoals.push({
                        type: 'meditate',
                        priority: (100 - perception.environmentalFactors.harmonyLevel) / 8,
                        target: null,
                        duration: 10000
                    });
                }

                if (perception.nearbyCreatures.length > 0 && creature.personality.sociability > 0.6) {
                    possibleGoals.push({
                        type: 'communicate',
                        priority: creature.personality.sociability * 8,
                        target: perception.nearbyCreatures[0].creature,
                        duration: 5000
                    });
                }
            }

            if (creature.type === 'voidExplorer') {
                if (creature.personality.exploration > 0.5) {
                    possibleGoals.push({
                        type: 'explore',
                        priority: creature.personality.exploration * 9,
                        target: {
                            x: Math.random() * (canvas.width - 100) + 50,
                            y: Math.random() * (canvas.height - 100) + 50
                        },
                        duration: 12000
                    });
                }

                if (perception.nearbyResources.length > 0) {
                    possibleGoals.push({
                        type: 'investigate',
                        priority: creature.personality.curiosity * 8,
                        target: perception.nearbyResources[0].entity,
                        duration: 6000
                    });
                }
            }

            if (creature.type === 'harmonyKeeper') {
                if (perception.environmentalFactors.harmonyLevel < 80) {
                    possibleGoals.push({
                        type: 'restore_harmony',
                        priority: (100 - perception.environmentalFactors.harmonyLevel) / 6,
                        target: null,
                        duration: 8000
                    });
                }

                if (perception.nearbyUnits.length > 2) {
                    possibleGoals.push({
                        type: 'organize',
                        priority: perception.nearbyUnits.length * 2,
                        target: perception.nearbyUnits,
                        duration: 10000
                    });
                }
            }

            // Add idle goal as fallback
            possibleGoals.push({
                type: 'idle',
                priority: 1,
                target: null,
                duration: 5000
            });

            // Select highest priority goal
            possibleGoals.sort((a, b) => b.priority - a.priority);
            creature.currentGoal = possibleGoals[0];
            creature.lastDecision = currentTime;
            creature.state = creature.currentGoal.type;

            return creature.currentGoal;
        };

        const updateMemory = (creature, event) => {
            const memoryEntry = {
                timestamp: Date.now(),
                type: event.type,
                location: { x: creature.x, y: creature.y },
                data: event.data,
                importance: event.importance || 1
            };

            creature.memory.push(memoryEntry);

            // Keep memory size manageable
            const maxMemorySize = 30;
            if (creature.memory.length > maxMemorySize) {
                // Remove least important old memories
                creature.memory.sort((a, b) => {
                    const ageA = Date.now() - a.timestamp;
                    const ageB = Date.now() - b.timestamp;
                    const scoreA = a.importance - (ageA / 20000);
                    const scoreB = b.importance - (ageB / 20000);
                    return scoreB - scoreA;
                });
                creature.memory = creature.memory.slice(0, maxMemorySize);
            }
        };

        const executeBehavior = (creature, goal, deltaTime) => {
            if (!goal) return;

            switch (goal.type) {
                case 'teach':
                    if (goal.target && goal.target.movable) {
                        const distance = Math.sqrt(
                            Math.pow(goal.target.x - creature.x, 2) +
                            Math.pow(goal.target.y - creature.y, 2)
                        );

                        if (distance > 60) {
                            // Move closer to target
                            creature.targetX = goal.target.x;
                            creature.targetY = goal.target.y;
                        } else {
                            // Teaching effect
                            if (!goal.target.teachingBoost || Date.now() - goal.target.teachingBoost.timestamp > 30000) {
                                goal.target.teachingBoost = {
                                    multiplier: 1.3,
                                    duration: 30000,
                                    timestamp: Date.now()
                                };

                                updateMemory(creature, {
                                    type: 'teaching_completed',
                                    data: { targetId: goal.target.id },
                                    importance: 3
                                });

                                creature.intelligence = Math.min(200, creature.intelligence + 1);
                            }
                        }
                    }
                    break;

                case 'meditate':
                    // Stay still and generate harmony
                    creature.targetX = creature.x;
                    creature.targetY = creature.y;

                    if (Math.random() < 0.02) { // 2% chance per frame
                        gameState.harmony = Math.min(100, gameState.harmony + 0.5);
                        gameState.insight = Math.min(gameState.insight + 0.2, gameState.insight + 0.2);
                    }
                    break;

                case 'explore':
                    if (goal.target) {
                        creature.targetX = goal.target.x;
                        creature.targetY = goal.target.y;

                        const distance = Math.sqrt(
                            Math.pow(goal.target.x - creature.x, 2) +
                            Math.pow(goal.target.y - creature.y, 2)
                        );

                        if (distance < 20) {
                            // Reached exploration target
                            updateMemory(creature, {
                                type: 'area_explored',
                                data: { location: { x: creature.x, y: creature.y } },
                                importance: 2
                            });

                            // Small chance to discover resources
                            if (Math.random() < 0.1) {
                                gameState.energy += 5;
                                log(`${creature.type} discovered energy while exploring!`, 'info');
                            }
                        }
                    }
                    break;

                case 'investigate':
                    if (goal.target) {
                        const distance = Math.sqrt(
                            Math.pow(goal.target.x - creature.x, 2) +
                            Math.pow(goal.target.y - creature.y, 2)
                        );

                        if (distance > 40) {
                            creature.targetX = goal.target.x;
                            creature.targetY = goal.target.y;
                        } else {
                            // Investigation complete
                            updateMemory(creature, {
                                type: 'resource_investigated',
                                data: { resourceType: goal.target.type, location: { x: goal.target.x, y: goal.target.y } },
                                importance: 4
                            });
                        }
                    }
                    break;

                case 'restore_harmony':
                    // Harmony restoration effect
                    if (Math.random() < 0.03) { // 3% chance per frame
                        gameState.harmony = Math.min(100, gameState.harmony + 1);

                        // Boost nearby units
                        gameState.villageGrid.forEach(entity => {
                            if (entity.movable) {
                                const distance = Math.sqrt(
                                    Math.pow(entity.x - creature.x, 2) +
                                    Math.pow(entity.y - creature.y, 2)
                                );

                                if (distance <= 80) {
                                    entity.harmonyBoost = {
                                        multiplier: 1.15,
                                        duration: 20000,
                                        timestamp: Date.now()
                                    };
                                }
                            }
                        });
                    }
                    break;

                case 'communicate':
                    if (goal.target) {
                        const distance = Math.sqrt(
                            Math.pow(goal.target.x - creature.x, 2) +
                            Math.pow(goal.target.y - creature.y, 2)
                        );

                        if (distance <= 70) {
                            // Share knowledge
                            const recentMemories = creature.memory.slice(-2);
                            recentMemories.forEach(memory => {
                                if (!goal.target.memory.some(m =>
                                    m.type === memory.type &&
                                    Math.abs(m.timestamp - memory.timestamp) < 2000
                                )) {
                                    goal.target.memory.push({
                                        ...memory,
                                        source: creature.id,
                                        shared: true
                                    });
                                }
                            });

                            // Improve relationship
                            creature.relationships.set(goal.target.id, 'friendly');
                            goal.target.relationships.set(creature.id, 'friendly');

                            // Both gain intelligence
                            creature.intelligence = Math.min(200, creature.intelligence + 0.5);
                            goal.target.intelligence = Math.min(200, goal.target.intelligence + 0.5);
                        }
                    }
                    break;

                case 'idle':
                default:
                    // Gentle wandering
                    const wanderRadius = 40;
                    creature.targetX = creature.x + (Math.random() - 0.5) * wanderRadius;
                    creature.targetY = creature.y + (Math.random() - 0.5) * wanderRadius;

                    // Keep within bounds
                    creature.targetX = Math.max(50, Math.min(canvas.width - 50, creature.targetX));
                    creature.targetY = Math.max(50, Math.min(canvas.height - 50, creature.targetY));
                    break;
            }
        };

        const updateIntelligentCreatures = (deltaTime) => {
            const currentTime = Date.now();

            gameState.intelligentCreatures.forEach(creature => {
                // Perception and decision making
                const perception = perceiveEnvironment(creature);
                const goal = makeDecision(creature, perception, currentTime);

                // Execute current behavior
                executeBehavior(creature, goal, deltaTime);

                // Update movement
                const dx = creature.targetX - creature.x;
                const dy = creature.targetY - creature.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 2) {
                    const speed = creature.movementSpeed;
                    const moveDistance = speed * deltaTime;
                    const ratio = Math.min(moveDistance / distance, 1);

                    creature.x += dx * ratio;
                    creature.y += dy * ratio;
                    creature.vx = dx * ratio / deltaTime;
                    creature.vy = dy * ratio / deltaTime;
                } else {
                    creature.vx = 0;
                    creature.vy = 0;
                }

                // Update goal duration
                if (goal && goal.startTime) {
                    if (currentTime - goal.startTime > goal.duration) {
                        creature.currentGoal = null;
                        creature.state = 'idle';
                    }
                } else if (goal) {
                    goal.startTime = currentTime;
                }
            });
        };

        const drawIntelligentCreatures = () => {
            gameState.intelligentCreatures.forEach(creature => {
                drawIntelligentCreature(creature);
            });
        };

        const drawIntelligentCreature = (creature) => {
            ctx.save();
            ctx.translate(creature.x, creature.y);

            const pulse = 1 + Math.sin(animationTime * 1.5 + creature.animationOffset) * 0.1;
            const currentSize = creature.size * pulse;

            // Intelligence aura - larger and more complex than regular units
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            ctx.shadowColor = creature.glowColor;
            ctx.shadowBlur = 35;

            const auraGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize * 2.5);
            const r = parseInt(creature.glowColor.slice(1,3), 16);
            const g = parseInt(creature.glowColor.slice(3,5), 16);
            const b = parseInt(creature.glowColor.slice(5,7), 16);

            auraGradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.3)`);
            auraGradient.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, 0.15)`);
            auraGradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);

            ctx.beginPath();
            ctx.arc(0, 0, currentSize * 2.5, 0, Math.PI * 2);
            ctx.fillStyle = auraGradient;
            ctx.fill();
            ctx.restore();

            // Main creature body - distinctive shape based on type
            if (creature.type === 'cosmicSage') {
                drawCosmicSage(creature, currentSize);
            } else if (creature.type === 'voidExplorer') {
                drawVoidExplorer(creature, currentSize);
            } else if (creature.type === 'harmonyKeeper') {
                drawHarmonyKeeper(creature, currentSize);
            }

            // Intelligence indicator - neural network pattern
            if (creature.intelligence > 100) {
                drawIntelligenceIndicator(creature, currentSize);
            }

            // State indicator
            drawStateIndicator(creature, currentSize);

            ctx.restore();
        };

        const drawCosmicSage = (creature, size) => {
            // Multi-layered mandala design
            ctx.save();
            ctx.shadowColor = creature.glowColor;
            ctx.shadowBlur = 25;

            // Outer ring with rotating symbols
            const rotation = animationTime * 0.3;
            for (let i = 0; i < 8; i++) {
                const angle = (i * Math.PI * 2 / 8) + rotation;
                const symbolX = Math.cos(angle) * size * 1.5;
                const symbolY = Math.sin(angle) * size * 1.5;

                ctx.save();
                ctx.translate(symbolX, symbolY);
                ctx.rotate(angle + Math.PI / 2);
                ctx.fillStyle = creature.glowColor;
                ctx.font = '12px serif';
                ctx.textAlign = 'center';
                ctx.fillText('‚óä', 0, 4);
                ctx.restore();
            }

            // Main body - complex geometric pattern
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
            const r = parseInt(creature.color.slice(1,3), 16);
            const g = parseInt(creature.color.slice(3,5), 16);
            const b = parseInt(creature.color.slice(5,7), 16);

            gradient.addColorStop(0, `rgba(${Math.min(255, r + 50)}, ${Math.min(255, g + 50)}, ${Math.min(255, b + 50)}, 1.0)`);
            gradient.addColorStop(0.6, `rgba(${r}, ${g}, ${b}, 0.9)`);
            gradient.addColorStop(1, `rgba(${Math.max(0, r - 30)}, ${Math.max(0, g - 30)}, ${Math.max(0, b - 30)}, 0.7)`);

            // Draw complex star pattern
            ctx.beginPath();
            for (let i = 0; i < 12; i++) {
                const angle = (i * Math.PI * 2) / 12;
                const radius = i % 2 === 0 ? size : size * 0.6;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fillStyle = gradient;
            ctx.fill();

            // Inner wisdom eye
            ctx.beginPath();
            ctx.arc(0, 0, size * 0.3, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.fill();

            ctx.beginPath();
            ctx.arc(0, 0, size * 0.15, 0, Math.PI * 2);
            ctx.fillStyle = creature.color;
            ctx.fill();

            ctx.restore();
        };

        const drawVoidExplorer = (creature, size) => {
            // Shifting, ethereal form
            ctx.save();
            ctx.shadowColor = creature.glowColor;
            ctx.shadowBlur = 20;

            const shift = Math.sin(animationTime * 2) * 0.2;

            // Main body - irregular, shifting shape
            ctx.beginPath();
            for (let i = 0; i <= 16; i++) {
                const angle = (i * Math.PI * 2) / 16;
                const variation = 1 + Math.sin(angle * 3 + animationTime * 1.5) * shift;
                const radius = size * variation;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();

            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
            const r = parseInt(creature.color.slice(1,3), 16);
            const g = parseInt(creature.color.slice(3,5), 16);
            const b = parseInt(creature.color.slice(5,7), 16);

            gradient.addColorStop(0, `rgba(${r + 40}, ${g + 40}, ${b + 40}, 0.8)`);
            gradient.addColorStop(0.7, `rgba(${r}, ${g}, ${b}, 0.6)`);
            gradient.addColorStop(1, `rgba(${r - 20}, ${g - 20}, ${b - 20}, 0.3)`);

            ctx.fillStyle = gradient;
            ctx.fill();

            // Void tendrils
            for (let i = 0; i < 4; i++) {
                const tendrilAngle = (i * Math.PI * 2 / 4) + animationTime * 0.5;
                const tendrilLength = size * (1.2 + Math.sin(animationTime * 2 + i) * 0.3);

                ctx.save();
                ctx.rotate(tendrilAngle);
                ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.6)`;
                ctx.lineWidth = 3;
                ctx.shadowBlur = 10;

                ctx.beginPath();
                ctx.moveTo(size * 0.7, 0);

                const segments = 5;
                for (let j = 1; j <= segments; j++) {
                    const t = j / segments;
                    const segmentX = size * 0.7 + tendrilLength * t;
                    const wave = Math.sin(t * Math.PI * 2 + animationTime * 3 + i) * 8;
                    const segmentY = wave;

                    if (j === 1) {
                        ctx.lineTo(segmentX, segmentY);
                    } else {
                        const prevT = (j - 1) / segments;
                        const prevX = size * 0.7 + tendrilLength * prevT;
                        const prevWave = Math.sin(prevT * Math.PI * 2 + animationTime * 3 + i) * 8;

                        const cp1x = prevX + (segmentX - prevX) * 0.5;
                        const cp1y = prevWave;
                        const cp2x = segmentX - (segmentX - prevX) * 0.5;
                        const cp2y = segmentY;

                        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, segmentX, segmentY);
                    }
                }
                ctx.stroke();
                ctx.restore();
            }

            ctx.restore();
        };

        const drawHarmonyKeeper = (creature, size) => {
            // Flowing, organic form with healing energy
            ctx.save();
            ctx.shadowColor = creature.glowColor;
            ctx.shadowBlur = 30;

            // Main body - organic, flowing shape
            const flow = animationTime * 1.2;
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
            const r = parseInt(creature.color.slice(1,3), 16);
            const g = parseInt(creature.color.slice(3,5), 16);
            const b = parseInt(creature.color.slice(5,7), 16);

            gradient.addColorStop(0, `rgba(${Math.min(255, r + 60)}, ${Math.min(255, g + 60)}, ${Math.min(255, b + 60)}, 1.0)`);
            gradient.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, 0.9)`);
            gradient.addColorStop(1, `rgba(${Math.max(0, r - 20)}, ${Math.max(0, g - 20)}, ${Math.max(0, b - 20)}, 0.6)`);

            // Draw flowing petals
            for (let i = 0; i < 6; i++) {
                const petalAngle = (i * Math.PI * 2 / 6) + flow * 0.2;
                const petalSize = size * (0.8 + Math.sin(flow + i) * 0.2);

                ctx.save();
                ctx.rotate(petalAngle);
                ctx.beginPath();
                ctx.ellipse(petalSize * 0.5, 0, petalSize * 0.6, petalSize * 0.3, 0, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
                ctx.restore();
            }

            // Central harmony core
            ctx.beginPath();
            ctx.arc(0, 0, size * 0.4, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(${Math.min(255, r + 80)}, ${Math.min(255, g + 80)}, ${Math.min(255, b + 80)}, 0.9)`;
            ctx.fill();

            // Healing energy waves
            for (let i = 0; i < 3; i++) {
                const waveRadius = size * (1.5 + i * 0.5) + Math.sin(flow * 2 - i) * 10;
                const waveAlpha = 0.3 - i * 0.1;

                ctx.beginPath();
                ctx.arc(0, 0, waveRadius, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${waveAlpha})`;
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            ctx.restore();
        };

        const drawIntelligenceIndicator = (creature, size) => {
            // Neural network pattern for high intelligence
            if (creature.intelligence <= 100) return;

            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            ctx.strokeStyle = `rgba(255, 255, 255, 0.4)`;
            ctx.lineWidth = 1;

            const nodes = 6;
            const nodePositions = [];

            // Create node positions
            for (let i = 0; i < nodes; i++) {
                const angle = (i * Math.PI * 2) / nodes;
                const radius = size * 0.8;
                nodePositions.push({
                    x: Math.cos(angle) * radius,
                    y: Math.sin(angle) * radius
                });
            }

            // Draw connections
            for (let i = 0; i < nodes; i++) {
                for (let j = i + 1; j < nodes; j++) {
                    if (Math.random() < 0.6) { // 60% chance of connection
                        ctx.beginPath();
                        ctx.moveTo(nodePositions[i].x, nodePositions[i].y);
                        ctx.lineTo(nodePositions[j].x, nodePositions[j].y);
                        ctx.stroke();
                    }
                }
            }

            // Draw nodes
            nodePositions.forEach(pos => {
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 2, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.fill();
            });

            ctx.restore();
        };

        const drawStateIndicator = (creature, size) => {
            // Small indicator showing current state
            ctx.save();
            ctx.translate(0, -size * 1.3);

            let stateColor = '#FFFFFF';
            let stateSymbol = '‚óè';

            switch (creature.state) {
                case 'teach':
                    stateColor = '#F59E0B';
                    stateSymbol = 'üìö';
                    break;
                case 'meditate':
                    stateColor = '#8B5CF6';
                    stateSymbol = 'üßò';
                    break;
                case 'explore':
                    stateColor = '#10B981';
                    stateSymbol = 'üîç';
                    break;
                case 'investigate':
                    stateColor = '#06B6D4';
                    stateSymbol = 'üî¨';
                    break;
                case 'restore_harmony':
                    stateColor = '#059669';
                    stateSymbol = '‚ú®';
                    break;
                case 'communicate':
                    stateColor = '#EC4899';
                    stateSymbol = 'üí¨';
                    break;
            }

            if (creature.state !== 'idle') {
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillStyle = stateColor;
                ctx.shadowColor = stateColor;
                ctx.shadowBlur = 5;
                ctx.fillText(stateSymbol, 0, 5);
            }

            ctx.restore();
        };

        // --- Grok API Integration with Popup ---
        async function callGrok(prompt, button, systemPrompt = "") {
            if (button) {
                button.disabled = true;
                button.classList.add('loading');
                button.innerHTML = 'AI is thinking...';
            }

            try {
                const apiKey = getApiKey();
                if (!apiKey) {
                    showApiKeyPopup();
                    throw new Error("API key required - popup shown");
                }

                const apiUrl = "https://api.x.ai/v1/chat/completions";
                const messages = [];

                if (systemPrompt) {
                    messages.push({ role: "system", content: systemPrompt });
                }
                messages.push({ role: "user", content: prompt });

                const payload = {
                    messages: messages,
                    model: "grok-beta",
                    stream: false,
                    temperature: 0.8
                };

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    throw new Error(`Grok API call failed: ${response.status} ${response.statusText}`);
                }

                const result = await response.json();
                return result.choices?.[0]?.message?.content || "The cosmic winds carry no clear message...";

            } catch (error) {
                console.error("Grok API Error:", error);
                if (error.message.includes("API key")) {
                    return "The Grok API key must be configured to access cosmic wisdom. Set your API key in the code.";
                }
                return "The aetheric connection is disrupted. The cosmic network seems unreachable.";
            } finally {
                if (button) {
                    button.disabled = false;
                    button.classList.remove('loading');
                    if(button.id === 'seasonal-vision-btn') button.innerHTML = '‚ú® Get Resonant Vision';
                    if(button.id === 'advisor-btn') button.innerHTML = 'üìú Ask Advisor';
                }
            }
        }
        async function getSeasonalVision() {
            const systemPrompt = "You are a mystical storyteller for Resonant Sanctuary: The Weaver, a cosmic incremental game. Create poetic, ethereal visions about the sanctuary's future or cosmic events. Use mystical language and keep responses to 2-3 sentences.";

            const prompt = `Current sanctuary state: Energy production ${gameState.energyPerSecond.toFixed(1)}/s, Insight production ${gameState.insightPerSecond.toFixed(1)}/s. The sanctuary houses ${gameState.units.dreamers} dreamers and ${gameState.units.weavers} weavers, with ${gameState.harmony.toFixed(1)}% harmony. Provide a mystical seasonal vision or cosmic forecast.`;

            const story = await callGrok(prompt, seasonalVisionBtn, systemPrompt);
            log(`‚ú® ${story}`, 'grok');
        }

        async function getAdvisorInsight() {
            const systemPrompt = "You are the Cosmic Advisor for Resonant Sanctuary: The Weaver. Provide brief, mystical advice using cosmic language. Always start responses with 'The sanctuary whispers...' and keep under 30 words. Focus on actionable game advice.";

            const prompt = `Current stats: Energy: ${formatNumber(gameState.energy)}, Insight: ${formatNumber(gameState.insight)}, Energy/s: ${formatNumber(gameState.energyPerSecond)}, Insight/s: ${formatNumber(gameState.insightPerSecond)}, Harmony: ${gameState.harmony.toFixed(1)}%. What should the player focus on next?`;

            const advice = await callGrok(prompt, advisorBtn, systemPrompt);
            log(`üìú ${advice}`, 'grok');
        }

        // --- TDD: Intelligent Creatures Global Functions ---
        window.spawnIntelligentCreature = (type) => {
            const creature = spawnIntelligentCreature(type);
            updateCreatureCount();
            return creature;
        };

        const updateCreatureCount = () => {
            const countElement = document.getElementById('creature-count');
            if (countElement) {
                countElement.textContent = gameState.intelligentCreatures.length;
            }
        };

        // --- Game Logic ---
        window.createUnit = (key) => {
            const unitConf = unitsConfig[key];
            const cost = gameState.unitCosts[key];
            if (gameState[unitConf.costResource] >= cost) {
                gameState[unitConf.costResource] -= cost;
                gameState.units[key]++;
                gameState.unitCosts[key] *= 1.15;
                if (key === 'dreamers') addSprite('crystal_tree');
                if (key === 'weavers') addSprite('dome');
                log(`A new ${unitConf.name} joins the sanctuary.`, 'success');

                // TDD Task 1: Add movable sprite for the new unit
                addSprite(key, 1);

                // TDD Fix: Don't immediately re-render UI, let game loop handle it
            }
        };

        window.upgradeNode = (key) => {
            const nodeConf = nodesConfig[key];
            const cost = gameState.nodeCosts[key];
            if (gameState[nodeConf.costResource] >= cost) {
                gameState[nodeConf.costResource] -= cost;
                gameState.nodes[key]++;
                gameState.nodeCosts[key] *= 2.5;
                if (nodeConf.harmony) {
                    gameState.harmony = Math.min(100, gameState.harmony + nodeConf.harmony);
                }
                if (key === 'sustenance') addSprite('garden');
                log(`Attuned the ${nodeConf.name}. Its resonance grows stronger.`, 'success');
                // TDD Fix: Don't immediately re-render UI, let game loop handle it
            }
        };
        
        const updateGameState = (delta) => {
            // Calculate production per second
            let energyPerSecond = gameState.units.weavers * unitsConfig.weavers.baseEnergy;
            let insightPerSecond = gameState.units.dreamers * unitsConfig.dreamers.baseInsight;

            // Apply node bonuses
            let costMultiplier = 1;
            energyPerSecond *= Math.pow(nodesConfig.energy.multiplier, gameState.nodes.energy);
            insightPerSecond *= Math.pow(nodesConfig.sustenance.multiplier, gameState.nodes.sustenance);
            const cohesionBonus = Math.pow(nodesConfig.cohesion.multiplier, gameState.nodes.cohesion);
            energyPerSecond *= cohesionBonus;
            insightPerSecond *= cohesionBonus;
            costMultiplier *= Math.pow(nodesConfig.cycling.multiplier, gameState.nodes.cycling);

            // Update unit costs based on multiplier (visual only, actual cost is in gameState)
            // This is a simplification; a more robust model would adjust the base cost.

            gameState.energyPerSecond = energyPerSecond;
            gameState.insightPerSecond = insightPerSecond;

            // Add resources
            gameState.energy += energyPerSecond * delta;
            gameState.insight += insightPerSecond * delta;
        };

        let lastUIUpdate = 0;
        const gameLoop = () => {
            const now = Date.now();
            const delta = (now - gameState.lastUpdate) / 1000; // Time in seconds

            updateGameState(delta);

            // TDD Fix: Update UI less frequently to prevent button blinking
            if (now - lastUIUpdate > 500) { // Increased from 100ms to 500ms
                renderUI();
                lastUIUpdate = now;
            }
            drawSanctuary();

            gameState.lastUpdate = now;
            requestAnimationFrame(gameLoop);
        };

        // --- TDD Test Suite ---
        const runTests = () => {
            console.log("--- Running TDD Test Suite ---");

            // Test 1: Initial game state
            const initialState = { ...gameState };
            console.assert(initialState.energy === 10, "Test 1.1 Failed: Initial energy should be 10.");
            console.assert(initialState.insight === 0, "Test 1.2 Failed: Initial insight should be 0.");
            console.assert(initialState.harmony === 50, "Test 1.3 Failed: Initial harmony should be 50.");

            // Test 1.4: Initial energy is displayed in the UI
            renderUI();
            const energyText = document.querySelector('#stats-bar .stat-card:nth-child(1) .text-xl').textContent;
            console.assert(parseFloat(energyText) === 10.0, "Test 1.4 Failed: Initial energy displayed should be 10.0.");

            // Test 2: Composting upgrade increases harmony
            const initialHarmony = initialState.harmony;
            gameState.insight = 200; // Ensure we can afford the upgrade
            upgradeNode('cycling');
            console.assert(gameState.harmony > initialHarmony, "Test 2.1 Failed: Composting upgrade should increase harmony.");

            // Test 3: Creating a unit deducts resources
            const initialEnergy = gameState.energy;
            createUnit('dreamers');
            console.assert(gameState.energy < initialEnergy, "Test 3.1 Failed: Creating a dreamer should deduct energy.");

            console.log("--- TDD Test Suite Finished ---");
        };

        // --- Initialization ---
        const init = () => {
            log("Welcome, Weaver. The sanctuary awakens with your first Dreamer and Weaver.", "success");
            log("üîë Grok API integration ready - key will be requested when needed", "info");

            // Initialize sprites
            addSprite('dome', 1);
            addSprite('crystal_tree', 1);

            // Initialize event listeners
            advisorBtn.addEventListener('click', getAdvisorInsight);
            seasonalVisionBtn.addEventListener('click', getSeasonalVision);

            // TDD API Key Popup Event Listeners
            const saveKeyBtn = document.getElementById('save-api-key');
            const cancelKeyBtn = document.getElementById('cancel-api-key');
            const apiKeyInput = document.getElementById('api-key-input');

            saveKeyBtn.addEventListener('click', () => {
                const key = apiKeyInput.value.trim();

                if (!key) {
                    showApiKeyError('Please enter an API key');
                    return;
                }

                if (key.length < 10) {
                    showApiKeyError('API key seems too short. Please check your key.');
                    return;
                }

                if (key.includes(' ')) {
                    showApiKeyError('API key should not contain spaces');
                    return;
                }

                if (saveApiKey(key)) {
                    hideApiKeyPopup();
                    log('üîë Grok API key saved successfully! You can now access cosmic wisdom.', 'success');
                } else {
                    showApiKeyError('Failed to save API key. Please try again.');
                }
            });

            cancelKeyBtn.addEventListener('click', () => {
                hideApiKeyPopup();
            });

            // Handle Enter key in API key input
            apiKeyInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    saveKeyBtn.click();
                }
            });

            // Handle Escape key to close popup
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    const popup = document.getElementById('api-key-popup');
                    if (!popup.classList.contains('hidden')) {
                        hideApiKeyPopup();
                    }
                }
            });

            // TDD Task 1: Mouse event listeners for drag-and-drop
            canvas.addEventListener('mousedown', (e) => {
                const coords = getCanvasCoordinates(e);
                const unit = getUnitAtPosition(coords.x, coords.y);

                if (unit && unit.movable) {
                    dragState.isDragging = true;
                    dragState.draggedUnit = unit;
                    dragState.dragOffsetX = coords.x - unit.x;
                    dragState.dragOffsetY = coords.y - unit.y;

                    // Stop auto-wandering while dragging
                    unit.wanderCenter = { x: unit.x, y: unit.y };

                    canvas.style.cursor = 'grabbing';
                }
            });

            canvas.addEventListener('mousemove', (e) => {
                const coords = getCanvasCoordinates(e);

                if (dragState.isDragging && dragState.draggedUnit) {
                    // Update dragged unit position
                    dragState.draggedUnit.targetX = coords.x - dragState.dragOffsetX;
                    dragState.draggedUnit.targetY = coords.y - dragState.dragOffsetY;

                    // Keep within canvas bounds
                    dragState.draggedUnit.targetX = Math.max(50, Math.min(canvas.width - 50, dragState.draggedUnit.targetX));
                    dragState.draggedUnit.targetY = Math.max(50, Math.min(canvas.height - 50, dragState.draggedUnit.targetY));
                } else {
                    // Update hover state
                    const unit = getUnitAtPosition(coords.x, coords.y);
                    dragState.hoveredUnit = unit;

                    if (unit && unit.movable) {
                        canvas.style.cursor = 'grab';
                    } else {
                        canvas.style.cursor = 'default';
                    }
                }
            });

            canvas.addEventListener('mouseup', (e) => {
                if (dragState.isDragging && dragState.draggedUnit) {
                    // Update wander center to new position
                    dragState.draggedUnit.wanderCenter = {
                        x: dragState.draggedUnit.x,
                        y: dragState.draggedUnit.y
                    };

                    log(`Moved ${dragState.draggedUnit.type} to new location`, 'info');
                }

                dragState.isDragging = false;
                dragState.draggedUnit = null;
                dragState.dragOffsetX = 0;
                dragState.dragOffsetY = 0;
                canvas.style.cursor = 'default';
            });

            canvas.addEventListener('mouseleave', (e) => {
                dragState.hoveredUnit = null;
                canvas.style.cursor = 'default';
            });

            runTests(); // Run TDD tests on startup
            gameLoop();
        };

        init();
    </script>
</body>
</html>
