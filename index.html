<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TerraFlow: Roots of Transition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            background-color: #0c0a1e; /* Deep cosmic blue */
        }
        .stat-card {
            background-color: rgba(18, 16, 46, 0.7); /* Dark blue/purple */
            backdrop-filter: blur(10px);
            transition: all 0.2s ease-in-out;
            border: 1px solid rgba(76, 71, 128, 0.5);
        }
        .module-card {
            background-color: #1c1944; /* Muted cosmic blue */
            transition: all 0.2s ease-in-out;
            border: 1px solid rgba(76, 71, 128, 0.5);
        }
        .unit-card {
             background-color: #2a275c;
        }
        .log-panel {
            height: 150px;
            background-color: rgba(10, 8, 28, 0.9);
            border-top: 1px solid rgba(76, 71, 128, 0.5);
            resize: vertical;
            overflow: hidden;
            min-height: 100px;
            max-height: 500px;
            position: relative;
        }

        /* Resize handle styling */
        .log-panel::after {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 8px;
            background: linear-gradient(90deg, transparent, rgba(76, 71, 128, 0.8), transparent);
            cursor: ns-resize;
            border-radius: 0 0 4px 4px;
        }

        .log-panel:hover::after {
            background: linear-gradient(90deg, transparent, rgba(139, 92, 246, 0.8), transparent);
        }

        /* Minimap styling */
        #minimap-container {
            background-color: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(4px);
        }

        #minimap-container.transparent {
            background-color: rgba(0, 0, 0, 0.3);
        }

        #minimap-container.collapsed #minimap-content {
            display: none;
        }

        #minimap-container.dragging {
            cursor: grabbing !important;
            z-index: 100;
        }

        #minimap-header {
            user-select: none;
        }

        #minimap-header:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        canvas {
            border-radius: 0.75rem;
        }
        .grok-btn.loading, .grok-btn:disabled, button:disabled {
            cursor: not-allowed;
            background-color: #4a5568;
            opacity: 0.7;
        }

        /* TDD Fix: Custom scrollbar for log output */
        #log-output {
            scrollbar-width: thin;
            scrollbar-color: #4c1d95 #1e1b4b;
        }
        #log-output::-webkit-scrollbar {
            width: 8px;
        }
        #log-output::-webkit-scrollbar-track {
            background: #1e1b4b;
            border-radius: 4px;
        }
        #log-output::-webkit-scrollbar-thumb {
            background: #4c1d95;
            border-radius: 4px;
        }
        #log-output::-webkit-scrollbar-thumb:hover {
            background: #5b21b6;
        }

        /* Ensure log entries don't break layout */
        .log-entry {
            word-wrap: break-word;
            line-height: 1.4;
            margin-bottom: 0.25rem;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .log-entry {
            animation: fadeIn 0.5s ease-out;
        }

        /* Improved UI Styles */
        .tab-btn {
            color: #9CA3AF;
            background: transparent;
            border: none;
            cursor: pointer;
        }
        .tab-btn.active {
            color: #FFFFFF;
            background: #4F46E5;
        }
        .tab-btn:hover:not(.active) {
            color: #E5E7EB;
            background: #374151;
        }
        .tab-content {
            animation: fadeIn 0.2s ease-in-out;
        }

        /* Compact Stats */
        .stat-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }
        .stat-card {
            background: linear-gradient(135deg, rgba(79, 70, 229, 0.15), rgba(99, 102, 241, 0.05));
            border: 1px solid rgba(99, 102, 241, 0.3);
            border-radius: 6px;
            padding: 6px 8px;
            text-align: center;
            transition: all 0.2s ease;
            cursor: pointer;
        }
        .stat-card:hover {
            border-color: rgba(99, 102, 241, 0.5);
            transform: translateY(-1px);
            background: linear-gradient(135deg, rgba(79, 70, 229, 0.2), rgba(99, 102, 241, 0.1));
        }

        /* Compact Stats Styling */
        .stat-compact {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 80px;
        }

        .stat-mini {
            text-align: center;
            padding: 4px;
            border-radius: 4px;
            background: rgba(75, 85, 99, 0.3);
            transition: background 0.2s ease;
        }

        .stat-mini:hover {
            background: rgba(75, 85, 99, 0.5);
        }
        .stat-value {
            font-size: 1.1rem;
            font-weight: bold;
            color: #FFFFFF;
            line-height: 1;
        }
        .stat-label {
            font-size: 0.7rem;
            color: #A78BFA;
            margin-top: 2px;
            line-height: 1;
        }
        .stat-rate {
            font-size: 0.6rem;
            color: #10B981;
            margin-top: 1px;
            line-height: 1;
        }

        /* Resource change animations */
        .resource-increase {
            animation: resourcePulse 0.5s ease-out;
        }
        @keyframes resourcePulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); color: #10B981; }
            100% { transform: scale(1); }
        }

        /* Control vs Consciousness Resource Styling */
        .control-resource {
            border-left: 3px solid #DC2626; /* Red border for Control */
            background: linear-gradient(135deg, rgba(220, 38, 38, 0.1), rgba(127, 29, 29, 0.05));
        }

        .consciousness-resource {
            border-left: 3px solid #059669; /* Green border for Consciousness */
            background: linear-gradient(135deg, rgba(5, 150, 105, 0.1), rgba(6, 78, 59, 0.05));
        }

        .control-resource:hover {
            background: linear-gradient(135deg, rgba(220, 38, 38, 0.15), rgba(127, 29, 29, 0.08));
        }

        .consciousness-resource:hover {
            background: linear-gradient(135deg, rgba(5, 150, 105, 0.15), rgba(6, 78, 59, 0.08));
        }

        /* Ruler Path Building Styling */
        .ruler-building-tier-1 {
            border-left: 3px solid #DC2626;
            background: linear-gradient(135deg, rgba(220, 38, 38, 0.1), rgba(127, 29, 29, 0.05));
        }

        .ruler-building-tier-2 {
            border-left: 3px solid #B91C1C;
            background: linear-gradient(135deg, rgba(185, 28, 28, 0.15), rgba(127, 29, 29, 0.08));
            box-shadow: 0 0 5px rgba(220, 38, 38, 0.3);
        }

        .ruler-building-tier-3 {
            border-left: 3px solid #991B1B;
            background: linear-gradient(135deg, rgba(153, 27, 27, 0.2), rgba(127, 29, 29, 0.1));
            box-shadow: 0 0 8px rgba(220, 38, 38, 0.4);
            animation: ominousPulse 3s infinite;
        }

        .ruler-building-tier-4 {
            border-left: 3px solid #7F1D1D;
            background: linear-gradient(135deg, rgba(127, 29, 29, 0.3), rgba(69, 10, 10, 0.15));
            box-shadow: 0 0 12px rgba(220, 38, 38, 0.6);
            animation: totalitarianPulse 2s infinite;
        }

        @keyframes ominousPulse {
            0%, 100% { box-shadow: 0 0 8px rgba(220, 38, 38, 0.4); }
            50% { box-shadow: 0 0 15px rgba(220, 38, 38, 0.7); }
        }

        @keyframes totalitarianPulse {
            0%, 100% {
                box-shadow: 0 0 12px rgba(220, 38, 38, 0.6);
                border-left-color: #7F1D1D;
            }
            50% {
                box-shadow: 0 0 20px rgba(220, 38, 38, 0.9);
                border-left-color: #DC2626;
            }
        }

        /* Gardener Path Building Styling */
        .gardener-building-tier-1 {
            border-left: 3px solid #059669;
            background: linear-gradient(135deg, rgba(5, 150, 105, 0.1), rgba(6, 78, 59, 0.05));
        }

        .gardener-building-tier-2 {
            border-left: 3px solid #047857;
            background: linear-gradient(135deg, rgba(4, 120, 87, 0.15), rgba(6, 78, 59, 0.08));
            box-shadow: 0 0 5px rgba(5, 150, 105, 0.3);
        }

        .gardener-building-tier-3 {
            border-left: 3px solid #065F46;
            background: linear-gradient(135deg, rgba(6, 95, 70, 0.2), rgba(6, 78, 59, 0.1));
            box-shadow: 0 0 8px rgba(5, 150, 105, 0.4);
            animation: enlightenedPulse 3s infinite;
        }

        .gardener-building-tier-4 {
            border-left: 3px solid #064E3B;
            background: linear-gradient(135deg, rgba(6, 78, 59, 0.3), rgba(4, 120, 87, 0.15));
            box-shadow: 0 0 12px rgba(5, 150, 105, 0.6);
            animation: ascensionPulse 2s infinite;
        }

        @keyframes enlightenedPulse {
            0%, 100% { box-shadow: 0 0 8px rgba(5, 150, 105, 0.4); }
            50% { box-shadow: 0 0 15px rgba(5, 150, 105, 0.7); }
        }

        @keyframes ascensionPulse {
            0%, 100% {
                box-shadow: 0 0 12px rgba(5, 150, 105, 0.6);
                border-left-color: #064E3B;
            }
            50% {
                box-shadow: 0 0 20px rgba(5, 150, 105, 0.9);
                border-left-color: #059669;
            }
        }

        /* Great Transition Progress Styling */
        .great-transition-progress {
            border-left: 3px solid #F59E0B; /* Golden border for the ultimate goal */
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.15), rgba(217, 119, 6, 0.08));
            position: relative;
            overflow: hidden;
        }

        .great-transition-progress:hover {
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.2), rgba(217, 119, 6, 0.1));
        }

        .great-transition-progress::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            animation: greatTransitionShimmer 3s infinite;
            pointer-events: none;
        }

        @keyframes greatTransitionShimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        /* Crisis Level Indicator Styling */
        .crisis-indicator {
            border-left: 3px solid #EF4444; /* Red border for crisis */
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.15), rgba(153, 27, 27, 0.08));
            position: relative;
            overflow: hidden;
        }

        .crisis-indicator:hover {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.2), rgba(153, 27, 27, 0.1));
        }

        .crisis-indicator.crisis-high {
            animation: crisisWarning 2s infinite;
        }

        @keyframes crisisWarning {
            0%, 100% {
                box-shadow: 0 0 8px rgba(239, 68, 68, 0.4);
                border-left-color: #EF4444;
            }
            50% {
                box-shadow: 0 0 15px rgba(239, 68, 68, 0.8);
                border-left-color: #DC2626;
            }
        }

        /* Tooltip styles */
        .tooltip {
            position: relative;
        }
        .tooltip:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
            white-space: nowrap;
            z-index: 1000;
            pointer-events: none;
        }
    </style>
</head>
<body class="text-indigo-100 flex flex-col h-screen">

    <!-- Top Bar -->
    <header class="w-full p-4 bg-[#1c1944] border-b border-indigo-900 shadow-lg z-10">
        <h1 class="text-2xl font-bold text-white">TerraFlow: Roots of Transition</h1>
    </header>

    <!-- Main Content -->
    <div class="flex flex-1 overflow-hidden">
        
        <!-- Improved Left Panel: Tabbed Interface -->
        <aside class="w-80 p-3 bg-[#1c1944] border-r border-indigo-900 flex flex-col">
            <!-- Tab Navigation -->
            <div class="flex mb-3 bg-indigo-900/30 rounded-lg p-1">
                <button id="tab-units" class="tab-btn flex-1 py-2 px-3 text-sm font-medium rounded-md transition-all active" onclick="switchTab('units')" title="Units (Hotkey: 1)">
                    ⚡ Units
                </button>
                <button id="tab-upgrades" class="tab-btn flex-1 py-2 px-3 text-sm font-medium rounded-md transition-all" onclick="switchTab('upgrades')" title="Upgrades (Hotkey: 2)">
                    🔮 Upgrades
                </button>
                <button id="tab-beings" class="tab-btn flex-1 py-2 px-3 text-sm font-medium rounded-md transition-all" onclick="switchTab('beings')" title="Intelligent Beings (Hotkey: 3)">
                    🧠 Beings
                </button>
                <button id="tab-ai" class="tab-btn flex-1 py-2 px-3 text-sm font-medium rounded-md transition-all" onclick="switchTab('ai')" title="Conversational AI (Hotkey: 4)">
                    💬 AI
                </button>
                <button id="tab-progress" class="tab-btn flex-1 py-2 px-3 text-sm font-medium rounded-md transition-all" onclick="switchTab('progress')" title="Achievements & Goals (Hotkey: 5)">
                    ⭐ Goals
                </button>
                <button id="tab-paths" class="tab-btn flex-1 py-2 px-3 text-sm font-medium rounded-md transition-all" onclick="switchTab('paths')" title="Path of Rulers vs Gardeners (Hotkey: 6)">
                    🌳 Paths
                </button>
            </div>

            <!-- Tab Content -->
            <div class="flex-1 overflow-y-auto">
                <!-- Units Tab -->
                <div id="content-units" class="tab-content">
                    <div id="units-panel" class="space-y-2">
                        <!-- Unit creation cards will be injected here -->
                    </div>
                </div>

                <!-- Upgrades Tab -->
                <div id="content-upgrades" class="tab-content hidden">
                    <div id="modules-panel" class="space-y-2">
                        <!-- Module cards will be injected here -->
                    </div>
                </div>

                <!-- Intelligent Beings Tab -->
                <div id="content-beings" class="tab-content hidden">
                    <div class="space-y-2">
                        <button onclick="spawnIntelligentCreature('cosmicSage')"
                                class="w-full p-2 rounded bg-purple-600 hover:bg-purple-700 text-white text-sm transition-colors">
                            🧙‍♂️ Cosmic Sage <span class="float-right text-xs opacity-75">Teaches</span>
                        </button>

                        <button onclick="spawnIntelligentCreature('voidExplorer')"
                                class="w-full p-2 rounded bg-gray-600 hover:bg-gray-700 text-white text-sm transition-colors">
                            🌌 Void Explorer <span class="float-right text-xs opacity-75">Explores</span>
                        </button>

                        <button onclick="spawnIntelligentCreature('harmonyKeeper')"
                                class="w-full p-2 rounded bg-green-600 hover:bg-green-700 text-white text-sm transition-colors">
                            ✨ Harmony Keeper <span class="float-right text-xs opacity-75">Heals</span>
                        </button>

                        <div class="text-xs text-indigo-300 mt-2 p-2 bg-indigo-900/20 rounded">
                            <strong>Active:</strong> <span id="creature-count">0</span>
                        </div>
                    </div>
                </div>

                <!-- Conversational AI Tab -->
                <div id="content-ai" class="tab-content hidden">
                    <div class="space-y-2">
                        <button onclick="spawnConversationalUnit('philosopherDreamer')"
                                class="w-full p-2 rounded bg-indigo-600 hover:bg-indigo-700 text-white text-sm transition-colors">
                            🧙‍♂️ Philosopher <span class="float-right text-xs opacity-75">Wisdom</span>
                        </button>

                        <button onclick="spawnConversationalUnit('artisticWeaver')"
                                class="w-full p-2 rounded bg-pink-600 hover:bg-pink-700 text-white text-sm transition-colors">
                            🎨 Artist <span class="float-right text-xs opacity-75">Beauty</span>
                        </button>

                        <button onclick="spawnConversationalUnit('curiousExplorer')"
                                class="w-full p-2 rounded bg-emerald-600 hover:bg-emerald-700 text-white text-sm transition-colors">
                            🔍 Explorer <span class="float-right text-xs opacity-75">Discovery</span>
                        </button>

                        <div class="text-xs text-purple-300 mt-2 p-2 bg-purple-900/20 rounded">
                            <strong>Conversational:</strong> <span id="conversational-count">0</span><br>
                            <em>Click beings to chat</em>
                        </div>

                        <hr class="border-indigo-700 my-3">

                        <button id="advisor-btn" class="grok-btn bg-blue-600 hover:bg-blue-700 text-white text-sm py-2 px-3 rounded transition-colors mb-2">
                            📜 Ask Advisor
                        </button>
                        <button id="seasonal-vision-btn" class="grok-btn bg-purple-600 hover:bg-purple-700 text-white text-sm py-2 px-3 rounded transition-colors">
                            ✨ Get Vision
                        </button>

                        <hr class="border-indigo-700 my-3">

                        <div class="text-xs text-gray-400 mb-2">Save & Load</div>
                        <div class="grid grid-cols-2 gap-2">
                            <button id="save-btn" class="bg-green-600 hover:bg-green-700 text-white text-xs py-1 px-2 rounded transition-colors">
                                💾 Save
                            </button>
                            <button id="load-btn" class="bg-blue-600 hover:bg-blue-700 text-white text-xs py-1 px-2 rounded transition-colors">
                                📁 Load
                            </button>
                            <button id="export-btn" class="bg-yellow-600 hover:bg-yellow-700 text-white text-xs py-1 px-2 rounded transition-colors">
                                📤 Export
                            </button>
                            <button id="import-btn" class="bg-orange-600 hover:bg-orange-700 text-white text-xs py-1 px-2 rounded transition-colors">
                                📥 Import
                            </button>
                        </div>
                        <div class="mt-2">
                            <button id="autosave-toggle" class="bg-gray-600 hover:bg-gray-700 text-white text-xs py-1 px-2 rounded transition-colors w-full">
                                🔄 Auto-save: ON
                            </button>
                        </div>
                        <input type="file" id="import-file" accept=".json" style="display: none;">
                    </div>
                </div>

                <!-- Progress Tab -->
                <div id="content-progress" class="tab-content hidden">
                    <div class="space-y-3">
                        <div class="mb-3">
                            <h3 class="text-sm font-medium text-white mb-2">🎯 Active Goals</h3>
                            <div id="active-goals" class="space-y-2">
                                <!-- Active goals will be populated here -->
                            </div>
                        </div>

                        <div class="mb-3">
                            <h3 class="text-sm font-medium text-white mb-2">⭐ Recent Achievements</h3>
                            <div id="recent-achievements" class="space-y-2">
                                <!-- Recent achievements will be populated here -->
                            </div>
                        </div>

                        <div class="text-xs text-gray-300 p-2 bg-gray-900/30 rounded">
                            <div><strong>Progress:</strong></div>
                            <div>Achievements: <span id="achievement-count">0</span></div>
                            <div>Goals Completed: <span id="goals-completed-count">0</span></div>
                            <div>Play Time: <span id="play-time">0m</span></div>
                        </div>
                    </div>
                </div>

                <!-- Paths Tab -->
                <div id="content-paths" class="tab-content hidden">
                    <div class="space-y-4">
                        <div class="text-center mb-4">
                            <h3 class="text-lg font-bold text-white mb-2">The Great Transition</h3>
                            <p class="text-sm text-gray-300">Choose your path: Control through dominance or Consciousness through harmony</p>
                        </div>

                        <!-- Path of the Rulers -->
                        <div class="border border-red-600 rounded-lg p-3 bg-red-900/20">
                            <div class="flex justify-between items-center mb-2">
                                <h4 class="font-bold text-red-400">🏛️ Path of the Rulers (Tree of Knowledge)</h4>
                                <span id="ruler-building-count" class="text-xs bg-red-800 text-red-200 px-2 py-1 rounded">0 Built</span>
                            </div>
                            <p class="text-xs text-red-300 mb-3">Immediate power through control and efficiency. Generates Control but suppresses Consciousness.</p>
                            <div class="text-xs text-red-500 mb-3">
                                ⚠️ Warning: Higher tiers lead to increasingly authoritarian outcomes
                            </div>
                            <div id="ruler-buildings" class="space-y-2">
                                <!-- Ruler buildings will be populated here -->
                            </div>
                        </div>

                        <!-- Path of the Gardeners -->
                        <div class="border border-green-600 rounded-lg p-3 bg-green-900/20">
                            <div class="flex justify-between items-center mb-2">
                                <h4 class="font-bold text-green-400">🌱 Path of the Gardeners (Tree of Life)</h4>
                                <span id="gardener-building-count" class="text-xs bg-green-800 text-green-200 px-2 py-1 rounded">0 Built</span>
                            </div>
                            <p class="text-xs text-green-300 mb-3">Sustainable growth through consciousness and harmony. Generates Consciousness but reduces Control.</p>
                            <div class="text-xs text-green-500 mb-3">
                                ✨ Note: Higher tiers lead to increasingly enlightened outcomes
                            </div>
                            <div id="gardener-buildings" class="space-y-2">
                                <!-- Gardener buildings will be populated here -->
                            </div>
                        </div>

                        <div class="text-xs text-gray-400 p-2 bg-gray-900/30 rounded">
                            <div><strong>Warning:</strong> Each path shapes humanity's future.</div>
                            <div>Extreme imbalance creates Entropy and risks failure.</div>
                            <div>The Great Transition requires wisdom in your choices.</div>
                        </div>
                    </div>
                </div>
            </div>
        </aside>

        <!-- Center Panel: Village View & Compact Stats -->
        <main class="flex-1 flex flex-col p-3">
            <!-- Player Switch Controls -->
            <div id="player-controls" class="mb-2">
                <div class="flex items-center justify-center bg-gray-800 rounded-lg p-2 border border-gray-600 space-x-3">
                    <div class="text-xs text-gray-400">Active Player:</div>
                    <button id="gardener-player-btn" class="px-3 py-1 text-xs rounded transition-all bg-green-700 text-green-200 border border-green-600 hover:bg-green-600">
                        🌱 Gardener
                    </button>
                    <button id="ruler-player-btn" class="px-3 py-1 text-xs rounded transition-all bg-gray-700 text-gray-300 border border-gray-600 hover:bg-gray-600">
                        🏛️ Ruler
                    </button>
                    <button id="alliance-mode-btn" class="px-3 py-1 text-xs rounded transition-all bg-purple-700 text-purple-200 border border-purple-600 hover:bg-purple-600" style="display: none;">
                        🤝 Alliance Mode
                    </button>
                    <button id="debug-btn" class="px-3 py-1 text-xs rounded transition-all bg-red-700 text-red-200 border border-red-600 hover:bg-red-600" onclick="window.debugCommands.enable(); window.debugCommands.viewer();">
                        🐛 Debug
                    </button>
                    <div id="current-player-indicator" class="text-xs font-bold text-green-400">
                        🌱 Gardener's Turn
                    </div>
                </div>
            </div>

            <!-- Compact Horizontal Stats Bar -->
            <div id="stats-bar" class="mb-2">
                <div class="flex items-center justify-between bg-gray-900 rounded-lg p-2 border border-gray-700">
                    <!-- Core Resources (Always Visible) -->
                    <div class="flex space-x-6">
                        <div class="stat-compact tooltip" data-tooltip="Energy - Create Dreamers (D key)">
                            <span class="text-blue-400 font-bold text-lg" id="energy">20</span>
                            <span class="text-xs text-gray-400">/<span id="energy-cap">100</span></span>
                            <span class="text-xs text-gray-300">⚡ Energy</span>
                            <span class="text-xs text-blue-300">+<span id="energy-rate">0.0</span>/s</span>
                        </div>
                        <div class="stat-compact tooltip" data-tooltip="Insight - Create Weavers (W key)">
                            <span class="text-purple-400 font-bold text-lg" id="insight">5</span>
                            <span class="text-xs text-gray-400">/<span id="insight-cap">50</span></span>
                            <span class="text-xs text-gray-300">🔮 Insight</span>
                            <span class="text-xs text-purple-300">+<span id="insight-rate">0.0</span>/s</span>
                        </div>
                        <div class="stat-compact tooltip" data-tooltip="The Great Transition Balance">
                            <div class="flex space-x-2">
                                <div class="text-center">
                                    <span class="text-green-400 font-bold" id="consciousness">10</span>
                                    <div class="text-xs text-gray-300">🌱 Consciousness</div>
                                </div>
                                <div class="text-gray-500 self-center">vs</div>
                                <div class="text-center">
                                    <span class="text-red-400 font-bold" id="control">0</span>
                                    <div class="text-xs text-gray-300">👑 Control</div>
                                </div>
                            </div>
                        </div>
                        <div class="stat-compact tooltip great-transition-progress" data-tooltip="Planetary Consciousness - Reach 100 to win!">
                            <span class="text-yellow-400 font-bold text-xl" id="planetary-consciousness">10</span>
                            <span class="text-xs text-gray-300">🌍 Planetary</span>
                            <div class="w-16 bg-gray-700 rounded-full h-1 mt-1">
                                <div class="bg-yellow-400 h-1 rounded-full transition-all duration-300" style="width: 10%"></div>
                            </div>
                        </div>

                        <!-- Alliance Status -->
                        <div id="alliance-status" class="stat-compact tooltip" data-tooltip="Alliance Integration - Unity of Rulers and Gardeners" style="display: none;">
                            <span class="text-purple-400 font-bold text-xl" id="integration-level">0%</span>
                            <span class="text-xs text-gray-300">🤝 Alliance</span>
                            <div class="w-16 bg-gray-700 rounded-full h-1 mt-1">
                                <div id="integration-bar" class="bg-purple-400 h-1 rounded-full transition-all duration-300" style="width: 0%"></div>
                            </div>
                        </div>

                        <!-- AI Player Status -->
                        <div id="ai-status" class="stat-compact tooltip" data-tooltip="AI Ruler Player - Your potential ally">
                            <span class="text-orange-400 font-bold text-lg" id="ai-control">10</span>
                            <span class="text-xs text-gray-300">🏛️ AI Ruler</span>
                            <div class="text-xs text-orange-300" id="ai-buildings">0 Buildings</div>
                            <div id="ai-activity-indicator" class="text-xs text-green-400">⚡ Active</div>
                        </div>
                    </div>

                    <!-- Control Buttons -->
                    <div class="flex space-x-2">
                        <button id="new-game-main-btn" class="bg-red-700 hover:bg-red-600 text-white text-xs px-2 py-1 rounded border border-red-600 font-bold" title="Start New Game (Clears All Progress)">
                            🔄 New Game
                        </button>
                        <button id="stats-toggle" class="bg-gray-700 hover:bg-gray-600 text-white text-xs px-2 py-1 rounded border border-gray-600" title="Show/Hide Extended Stats">
                            📊 More
                        </button>
                    </div>
                </div>

                <!-- Extended Stats (Collapsible) -->
                <div id="extended-stats" class="hidden mt-2 bg-gray-900 rounded-lg p-3 border border-gray-700">
                    <div class="grid grid-cols-4 gap-4">
                        <!-- Secondary Resources -->
                        <div class="stat-mini tooltip" data-tooltip="Harmony - Affects all production efficiency">
                            <div class="text-sm font-bold text-green-300" id="harmony">75</div>
                            <div class="text-xs text-gray-400">🎵 Harmony</div>
                        </div>
                        <div class="stat-mini tooltip" data-tooltip="Inspiration - Generated by unit interactions">
                            <div class="text-sm font-bold text-pink-300" id="inspiration">0</div>
                            <div class="text-xs text-gray-400">✨ Inspiration</div>
                        </div>
                        <div class="stat-mini tooltip" data-tooltip="Wisdom - Generated by philosophical beings">
                            <div class="text-sm font-bold text-indigo-300" id="wisdom">0</div>
                            <div class="text-xs text-gray-400">📚 Wisdom</div>
                        </div>
                        <div class="stat-mini tooltip crisis-indicator" data-tooltip="Crisis Level - High levels trigger the Four Horsemen">
                            <div class="text-sm font-bold text-red-300" id="crisis-level">0</div>
                            <div class="text-xs text-gray-400">⚠️ Crisis</div>
                        </div>
                    </div>

                    <!-- Unit Information -->
                    <div class="mt-3 pt-3 border-t border-gray-700">
                        <div class="text-xs text-gray-400 mb-2">🏛️ Sanctuary Status</div>
                        <div class="grid grid-cols-3 gap-2 text-xs">
                            <div class="text-center">
                                <div class="text-cyan-300 font-bold" id="total-units">0</div>
                                <div class="text-gray-400">Total Units</div>
                            </div>
                            <div class="text-center">
                                <div class="text-blue-300 font-bold" id="zoom-level">100%</div>
                                <div class="text-gray-400">Zoom Level</div>
                            </div>
                            <div class="text-center">
                                <div class="text-purple-300 font-bold"><span id="visible-units">0</span>/<span id="total-units-mini">0</span></div>
                                <div class="text-gray-400">Visible</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Unit Information Panel -->
                <div id="unit-info-panel" class="hidden mt-2 bg-gray-900 rounded-lg p-3 border border-gray-700">
                    <div class="flex justify-between items-center mb-2">
                        <div class="text-sm font-bold text-white">📋 Unit Information</div>
                        <button id="close-unit-info" class="text-gray-400 hover:text-white text-xs">✕</button>
                    </div>
                    <div id="unit-info-content">
                        <!-- Unit details will be populated here -->
                    </div>
                </div>
            </div>

            <!-- Village Canvas -->
            <div class="flex-1 relative">
                <canvas id="village-canvas" class="w-full h-full"></canvas>

                <!-- Canvas Controls -->
                <div class="absolute top-2 right-2 flex flex-col space-y-1">
                    <!-- View Controls -->
                    <div class="bg-gray-900 bg-opacity-90 rounded-lg p-1 border border-gray-600">
                        <div class="flex space-x-1">
                            <button id="zoom-in-btn" class="bg-gray-700 hover:bg-gray-600 text-white text-xs px-2 py-1 rounded" title="Zoom In">🔍+</button>
                            <button id="zoom-out-btn" class="bg-gray-700 hover:bg-gray-600 text-white text-xs px-2 py-1 rounded" title="Zoom Out">🔍-</button>
                            <button id="reset-view-btn" class="bg-blue-700 hover:bg-blue-600 text-white text-xs px-2 py-1 rounded" title="Center View">🎯</button>
                        </div>
                    </div>

                    <!-- Help -->
                    <div class="bg-gray-900 bg-opacity-90 rounded-lg p-1 border border-gray-600">
                        <button id="help-btn" class="bg-blue-700 hover:bg-blue-600 text-white text-xs px-2 py-1 rounded" title="Show Controls Help">❓ Help</button>
                    </div>
                </div>



                <!-- Minimap - Enhanced with visibility controls -->
                <div id="minimap-container" class="absolute left-2 bg-black border border-gray-600 rounded z-50 transition-all duration-300" style="bottom: 210px;">
                    <!-- Minimap Header with Controls -->
                    <div class="text-xs text-gray-400 px-2 py-1 border-b border-gray-600 flex justify-between items-center cursor-move" id="minimap-header">
                        <span>Minimap</span>
                        <div class="flex space-x-1">
                            <!-- Transparency Toggle -->
                            <button id="minimap-transparency-btn" class="text-gray-400 hover:text-white text-xs" title="Toggle transparency">◐</button>
                            <!-- Collapse/Expand Toggle -->
                            <button id="minimap-collapse-btn" class="text-gray-400 hover:text-white text-xs" title="Collapse/Expand">−</button>
                            <!-- Hide/Show Toggle -->
                            <button id="minimap-hide-btn" class="text-gray-400 hover:text-white text-xs" title="Hide minimap">×</button>
                        </div>
                    </div>
                    <!-- Minimap Content -->
                    <div id="minimap-content">
                        <canvas id="minimap-canvas" width="120" height="90" class="block"></canvas>
                    </div>
                </div>

                <!-- Minimap Show Button (when hidden) -->
                <button id="minimap-show-btn" class="absolute left-2 bg-black bg-opacity-70 border border-gray-600 rounded z-50 px-2 py-1 text-xs text-gray-400 hover:text-white hidden transition-all duration-300" style="bottom: 210px;" title="Show minimap">
                    📍 Map
                </button>
            </div>
        </main>

    </div>

    <!-- Bottom Bar: Log & Help - Resizable -->
    <footer id="log-panel" class="log-panel w-full border-t border-indigo-900">
        <div class="p-3 h-full flex">
            <!-- Log Section -->
            <div class="flex-1 flex flex-col mr-3">
                <h3 class="font-semibold text-base mb-2 text-indigo-200 flex-shrink-0">Aetheric Log</h3>
                <div id="log-output" class="text-sm text-indigo-300 space-y-1 flex-1 overflow-y-auto pr-2"></div>
            </div>

            <!-- Help Section -->
            <div class="w-64 flex flex-col border-l border-indigo-700 pl-3">
                <h3 class="font-semibold text-base mb-2 text-indigo-200 flex-shrink-0">Quick Help</h3>
                <div class="text-xs text-indigo-300 space-y-1 overflow-y-auto">
                    <div class="mb-2">
                        <div class="text-indigo-200 font-medium">Tabs:</div>
                        <div>1-4: Switch tabs</div>
                    </div>
                    <div class="mb-2">
                        <div class="text-indigo-200 font-medium">Units:</div>
                        <div>D: Create Dreamer</div>
                        <div>W: Create Weaver</div>
                    </div>
                    <div class="mb-2">
                        <div class="text-indigo-200 font-medium">Beings:</div>
                        <div>S: Summon Sage</div>
                        <div>E: Void Explorer</div>
                        <div>H: Harmony Keeper</div>
                    </div>
                    <div class="mb-2">
                        <div class="text-indigo-200 font-medium">Other:</div>
                        <div>ESC: Close dialogs</div>
                        <div>Click beings to chat</div>
                    </div>
                </div>
            </div>
        </div>
    </footer>
    
    <!-- TDD Test Runner (Hidden) -->
    <div id="test-runner" style="display: none;"></div>

    <!-- TDD API Key Popup -->
    <div id="api-key-popup" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-gray-800 border border-indigo-600 p-6 rounded-lg max-w-md w-full mx-4 shadow-2xl">
            <h3 class="text-xl font-bold text-white mb-4">🔑 Configure Grok API Key</h3>
            <p class="text-gray-300 mb-4">To access cosmic wisdom and AI insights, please enter your Grok API key:</p>
            <p class="text-sm text-indigo-300 mb-4">Get your API key from <a href="https://x.ai" target="_blank" class="text-blue-400 hover:text-blue-300 underline">x.ai</a></p>
            <input type="password" id="api-key-input" class="w-full p-3 bg-gray-700 text-white rounded mb-2 border border-gray-600 focus:border-indigo-500 focus:outline-none" placeholder="Enter your Grok API key...">
            <div id="api-key-error" class="text-red-400 text-sm mb-4 hidden"></div>
            <div class="flex gap-3">
                <button id="save-api-key" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white py-2 px-4 rounded transition-colors">
                    💾 Save Key
                </button>
                <button id="cancel-api-key" class="flex-1 bg-gray-600 hover:bg-gray-700 text-white py-2 px-4 rounded transition-colors">
                    ❌ Cancel
                </button>
            </div>
        </div>
    </div>

    <script>
        // --- Canvas & DOM Elements ---
        // TDD FIX: Initialize DOM elements when DOM is ready
        let canvas, ctx, modulesPanel, unitsPanel, statsBar, logOutput, seasonalVisionBtn, advisorBtn;

        // Initialize DOM elements when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            canvas = document.getElementById('village-canvas');
            ctx = canvas ? canvas.getContext('2d') : null;
            modulesPanel = document.getElementById('modules-panel');
            unitsPanel = document.getElementById('units-panel');
            statsBar = document.getElementById('stats-bar');
            logOutput = document.getElementById('log-output');
            seasonalVisionBtn = document.getElementById('seasonal-vision-btn');
            advisorBtn = document.getElementById('advisor-btn');

            console.log('DOM elements initialized:', {
                canvas: !!canvas,
                modulesPanel: !!modulesPanel,
                unitsPanel: !!unitsPanel,
                statsBar: !!statsBar,
                logOutput: !!logOutput,
                seasonalVisionBtn: !!seasonalVisionBtn,
                advisorBtn: !!advisorBtn
            });

            // Initialize log panel resizing
            initializeLogPanelResizing();

            // Initialize minimap controls
            initializeMinimapControls();

            // Initialize the game after DOM is ready
            init();
        });

        // --- Log Panel Resizing Functionality ---
        const initializeLogPanelResizing = () => {
            const logPanel = document.getElementById('log-panel');
            if (!logPanel) return;

            // Load saved height from localStorage
            const savedHeight = localStorage.getItem('terraflow_log_panel_height');
            if (savedHeight) {
                logPanel.style.height = savedHeight + 'px';
            }

            // Create a more visible resize handle
            const resizeHandle = document.createElement('div');
            resizeHandle.className = 'log-resize-handle';
            resizeHandle.innerHTML = '⋯⋯⋯'; // Three sets of dots to indicate draggable
            resizeHandle.title = 'Drag to resize the aetheric log panel';
            resizeHandle.style.cssText = `
                position: absolute;
                top: -6px;
                left: 50%;
                transform: translateX(-50%);
                width: 100px;
                height: 12px;
                background: linear-gradient(90deg, transparent, rgba(139, 92, 246, 0.6), transparent);
                cursor: ns-resize;
                border-radius: 6px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 10px;
                color: rgba(139, 92, 246, 0.8);
                transition: all 0.2s ease;
                z-index: 10;
                letter-spacing: 2px;
            `;

            // Add hover effect
            resizeHandle.addEventListener('mouseenter', () => {
                resizeHandle.style.background = 'linear-gradient(90deg, transparent, rgba(139, 92, 246, 0.9), transparent)';
                resizeHandle.style.color = 'rgba(139, 92, 246, 1)';
            });

            resizeHandle.addEventListener('mouseleave', () => {
                resizeHandle.style.background = 'linear-gradient(90deg, transparent, rgba(139, 92, 246, 0.6), transparent)';
                resizeHandle.style.color = 'rgba(139, 92, 246, 0.8)';
            });

            logPanel.appendChild(resizeHandle);

            // Resizing functionality
            let isResizing = false;
            let startY = 0;
            let startHeight = 0;

            const startResize = (e) => {
                isResizing = true;
                startY = e.clientY;
                startHeight = parseInt(document.defaultView.getComputedStyle(logPanel).height, 10);
                document.addEventListener('mousemove', doResize);
                document.addEventListener('mouseup', stopResize);
                document.body.style.cursor = 'ns-resize';
                document.body.style.userSelect = 'none';
                e.preventDefault();
            };

            const doResize = (e) => {
                if (!isResizing) return;

                const deltaY = startY - e.clientY; // Inverted because we want to resize upward
                const newHeight = Math.max(100, Math.min(500, startHeight + deltaY));

                logPanel.style.height = newHeight + 'px';

                // Save to localStorage
                localStorage.setItem('terraflow_log_panel_height', newHeight);
            };

            const stopResize = () => {
                isResizing = false;
                document.removeEventListener('mousemove', doResize);
                document.removeEventListener('mouseup', stopResize);
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
            };

            // Add event listeners
            resizeHandle.addEventListener('mousedown', startResize);

            // Also allow resizing by dragging the top border of the log panel
            logPanel.addEventListener('mousedown', (e) => {
                if (e.offsetY <= 8) { // Only if clicking near the top
                    startResize(e);
                }
            });

            console.log('Log panel resizing initialized');
        };

        // --- Minimap Controls Functionality ---
        const initializeMinimapControls = () => {
            const minimapContainer = document.getElementById('minimap-container');
            const minimapContent = document.getElementById('minimap-content');
            const minimapHeader = document.getElementById('minimap-header');
            const transparencyBtn = document.getElementById('minimap-transparency-btn');
            const collapseBtn = document.getElementById('minimap-collapse-btn');
            const hideBtn = document.getElementById('minimap-hide-btn');
            const showBtn = document.getElementById('minimap-show-btn');

            if (!minimapContainer) return;

            // Load saved settings
            const savedSettings = {
                visible: localStorage.getItem('terraflow_minimap_visible') !== 'false',
                collapsed: localStorage.getItem('terraflow_minimap_collapsed') === 'true',
                transparent: localStorage.getItem('terraflow_minimap_transparent') === 'true',
                position: JSON.parse(localStorage.getItem('terraflow_minimap_position') || '{"bottom": "210px", "left": "8px"}')
            };

            // Apply saved settings
            if (!savedSettings.visible) {
                minimapContainer.style.display = 'none';
                showBtn.classList.remove('hidden');
            }

            if (savedSettings.collapsed) {
                minimapContainer.classList.add('collapsed');
                collapseBtn.textContent = '+';
                collapseBtn.title = 'Expand';
            }

            if (savedSettings.transparent) {
                minimapContainer.classList.add('transparent');
                transparencyBtn.textContent = '◑';
            }

            // Apply saved position
            minimapContainer.style.bottom = savedSettings.position.bottom;
            minimapContainer.style.left = savedSettings.position.left;
            showBtn.style.bottom = savedSettings.position.bottom;
            showBtn.style.left = savedSettings.position.left;

            // Transparency toggle
            transparencyBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const isTransparent = minimapContainer.classList.toggle('transparent');
                transparencyBtn.textContent = isTransparent ? '◑' : '◐';
                localStorage.setItem('terraflow_minimap_transparent', isTransparent);
            });

            // Collapse/Expand toggle
            collapseBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const isCollapsed = minimapContainer.classList.toggle('collapsed');
                collapseBtn.textContent = isCollapsed ? '+' : '−';
                collapseBtn.title = isCollapsed ? 'Expand' : 'Collapse';
                localStorage.setItem('terraflow_minimap_collapsed', isCollapsed);
            });

            // Hide minimap
            hideBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                minimapContainer.style.display = 'none';
                showBtn.classList.remove('hidden');
                localStorage.setItem('terraflow_minimap_visible', 'false');
            });

            // Show minimap
            showBtn.addEventListener('click', () => {
                minimapContainer.style.display = 'block';
                showBtn.classList.add('hidden');
                localStorage.setItem('terraflow_minimap_visible', 'true');
            });

            // Dragging functionality
            let isDragging = false;
            let dragOffset = { x: 0, y: 0 };

            const startDrag = (e) => {
                if (e.target.tagName === 'BUTTON') return; // Don't drag when clicking buttons

                isDragging = true;
                minimapContainer.classList.add('dragging');

                const rect = minimapContainer.getBoundingClientRect();
                dragOffset.x = e.clientX - rect.left;
                dragOffset.y = e.clientY - rect.top;

                document.addEventListener('mousemove', doDrag);
                document.addEventListener('mouseup', stopDrag);
                e.preventDefault();
            };

            const doDrag = (e) => {
                if (!isDragging) return;

                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                const containerRect = minimapContainer.getBoundingClientRect();

                // Calculate new position
                let newLeft = e.clientX - dragOffset.x;
                let newBottom = viewportHeight - (e.clientY - dragOffset.y + containerRect.height);

                // Constrain to viewport
                newLeft = Math.max(0, Math.min(viewportWidth - containerRect.width, newLeft));
                newBottom = Math.max(0, Math.min(viewportHeight - containerRect.height, newBottom));

                minimapContainer.style.left = newLeft + 'px';
                minimapContainer.style.bottom = newBottom + 'px';
                showBtn.style.left = newLeft + 'px';
                showBtn.style.bottom = newBottom + 'px';
            };

            const stopDrag = () => {
                if (!isDragging) return;

                isDragging = false;
                minimapContainer.classList.remove('dragging');

                // Save position
                const position = {
                    left: minimapContainer.style.left,
                    bottom: minimapContainer.style.bottom
                };
                localStorage.setItem('terraflow_minimap_position', JSON.stringify(position));

                document.removeEventListener('mousemove', doDrag);
                document.removeEventListener('mouseup', stopDrag);
            };

            // Add drag event listeners
            minimapHeader.addEventListener('mousedown', startDrag);

            console.log('Minimap controls initialized');
        };

        // --- TDD: Centralized Game State Initialization ---
        function createInitialGameState() {
            return {
                // Core Resources (from config)
                ...gameConfig.initialResources,

                // Per-second rates (start at 0)
                energyPerSecond: 0,
                insightPerSecond: 0,
                inspirationPerSecond: 0,
                wisdomPerSecond: 0,
                controlPerSecond: 0,
                consciousnessPerSecond: 0,

                // Units (from config)
                units: {
                    ...gameConfig.initialUnits,
                    stellarNomads: 0,
                    voidWhisperers: 0,
                    crystalBeings: 0,
                    plasmaDancers: 0,
                    quantumSages: 0,
                    nebulaShepherds: 0
                },

                // Unit Costs (from config)
                unitCosts: { ...gameConfig.unitBaseCosts },
                unitBaseCosts: { ...gameConfig.unitBaseCosts },
                costMultiplier: gameConfig.costMultiplier,
                units: {
                    dreamers: 1,
                    weavers: 1,
                    stellarNomads: 0,
                    voidWhisperers: 0,
                    crystalBeings: 0,
                    plasmaDancers: 0,
                    quantumSages: 0,
                    nebulaShepherds: 0
                },
                unitCosts: {
                    dreamers: 15,
                    weavers: 15,
                    stellarNomads: 25,
                    voidWhisperers: 40,
                    crystalBeings: 60,
                    plasmaDancers: 80,
                    quantumSages: 120,
                    nebulaShepherds: 200
                },
                unlockedRaces: ['human'],
                nodes: {
                    sustenance: 0,
                    energy: 0,
                    cohesion: 0,
                    cycling: 0,
                },
                nodeCosts: {
                    sustenance: 100,
                    energy: 100,
                    cohesion: 500,
                    cycling: 200,
                },
                rulerBuildings: {
                    industrialMine: 0,
                    centralizedGrid: 0,
                    automatedAgriculture: 0,
                    hierarchicalCity: 0,
                    propagandaTower: 0,
                    surveillanceNetwork: 0,
                    thoughtPolice: 0,
                    corporateState: 0,
                    memoryWipe: 0,
                    totalitarianCore: 0,
                    exodusArk: 0
                },
                gardenerBuildings: {
                    stoneCircle: 0,
                    healingGrove: 0,
                    permacultureGarden: 0,
                    wisdomSanctuary: 0,
                    mycelialNetwork: 0,
                    communityCouncil: 0,
                    planetaryAwakening: 0,
                    sacredGeometry: 0,
                    livingLibrary: 0,
                    theAscension: 0
                },
                techTreeUnlocked: false,
                gameEnded: false,
                storyPhase: 'early',
                anomalyDiscovered: false,
                trueLoreRevealed: false,
                rulerPathProgress: 0,
                gardenerPathProgress: 0,
                dominantPath: 'none',
                crisisLevel: 0,
                activeCrises: [],
                horsemenDefeated: [],
                lastCrisisTime: 0,
                villageGrid: [],
                stars: [],
                intelligentCreatures: [],
                conversationalUnits: [],
                activeInteractions: [],
                synergyEffects: [],
                inspiration: 0,
                wisdom: 0,
                achievements: {
                    unlocked: [],
                    progress: {},
                    categories: ['basic', 'advanced', 'master', 'secret'],
                    definitions: {}
                },
                goals: {
                    active: [],
                    completed: [],
                    available: [],
                    milestones: []
                },
                statistics: {
                    totalUnitsCreated: 3,
                    totalEnergyGenerated: 0,
                    totalInsightGenerated: 0,
                    totalInteractions: 0,
                    totalConversations: 0,
                    playTime: 0,
                    maxHarmony: 50,
                    maxEnergy: 20,
                    maxInsight: 5,
                    maxControl: 0,
                    maxConsciousness: 10,
                    maxPlanetaryConsciousness: 10,
                    totalControlGenerated: 0,
                    totalConsciousnessGenerated: 0,
                    rulerPathChoices: 0,
                    gardenerPathChoices: 0,
                    gameStartTime: Date.now()
                },
                playerTitles: [],
                lastUpdate: Date.now(),
                saveVersion: "1.0.0",
                lastSaved: null,
                autoSaveEnabled: true,
                autoSaveInterval: 30000,

                // TDD FIX: Add missing aiPlayer object
                aiEnabled: false,
                aiPlayer: {
                    resources: {
                        energy: 20,
                        insight: 5,
                        control: 0
                    },
                    buildings: {
                        sustenance: 0,
                        energy: 0,
                        cohesion: 0,
                        cycling: 0
                    },
                    aggressiveness: 1.0,
                    lastAction: Date.now(),
                    lastMessage: Date.now()
                },
                allianceFormed: false,
                lastUserAction: Date.now(),
                userInactiveThreshold: 60000 // 1 minute
            };
        }

        // --- Reset Game State Function (Uses Centralized Config) ---
        function resetGameState() {
            debugLog('SYSTEM', 'Resetting game state', {
                oldState: {
                    energy: gameState?.energy || 0,
                    consciousness: gameState?.consciousness || 0,
                    storyPhase: gameState?.storyPhase || 'unknown'
                }
            });

            gameState = createInitialGameState();

            debugLog('SYSTEM', 'Game state reset complete', {
                newState: {
                    energy: gameState.energy,
                    consciousness: gameState.consciousness,
                    storyPhase: gameState.storyPhase,
                    villageGridLength: gameState.villageGrid?.length || 0
                }
            });

            // Reset UI tracking variables
            previousValues = {
                energy: gameConfig.initialResources.energy,
                insight: gameConfig.initialResources.insight,
                harmony: gameConfig.initialResources.harmony,
                inspiration: gameConfig.initialResources.inspiration,
                wisdom: gameConfig.initialResources.wisdom,
                control: gameConfig.initialResources.control,
                consciousness: gameConfig.initialResources.consciousness,
                planetaryConsciousness: gameConfig.initialResources.planetaryConsciousness
            };

            // Clear and re-render UI
            if (logOutput) {
                logOutput.innerHTML = '';
                debugLog('SYSTEM', 'Log output cleared');
            }

            // Check if render functions exist
            debugLog('SYSTEM', 'Checking render functions', {
                renderStats: typeof renderStats,
                renderUnits: typeof renderUnits,
                renderNodes: typeof renderNodes
            });

            if (typeof renderStats === 'function') renderStats();
            if (typeof renderUnits === 'function') renderUnits();
            if (typeof renderNodes === 'function') renderNodes();

            debugLog('SYSTEM', 'Reset complete - UI should be refreshed');
        }

        // --- Attach Reset to New Game Button ---
        document.addEventListener('DOMContentLoaded', function() {
            const newGameBtn = document.getElementById('new-game-main-btn');
            if (newGameBtn) {
                newGameBtn.textContent = 'New Game';
                newGameBtn.onclick = function() {
                    resetGameState();
                    log('New game started. All progress cleared.', 'success');
                };
            }
        });

        // --- TDD: Centralized Game Configuration (MUST come before gameState) ---
        const gameConfig = {
            // Initial Resources (matches core_instructions.md)
            initialResources: {
                energy: 20,
                energyCap: 100,
                insight: 5,
                insightCap: 50,
                harmony: 50,
                harmonyCap: 100,
                inspiration: 0,
                inspirationCap: 25,
                wisdom: 0,
                wisdomCap: 25,
                control: 0,
                controlCap: 100,
                consciousness: 10, // Start with some consciousness
                consciousnessCap: 100,
                planetaryConsciousness: 10, // Global consciousness level
                planetaryConsciousnessCap: 100,
                entropy: 0,
                entropyCap: 100
            },

            // Starting Units (auto-generated)
            initialUnits: {
                dreamers: 1,
                weavers: 1
            },

            // Unit Base Costs & Scaling
            unitBaseCosts: {
                dreamers: 15,
                weavers: 15,
                stellarNomads: 25,
                voidWhisperers: 40,
                crystalBeings: 60,
                plasmaDancers: 80,
                quantumSages: 120,
                nebulaShepherds: 200
            },
            costMultiplier: 1.15, // Swarm Simulator-style exponential scaling

            // AI Player Configuration
            aiPlayer: {
                initialResources: {
                    energy: 50,
                    insight: 30,
                    wisdom: 0,
                    control: 10
                },
                actionCooldown: 15000, // 15 seconds when user active
                inactiveActionCooldown: 5000, // 5 seconds when user inactive
                resourceGenerationRate: {
                    energy: 2,
                    insight: 1,
                    control: 0.5
                },
                userInactiveThreshold: 60000 // 1 minute
            },

            // Game Balance Parameters
            balance: {
                // TDD: Much harder victory conditions to fix "too easy" issue
                victoryThresholds: {
                    planetaryConsciousness: 100, // Still 100, but requires more buildings
                    minBuildingsForVictory: 8, // Need 8+ buildings for any victory
                    minResourcesForVictory: 200, // Need 200+ in primary resource
                    storyProgressionRequired: true // Must complete story phases
                },
                storyProgression: {
                    anomalyTrigger: {
                        minBuildings: 8, // Increased from 5
                        minResourceSum: 80 // Increased from 50
                    },
                    loreReveal: {
                        minWisdom: 40, // Increased from 20
                        minInsight: 60 // Increased from 30
                    }
                },
                allianceFormationThreshold: {
                    playerBuildings: 5, // Increased from 3
                    aiBuildings: 5, // Increased from 3
                    playerConsciousness: 60, // Increased from 40
                    aiControl: 50 // Increased from 30
                },
                crisisSystem: {
                    updateFrequency: 0.05, // 5% chance per frame
                    horsemenCooldown: 60000, // 1 minute between crises
                    cosmicThreatCooldown: 120000 // 2 minutes between cosmic threats
                }
            }
        };

        // --- Game Config - TDD Races System ---
        const racesConfig = {
            human: { name: "Human", description: "The original inhabitants", color: '#8B5CF6', symbol: '👤', unlocked: true, tier: 1 },
            stellar: { name: "Stellar Nomads", description: "Wandering star-travelers", color: '#F59E0B', symbol: '⭐', unlockCondition: { energy: 50, insight: 25 }, unlocked: false, tier: 2 },
            void: { name: "Void Whisperers", description: "Mysterious void entities", color: '#1F2937', symbol: '🌑', unlockCondition: { harmony: 70, energy: 100 }, unlocked: false, tier: 3 },
            crystal: { name: "Crystal Beings", description: "Living crystalline entities", color: '#10B981', symbol: '💎', unlockCondition: { energy: 200, insight: 100 }, unlocked: false, tier: 3 },
            plasma: { name: "Plasma Dancers", description: "Pure energy beings", color: '#EF4444', symbol: '🔥', unlockCondition: { energy: 500, harmony: 80 }, unlocked: false, tier: 4 },
            quantum: { name: "Quantum Sages", description: "Multi-dimensional beings", color: '#8B5CF6', symbol: '🌀', unlockCondition: { insight: 500, harmony: 85 }, unlocked: false, tier: 5 },
            nebula: { name: "Nebula Shepherds", description: "Ancient star-birthers", color: '#A78BFA', symbol: '🌌', unlockCondition: { energy: 1000, insight: 800, harmony: 95 }, unlocked: false, tier: 5 }
        };

        const unitsConfig = {
            dreamers: { name: "Dreamer", description: "Generates Insight through cosmic meditation.", baseInsight: 0.1, costResource: 'energy', race: 'human', special: 'dreamVision' },
            weavers: { name: "Weaver", description: "Generates Energy by weaving cosmic threads.", baseEnergy: 0.1, costResource: 'insight', race: 'human', special: 'energyWeaving' },
            stellarNomads: { name: "Stellar Nomad", description: "Star-travelers generating Energy and Insight.", baseEnergy: 0.15, baseInsight: 0.05, costResource: 'energy', race: 'stellar', special: 'stellarNavigation' },
            voidWhisperers: { name: "Void Whisperer", description: "Void communers generating Insight and Harmony.", baseInsight: 0.08, baseHarmony: 0.02, costResource: 'insight', race: 'void', special: 'voidCommunion' },
            crystalBeings: { name: "Crystal Being", description: "Living crystals amplifying cosmic energy.", baseEnergy: 0.2, costResource: 'energy', race: 'crystal', special: 'crystalResonance' },
            plasmaDancers: { name: "Plasma Dancer", description: "Pure energy beings dancing through plasma.", baseEnergy: 0.3, costResource: 'insight', race: 'plasma', special: 'plasmaManipulation' },
            quantumSages: { name: "Quantum Sage", description: "Multi-dimensional beings with vast knowledge.", baseInsight: 0.5, costResource: 'energy', race: 'quantum', special: 'quantumEntanglement' },
            nebulaShepherds: { name: "Nebula Shepherd", description: "Ancient beings birthing stars.", baseEnergy: 0.8, baseInsight: 0.3, baseHarmony: 0.1, costResource: 'insight', race: 'nebula', special: 'starBirth' }
        };

        // --- TDD: Two Divergent Tech Trees ---

        const rulerPathBuildings = {
            // Tier 1: Foundation of Control (Early Game)
            resourceSilo: {
                name: "Resource Silo",
                description: "Industrial storage facility. +75 Energy capacity, +25 Control capacity.",
                costResource: 'energy',
                cost: 100,
                effects: { energyCap: 75, controlCap: 25, control: 1 },
                path: 'ruler',
                category: 'infrastructure',
                tier: 1,
                unlockCondition: () => true
            },
            dataVault: {
                name: "Data Vault",
                description: "Centralized information storage. +30 Insight capacity, +20 Control capacity.",
                costResource: 'insight',
                cost: 60,
                effects: { insightCap: 30, controlCap: 20, control: 0.5 },
                path: 'ruler',
                category: 'infrastructure',
                tier: 1,
                unlockCondition: () => true
            },
            industrialMine: {
                name: "Industrial Mine",
                description: "Extracts resources efficiently but damages the environment. Foundation of industrial power.",
                costResource: 'energy',
                cost: 50,
                effects: { control: 2, energy: 1.5, harmony: -0.5, entropy: 0.1 },
                path: 'ruler',
                category: 'extraction',
                tier: 1,
                unlockCondition: () => true // Always available
            },
            centralizedGrid: {
                name: "Centralized Power Grid",
                description: "Distributes power efficiently but creates dependency. Citizens rely on the system.",
                costResource: 'insight',
                cost: 75,
                effects: { control: 3, energyPerSecond: 0.3, consciousness: -0.2, entropy: 0.05 },
                path: 'ruler',
                category: 'infrastructure',
                tier: 1,
                unlockCondition: () => gameState.rulerBuildings.industrialMine > 0
            },
            automatedAgriculture: {
                name: "Automated Agriculture",
                description: "Produces food efficiently but disconnects people from nature and traditional ways.",
                costResource: 'energy',
                cost: 60,
                effects: { control: 1, energyPerSecond: 0.2, consciousness: -0.3, entropy: 0.05 },
                path: 'ruler',
                category: 'production',
                tier: 1,
                unlockCondition: () => true
            },

            // Tier 2: Systems of Dominance (Mid Game)
            hierarchicalCity: {
                name: "Hierarchical City",
                description: "Organizes population in rigid social strata. Order through stratification.",
                costResource: 'energy',
                cost: 120,
                effects: { control: 5, harmony: 1, consciousness: -1, entropy: 0.2, controlPerSecond: 0.1 },
                path: 'ruler',
                category: 'social',
                tier: 2,
                unlockCondition: () => gameState.rulerBuildings.centralizedGrid > 0
            },
            propagandaTower: {
                name: "Propaganda Tower",
                description: "Shapes public opinion through mass media. Truth becomes what the state declares.",
                costResource: 'insight',
                cost: 100,
                effects: { control: 4, harmony: 0.5, consciousness: -1.5, entropy: 0.15 },
                path: 'ruler',
                category: 'information',
                tier: 2,
                unlockCondition: () => gameState.rulerBuildings.industrialMine > 0
            },
            surveillanceNetwork: {
                name: "Surveillance Network",
                description: "Monitors all citizen activity. Privacy becomes a relic of the past.",
                costResource: 'insight',
                cost: 150,
                effects: { control: 6, consciousness: -2, entropy: 0.3, controlPerSecond: 0.15 },
                path: 'ruler',
                category: 'security',
                tier: 2,
                unlockCondition: () => gameState.rulerBuildings.propagandaTower > 0
            },

            // Tier 3: Instruments of Oppression (Late Game)
            thoughtPolice: {
                name: "Thought Police",
                description: "Enforces ideological conformity. Independent thinking becomes dangerous.",
                costResource: 'wisdom',
                cost: 200,
                effects: { control: 8, consciousness: -3, harmony: -1, entropy: 0.4, controlPerSecond: 0.2 },
                path: 'ruler',
                category: 'enforcement',
                tier: 3,
                unlockCondition: () => gameState.rulerBuildings.surveillanceNetwork > 0
            },
            corporateState: {
                name: "Corporate State",
                description: "Merges government and business into one entity. Citizens become human resources.",
                costResource: 'energy',
                cost: 300,
                effects: { control: 10, energyPerSecond: 0.5, consciousness: -2, entropy: 0.5 },
                path: 'ruler',
                category: 'economic',
                tier: 3,
                unlockCondition: () => gameState.rulerBuildings.hierarchicalCity > 0
            },
            memoryWipe: {
                name: "Memory Reconditioning Center",
                description: "Erases inconvenient memories and implants approved thoughts. The past becomes malleable.",
                costResource: 'wisdom',
                cost: 400,
                effects: { control: 12, consciousness: -5, harmony: -2, entropy: 0.6, controlPerSecond: 0.3 },
                path: 'ruler',
                category: 'psychological',
                tier: 3,
                unlockCondition: () => gameState.rulerBuildings.thoughtPolice > 0
            },

            // Tier 4: Ultimate Control (End Game)
            totalitarianCore: {
                name: "Totalitarian Core",
                description: "The ultimate expression of control. Individual will ceases to exist.",
                costResource: 'consciousness',
                cost: 50, // Ironically cheap in consciousness - you sacrifice it
                effects: { control: 20, consciousness: -10, harmony: -5, entropy: 1.0, controlPerSecond: 0.5 },
                path: 'ruler',
                category: 'ultimate',
                tier: 4,
                unlockCondition: () => gameState.rulerBuildings.memoryWipe > 0 && gameState.control > 50
            },

            // Tier 5: The Exodus (Victory Condition)
            exodusArk: {
                name: "Exodus Ark",
                description: "The ultimate escape vessel. Leave this dying world behind and join the galactic empire.",
                costResource: 'energy',
                cost: 1000,
                effects: { rulerPathProgress: 100 }, // Triggers Ruler victory
                path: 'ruler',
                category: 'victory',
                tier: 5,
                unlockCondition: () => gameState.rulerBuildings.totalitarianCore > 0 && gameState.control > 80 && gameState.trueLoreRevealed
            }
        };

        const gardenerPathBuildings = {
            // Tier 1: Seeds of Consciousness (Early Game)
            energyReservoir: {
                name: "Energy Reservoir",
                description: "Crystalline pools that store cosmic energy. +50 Energy capacity.",
                costResource: 'energy',
                cost: 75,
                effects: { energyCap: 50, energyPerSecond: 0.1 },
                path: 'gardener',
                category: 'infrastructure',
                tier: 1,
                unlockCondition: () => true
            },
            insightLibrary: {
                name: "Insight Library",
                description: "Repository of cosmic knowledge. +25 Insight capacity.",
                costResource: 'insight',
                cost: 40,
                effects: { insightCap: 25, insightPerSecond: 0.05 },
                path: 'gardener',
                category: 'infrastructure',
                tier: 1,
                unlockCondition: () => true
            },
            stoneCircle: {
                name: "Stone Circle",
                description: "Ancient gathering place that enhances collective consciousness and spiritual connection.",
                costResource: 'wisdom',
                cost: 40,
                effects: { consciousness: 2, wisdom: 0.5, harmony: 1, control: -0.2 },
                path: 'gardener',
                category: 'spiritual',
                tier: 1,
                unlockCondition: () => true // Always available
            },
            healingGrove: {
                name: "Healing Grove",
                description: "Natural sanctuary that restores balance and awareness through nature's healing power.",
                costResource: 'inspiration',
                cost: 50,
                effects: { consciousness: 1.5, harmony: 2, consciousnessPerSecond: 0.1, entropy: -0.1 },
                path: 'gardener',
                category: 'healing',
                tier: 1,
                unlockCondition: () => true // Always available
            },
            permacultureGarden: {
                name: "Permaculture Garden",
                description: "Sustainable food system that connects people to nature and traditional wisdom.",
                costResource: 'harmony',
                cost: 45,
                effects: { consciousness: 1, harmony: 1.5, inspirationPerSecond: 0.15, entropy: -0.05 },
                path: 'gardener',
                category: 'sustainability',
                tier: 1,
                unlockCondition: () => gameState.gardenerBuildings.healingGrove > 0
            },

            // Tier 2: Growing Awareness (Mid Game)
            wisdomSanctuary: {
                name: "Wisdom Sanctuary",
                description: "Center of learning that develops deep understanding and philosophical insight.",
                costResource: 'insight',
                cost: 80,
                effects: { consciousness: 3, wisdom: 1, wisdomPerSecond: 0.2, control: -0.5 },
                path: 'gardener',
                category: 'knowledge',
                tier: 2,
                unlockCondition: () => gameState.gardenerBuildings.stoneCircle > 0
            },
            mycelialNetwork: {
                name: "Mycelial Network",
                description: "Underground fungal network that enhances communication and connection between all beings.",
                costResource: 'wisdom',
                cost: 70,
                effects: { consciousness: 2.5, consciousnessPerSecond: 0.2, harmony: 1, control: -1 },
                path: 'gardener',
                category: 'connection',
                tier: 2,
                unlockCondition: () => gameState.gardenerBuildings.wisdomSanctuary > 0
            },
            communityCouncil: {
                name: "Community Council",
                description: "Democratic decision-making body that empowers collective wisdom and shared governance.",
                costResource: 'harmony',
                cost: 90,
                effects: { consciousness: 2, harmony: 3, wisdomPerSecond: 0.15, control: -2 },
                path: 'gardener',
                category: 'governance',
                tier: 2,
                unlockCondition: () => gameState.gardenerBuildings.permacultureGarden > 0
            },

            // Tier 3: Awakening Bloom (Late Game)
            planetaryAwakening: {
                name: "Planetary Awakening Center",
                description: "A nexus that connects all consciousness on the planet into a unified field of awareness.",
                costResource: 'consciousness',
                cost: 120,
                effects: { consciousness: 10, consciousnessPerSecond: 0.5, planetaryConsciousness: 20, control: -5 },
                path: 'gardener',
                category: 'awakening',
                tier: 3,
                unlockCondition: () => gameState.gardenerBuildings.mycelialNetwork > 0 && gameState.consciousness > 50
            },
            sacredGeometry: {
                name: "Sacred Geometry Temple",
                description: "Crystalline structures that amplify consciousness through harmonic resonance and sacred patterns.",
                costResource: 'wisdom',
                cost: 150,
                effects: { consciousness: 8, consciousnessPerSecond: 0.3, harmony: 2, entropy: -0.2 },
                path: 'gardener',
                category: 'resonance',
                tier: 3,
                unlockCondition: () => gameState.gardenerBuildings.communityCouncil > 0
            },
            livingLibrary: {
                name: "Living Library",
                description: "Repository of all knowledge and wisdom, accessible to every awakened consciousness.",
                costResource: 'insight',
                cost: 200,
                effects: { consciousness: 6, wisdom: 5, wisdomPerSecond: 0.4, inspirationPerSecond: 0.2 },
                path: 'gardener',
                category: 'knowledge',
                tier: 3,
                unlockCondition: () => gameState.gardenerBuildings.planetaryAwakening > 0
            },

            // Tier 4: The Great Ascension (Victory Condition)
            theAscension: {
                name: "The Great Ascension",
                description: "Complete the planetary transformation. Awaken all beings to their true nature and cosmic unity.",
                costResource: 'wisdom',
                cost: 500,
                effects: { gardenerPathProgress: 100 }, // Triggers Gardener victory
                path: 'gardener',
                category: 'victory',
                tier: 4,
                unlockCondition: () => gameState.gardenerBuildings.livingLibrary > 0 && gameState.consciousness > 80 && gameState.trueLoreRevealed
            }
        };

        // Legacy nodes for backward compatibility
        const nodesConfig = {
            sustenance: { name: "Sustenance Node", description: "Boosts Dreamer insight generation.", effectTarget: 'dreamers', multiplier: 1.2, costResource: 'energy' },
            energy: { name: "Energy Node", description: "Boosts Weaver energy generation.", effectTarget: 'weavers', multiplier: 1.2, costResource: 'insight' },
            cohesion: { name: "Cohesion Node", description: "Boosts all production.", effectTarget: 'all', multiplier: 1.1, costResource: 'energy' },
            cycling: { name: "Recycling Node", description: "Reduces the cost of all units and improves Harmony.", effectTarget: 'cost', multiplier: 0.95, harmony: 5, costResource: 'insight' },
        };

        // --- Initialize Game State (AFTER all configs are defined) ---
        let gameState = createInitialGameState();

        // --- Utility Functions ---
        const formatNumber = (num) => {
            if (num < 1000) return num.toFixed(1);
            if (num < 1e6) return (num / 1e3).toFixed(2) + 'k';
            if (num < 1e9) return (num / 1e6).toFixed(2) + 'M';
            return (num / 1e9).toFixed(2) + 'B';
        };
        const log = (message, type = 'info') => {
            const colors = { info: 'text-indigo-300', success: 'text-teal-300', error: 'text-red-400', warning: 'text-amber-300', grok: 'text-purple-300' };
            const p = document.createElement('p');
            p.innerHTML = `[INFO] ${message}`;
            p.className = `${colors[type]} log-entry`;
            logOutput.prepend(p);
            if (logOutput.children.length > 20) {
                logOutput.lastChild.remove();
            }
        };

        // --- Rendering Functions ---
        // Store previous values for change detection
        let previousValues = {
            energy: 20,
            insight: 5,
            harmony: 50,
            inspiration: 0,
            wisdom: 0,
            control: 0,
            consciousness: 10,
            planetaryConsciousness: 10
        };

        const renderStats = () => {
            // Update individual stat elements instead of replacing entire innerHTML
            const energyEl = document.getElementById('energy');
            const insightEl = document.getElementById('insight');
            const harmonyEl = document.getElementById('harmony');
            const inspirationEl = document.getElementById('inspiration');
            const wisdomEl = document.getElementById('wisdom');
            const controlEl = document.getElementById('control');
            const consciousnessEl = document.getElementById('consciousness');
            const planetaryConsciousnessEl = document.getElementById('planetary-consciousness');
            const crisisLevelEl = document.getElementById('crisis-level');
            const crisisStatusEl = document.getElementById('crisis-status');
            const energyRateEl = document.getElementById('energy-rate');
            const insightRateEl = document.getElementById('insight-rate');
            const inspirationRateEl = document.getElementById('inspiration-rate');
            const wisdomRateEl = document.getElementById('wisdom-rate');
            const controlRateEl = document.getElementById('control-rate');
            const consciousnessRateEl = document.getElementById('consciousness-rate');
            const totalUnitsEl = document.getElementById('total-units');

            // Check for increases and add visual feedback
            const checkAndUpdate = (element, newValue, resourceName) => {
                if (element) {
                    const oldValue = previousValues[resourceName];
                    element.textContent = formatNumber(newValue);

                    if (newValue > oldValue && oldValue > 0) {
                        element.classList.add('resource-increase');
                        setTimeout(() => element.classList.remove('resource-increase'), 500);
                    }
                    previousValues[resourceName] = newValue;
                }
            };

            checkAndUpdate(energyEl, gameState.energy, 'energy');
            checkAndUpdate(insightEl, gameState.insight, 'insight');

            // Update resource caps
            const energyCapEl = document.getElementById('energy-cap');
            const insightCapEl = document.getElementById('insight-cap');
            if (energyCapEl) energyCapEl.textContent = gameState.energyCap;
            if (insightCapEl) insightCapEl.textContent = gameState.insightCap;
            checkAndUpdate(inspirationEl, gameState.inspiration, 'inspiration');
            checkAndUpdate(wisdomEl, gameState.wisdom, 'wisdom');
            checkAndUpdate(controlEl, gameState.control, 'control');
            checkAndUpdate(consciousnessEl, gameState.consciousness, 'consciousness');
            checkAndUpdate(planetaryConsciousnessEl, gameState.planetaryConsciousness, 'planetaryConsciousness');

            // Update planetary consciousness progress bar
            const progressBar = document.querySelector('.bg-yellow-400');
            if (progressBar) {
                const percentage = Math.min(100, Math.max(0, gameState.planetaryConsciousness));
                progressBar.style.width = `${percentage}%`;
            }

            // Update alliance status
            const allianceStatusEl = document.getElementById('alliance-status');
            const integrationLevelEl = document.getElementById('integration-level');
            const integrationBarEl = document.getElementById('integration-bar');

            if (gameState.allianceFormed) {
                if (allianceStatusEl) allianceStatusEl.style.display = 'block';
                if (integrationLevelEl) integrationLevelEl.textContent = `${Math.round(gameState.integrationLevel)}%`;
                if (integrationBarEl) integrationBarEl.style.width = `${gameState.integrationLevel}%`;
            } else {
                if (allianceStatusEl) allianceStatusEl.style.display = 'none';
            }

            // Update AI player status
            const aiControlEl = document.getElementById('ai-control');
            const aiBuildingsEl = document.getElementById('ai-buildings');
            const aiActivityEl = document.getElementById('ai-activity-indicator');

            if (aiControlEl) aiControlEl.textContent = Math.round(gameState.aiPlayer.resources.control);
            if (aiBuildingsEl) {
                const totalAIBuildings = Object.values(gameState.aiPlayer.buildings).reduce((sum, count) => sum + count, 0);
                aiBuildingsEl.textContent = `${totalAIBuildings} Buildings`;
            }

            // Update AI activity indicator
            if (aiActivityEl) {
                const inactive = isUserInactive();
                const aggressiveness = gameState.aiPlayer.aggressiveness;

                if (inactive) {
                    if (aggressiveness > 2.0) {
                        aiActivityEl.innerHTML = '🔥 Aggressive';
                        aiActivityEl.className = 'text-xs text-red-400';
                    } else {
                        aiActivityEl.innerHTML = '⚡ Accelerated';
                        aiActivityEl.className = 'text-xs text-yellow-400';
                    }
                } else {
                    aiActivityEl.innerHTML = '⚡ Active';
                    aiActivityEl.className = 'text-xs text-green-400';
                }
            }

            // Handle harmony separately (no formatting, just fixed decimal)
            if (harmonyEl) {
                const oldHarmony = previousValues.harmony;
                harmonyEl.textContent = gameState.harmony.toFixed(1);

                if (gameState.harmony > oldHarmony && oldHarmony > 0) {
                    harmonyEl.classList.add('resource-increase');
                    setTimeout(() => harmonyEl.classList.remove('resource-increase'), 500);
                }
                previousValues.harmony = gameState.harmony;
            }

            if (energyRateEl) energyRateEl.textContent = gameState.energyPerSecond.toFixed(1);
            if (insightRateEl) insightRateEl.textContent = gameState.insightPerSecond.toFixed(1);
            if (inspirationRateEl) inspirationRateEl.textContent = (gameState.inspirationPerSecond || 0).toFixed(1);
            if (wisdomRateEl) wisdomRateEl.textContent = (gameState.wisdomPerSecond || 0).toFixed(1);
            if (controlRateEl) controlRateEl.textContent = (gameState.controlPerSecond || 0).toFixed(1);
            if (consciousnessRateEl) consciousnessRateEl.textContent = (gameState.consciousnessPerSecond || 0).toFixed(1);

            // Calculate total units
            if (totalUnitsEl) {
                const totalUnits = Object.values(gameState.units).reduce((sum, count) => sum + count, 0) +
                                 gameState.intelligentCreatures.length +
                                 gameState.conversationalUnits.length;
                totalUnitsEl.textContent = totalUnits;
            }
        };

        // TDD Fix: Stable button rendering that doesn't recreate buttons
        let unitsInitialized = false;

        // TDD Races: Check for newly unlocked races
        const checkRaceUnlocks = () => {
            let newlyUnlocked = [];

            Object.entries(racesConfig).forEach(([raceKey, race]) => {
                if (!gameState.unlockedRaces.includes(raceKey) && !race.unlocked) {
                    if (!race.unlockCondition) {
                        gameState.unlockedRaces.push(raceKey);
                        race.unlocked = true;
                        newlyUnlocked.push(raceKey);
                    } else {
                        const canUnlock = Object.entries(race.unlockCondition).every(([resource, required]) => {
                            return gameState[resource] >= required;
                        });

                        if (canUnlock) {
                            gameState.unlockedRaces.push(raceKey);
                            race.unlocked = true;
                            newlyUnlocked.push(raceKey);
                            log(`🌟 New race discovered: ${race.name}! ${race.description}`, 'success');
                        }
                    }
                }
            });

            return newlyUnlocked;
        };

        const renderUnits = () => {
            try {
                debugLog('SYSTEM', 'renderUnits starting', {
                    unitsInitialized: unitsInitialized,
                    unitsPanel: !!unitsPanel,
                    unitsPanelId: unitsPanel ? 'found' : 'missing'
                });

                // Only create buttons once, then update their states
                if (!unitsInitialized) {
                    debugLog('SYSTEM', 'Creating unit buttons');
                    createUnitButtons();
                    unitsInitialized = true;
                    debugLog('SYSTEM', 'Unit buttons created');
                }
                debugLog('SYSTEM', 'Updating unit button states');
                updateUnitButtonStates();
                debugLog('SYSTEM', 'renderUnits complete');
            } catch (error) {
                debugLog('ERROR', 'renderUnits failed', {
                    error: error.message,
                    stack: error.stack
                });
                console.error('renderUnits error:', error);
            }
        };

        const createUnitButtons = () => {
            debugLog('SYSTEM', 'createUnitButtons starting', {
                unitsPanel: !!unitsPanel,
                unitsPanelType: typeof unitsPanel,
                unitsConfigKeys: Object.keys(unitsConfig || {})
            });

            if (!unitsPanel) {
                debugLog('ERROR', 'unitsPanel is null/undefined - skipping unit button creation');
                return false;
            }

            try {
                unitsPanel.innerHTML = '';
                debugLog('SYSTEM', 'Cleared unitsPanel innerHTML');

                for (const key in unitsConfig) {
                    debugLog('SYSTEM', `Creating button for unit: ${key}`);
                    const unit = unitsConfig[key];
                    const card = document.createElement('div');
                card.className = "unit-card p-4 rounded-lg border border-indigo-800";
                card.innerHTML = `
                    <h3 class="font-bold text-lg text-white">${unit.name}</h3>
                    <p class="text-sm text-indigo-200">${unit.description}</p>
                    <button class="unit-btn mt-2 py-2 px-3 text-sm font-semibold rounded-md transition-colors"
                            data-unit="${key}">
                        Create ${unit.name}
                    </button>
                `;

                // Add stable event listener
                const button = card.querySelector('.unit-btn');
                button.addEventListener('click', () => {
                    if (!button.disabled) {
                        createUnit(key);
                    }
                });

                unitsPanel.appendChild(card);
            }
            return true;
            } catch (error) {
                debugLog('ERROR', 'createUnitButtons failed', {
                    error: error.message,
                    stack: error.stack
                });
                return false;
            }
        };

        const updateUnitButtonStates = () => {
            for (const key in unitsConfig) {
                const unit = unitsConfig[key];
                const cost = gameState.unitCosts[key];
                const canAfford = gameState[unit.costResource] >= cost;

                const button = unitsPanel.querySelector(`[data-unit="${key}"]`);
                if (button) {
                    button.disabled = !canAfford;
                    button.textContent = `Create (Cost: ${formatNumber(cost)} ${unit.costResource})`;

                    // Update visual state without recreating
                    button.className = `unit-btn mt-2 py-2 px-3 text-sm font-semibold rounded-md transition-colors ${
                        canAfford ? 'bg-green-600 hover:bg-green-700 text-white' : 'bg-gray-600 text-gray-400'
                    }`;
                }
            }
        };

        // TDD Fix: Stable node button rendering
        let nodesInitialized = false;

        const renderNodes = () => {
            // Only create buttons once, then update their states
            if (!nodesInitialized) {
                createNodeButtons();
                nodesInitialized = true;
            }
            updateNodeButtonStates();
        };

        const createNodeButtons = () => {
            modulesPanel.innerHTML = '';
            for (const key in nodesConfig) {
                const node = nodesConfig[key];
                const card = document.createElement('div');
                card.className = "module-card p-4 rounded-lg";
                card.innerHTML = `
                    <h3 class="font-bold text-lg text-white">
                        ${node.name} <span class="text-sm font-normal text-indigo-300 level-display" data-node="${key}">(Lvl 0)</span>
                    </h3>
                    <p class="text-sm text-indigo-200">${node.description}</p>
                    <button class="node-btn mt-2 py-2 px-3 text-sm font-semibold rounded-md transition-colors"
                            data-node="${key}">
                        Attune ${node.name}
                    </button>
                `;

                // Add stable event listener
                const button = card.querySelector('.node-btn');
                button.addEventListener('click', () => {
                    if (!button.disabled) {
                        upgradeNode(key);
                    }
                });

                modulesPanel.appendChild(card);
            }
        };

        const updateNodeButtonStates = () => {
            for (const key in nodesConfig) {
                const node = nodesConfig[key];
                const cost = gameState.nodeCosts[key];
                const level = gameState.nodes[key];
                const canAfford = gameState[node.costResource] >= cost;

                // Update level display
                const levelDisplay = modulesPanel.querySelector(`[data-node="${key}"].level-display`);
                if (levelDisplay) {
                    levelDisplay.textContent = `(Lvl ${level})`;
                }

                // Update button
                const button = modulesPanel.querySelector(`button[data-node="${key}"]`);
                if (button) {
                    button.disabled = !canAfford;
                    button.textContent = `Attune (Cost: ${formatNumber(cost)} ${node.costResource})`;

                    // Update visual state without recreating
                    button.className = `node-btn mt-2 py-2 px-3 text-sm font-semibold rounded-md transition-colors ${
                        canAfford ? 'bg-teal-600 hover:bg-teal-700 text-white' : 'bg-gray-600 text-gray-400'
                    }`;
                }
            }
        };

        const renderUI = () => {
            try {
                debugLog('SYSTEM', 'Starting renderUI');

                debugLog('SYSTEM', 'Calling renderStats');
                renderStats();
                debugLog('SYSTEM', 'renderStats complete');

                debugLog('SYSTEM', 'Calling renderUnits');
                renderUnits();
                debugLog('SYSTEM', 'renderUnits complete');

                debugLog('SYSTEM', 'Calling renderNodes');
                renderNodes();
                debugLog('SYSTEM', 'renderNodes complete');

                debugLog('SYSTEM', 'Calling renderTechTrees');
                renderTechTrees();
                debugLog('SYSTEM', 'renderTechTrees complete');

                debugLog('SYSTEM', 'renderUI complete');
            } catch (error) {
                debugLog('ERROR', 'renderUI failed', {
                    error: error.message,
                    stack: error.stack
                });
                console.error('renderUI error:', error);
            }
        }
        
        // --- Enhanced Drawing System with Movement ---
        let animationTime = 0;
        let particles = [];

        // TDD Task 1: Drag and Drop System
        let dragState = {
            isDragging: false,
            draggedUnit: null,
            dragOffsetX: 0,
            dragOffsetY: 0,
            hoveredUnit: null,
            originalPosition: null,
            dragStartTime: 0,
            totalDragDistance: 0,
            isValidPlacement: true,
            placementEffects: [],
            proximityIndicators: []
        };

        let movementTrails = {};

        // TDD Task 2: Enhanced Visual Effects System
        let particlePool = {
            active: [],
            inactive: [],
            maxParticles: 200
        };

        let lightSources = [];
        let energyFlows = [];
        let screenEffects = {
            bloom: { enabled: true, intensity: 0.3 },
            vignette: { enabled: true, intensity: 0.2 }
        };

        // --- TDD: Screen Real Estate Management ---

        let canvasState = {
            width: 800,
            height: 600,
            safeZone: { left: 50, right: 50, top: 50, bottom: 50 },
            zoom: 1.0,
            panX: 0,
            panY: 0
        };

        const updateCanvasSize = () => {
            const rect = canvas.getBoundingClientRect();
            const newWidth = Math.max(600, rect.width); // Minimum width
            const newHeight = Math.max(400, rect.height); // Minimum height

            // Only update if size changed significantly
            if (Math.abs(canvas.width - newWidth) > 10 || Math.abs(canvas.height - newHeight) > 10) {
                canvas.width = newWidth;
                canvas.height = newHeight;
                canvasState.width = newWidth;
                canvasState.height = newHeight;

                // Reposition units that are now off-screen
                repositionOffScreenUnits();
            }
        };

        const repositionOffScreenUnits = () => {
            const safeWidth = canvasState.width - canvasState.safeZone.left - canvasState.safeZone.right;
            const safeHeight = canvasState.height - canvasState.safeZone.top - canvasState.safeZone.bottom;

            gameState.villageGrid.forEach(unit => {
                if (unit.x < canvasState.safeZone.left ||
                    unit.x > canvasState.width - canvasState.safeZone.right ||
                    unit.y < canvasState.safeZone.top ||
                    unit.y > canvasState.height - canvasState.safeZone.bottom) {

                    // Reposition to safe zone
                    unit.x = canvasState.safeZone.left + Math.random() * safeWidth;
                    unit.y = canvasState.safeZone.top + Math.random() * safeHeight;

                    // Update movement targets
                    if (unit.targetX !== undefined) {
                        unit.targetX = unit.x;
                        unit.targetY = unit.y;
                    }
                    if (unit.wanderCenter) {
                        unit.wanderCenter = { x: unit.x, y: unit.y };
                    }
                }
            });
        };

        const drawSanctuary = () => {
            // Safety check
            if (!canvas || !ctx) {
                console.error('Canvas or context not available');
                return;
            }

            updateCanvasSize();
            animationTime += 0.016; // ~60fps

            // Clear the entire canvas first
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw a simple test background first to ensure canvas is working
            ctx.fillStyle = '#0a0820';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Enhanced Background with nebula effect (not affected by zoom/pan)
            drawBackground();

            // Enhanced Stars with twinkling (not affected by zoom/pan)
            drawStars();

            // Floating particles for magical atmosphere (not affected by zoom/pan)
            updateAndDrawParticles();

            // Energy/Insight flow lines (not affected by zoom/pan)
            drawEnergyFlows();

            // Apply zoom and pan transformations for units only
            ctx.save();
            ctx.translate(canvasState.panX, canvasState.panY);
            ctx.scale(canvasState.zoom, canvasState.zoom);

            // TDD Task 1: Update unit movement and draw enhanced sprites
            updateUnitMovement(0.016);
            updateMovementTrails();

            // TDD: Update intelligent creatures
            updateIntelligentCreatures(0.016);

            // TDD: Update conversational AI units
            updateConversationalUnits(0.016);

            // TDD: Update unit interactions and synergies
            updateUnitInteractions(0.016);

            // TDD: Check achievements and goals periodically
            if (Math.random() < 0.1) { // Check every ~10 frames to avoid performance issues
                checkAchievementsAndGoals();
            }

            // TDD: Update Control vs Consciousness system
            updateControlConsciousnessSystem(0.016);

            // TDD: Check Great Transition win/lose conditions
            if (Math.random() < 0.05) { // Check every ~20 frames
                checkGreatTransitionConditions();
            }

            // TDD: Check for new building unlocks
            if (Math.random() < 0.02) { // Check every ~50 frames
                checkBuildingUnlocks();
            }

            // TDD: Check story progression
            if (Math.random() < 0.01) { // Check every ~100 frames
                checkStoryProgression();
            }

            // TDD: Update crisis system and alliance mechanics
            if (Math.random() < 0.05) { // Check every ~20 frames
                updateCrisisLevel();
                updateAIPlayer(); // AI opponent actions
                checkAllianceFormation();
                updateIntegrationLevel();
                checkForNewCrises();
                checkCrisisResolution();
            }

            gameState.villageGrid.sort((a, b) => a.y - b.y);
            gameState.villageGrid.forEach(item => {
                const isHovered = dragState.hoveredUnit === item;
                const isDragged = dragState.draggedUnit === item;

                if (item.type === 'dome') drawEnhancedDome(item.x, item.y, item.size, item, isHovered, isDragged);
                else if (item.type === 'crystal_tree') drawEnhancedCrystalTree(item.x, item.y, item.size, item, isHovered, isDragged);
                else if (item.type === 'garden') drawEnhancedGarden(item.x, item.y, item.size, item, isHovered, isDragged);
                else drawMovableUnit(item, isHovered, isDragged);
            });

            // Draw movement trails
            drawMovementTrails();

            // TDD: Draw intelligent creatures
            drawIntelligentCreatures();

            // TDD: Draw conversational AI units
            drawConversationalUnits();

            // TDD: Draw drag-and-drop visual effects
            drawDragEffects();

            // TDD: Draw unit identification particles
            drawUnitIdentificationEffects();

            // Ambient light effects
            drawAmbientEffects();

            // Restore transformation matrix
            ctx.restore();

            // Draw UI elements that should not be affected by zoom/pan
            drawCanvasUI();

            // Draw minimap
            drawMinimap();

            // Only show debug info in development mode
            if (window.location.hostname === 'localhost' && window.location.search.includes('debug')) {
                drawDebugInfo();
            }
        };

        const drawCanvasUI = () => {
            // Update zoom level display in extended stats
            const zoomLevelEl = document.getElementById('zoom-level');
            if (zoomLevelEl) {
                zoomLevelEl.textContent = `${Math.round(canvasState.zoom * 100)}%`;
            }

            // Update unit count displays
            const visibleUnitsEl = document.getElementById('visible-units');
            const totalUnitsEl = document.getElementById('total-units');
            const totalUnitsMiniEl = document.getElementById('total-units-mini');

            if (visibleUnitsEl && totalUnitsEl) {
                const visibleUnits = countVisibleUnits();
                const totalUnits = gameState.villageGrid.length;
                visibleUnitsEl.textContent = visibleUnits;
                totalUnitsEl.textContent = totalUnits;
                if (totalUnitsMiniEl) {
                    totalUnitsMiniEl.textContent = totalUnits;
                }
            }
        };

        const countVisibleUnits = () => {
            const viewLeft = -canvasState.panX / canvasState.zoom;
            const viewTop = -canvasState.panY / canvasState.zoom;
            const viewRight = viewLeft + canvasState.width / canvasState.zoom;
            const viewBottom = viewTop + canvasState.height / canvasState.zoom;

            return gameState.villageGrid.filter(unit => {
                return unit.x >= viewLeft - unit.size &&
                       unit.x <= viewRight + unit.size &&
                       unit.y >= viewTop - unit.size &&
                       unit.y <= viewBottom + unit.size;
            }).length;
        };

        // --- Canvas Control Functions ---

        const zoomIn = () => {
            canvasState.zoom = Math.min(3.0, canvasState.zoom * 1.2);
        };

        const zoomOut = () => {
            canvasState.zoom = Math.max(0.3, canvasState.zoom / 1.2);
        };

        const resetView = () => {
            canvasState.zoom = 1.0;

            // Center view on existing units if any
            if (gameState.villageGrid.length > 0) {
                let minX = Infinity, maxX = -Infinity;
                let minY = Infinity, maxY = -Infinity;

                gameState.villageGrid.forEach(unit => {
                    minX = Math.min(minX, unit.x);
                    maxX = Math.max(maxX, unit.x);
                    minY = Math.min(minY, unit.y);
                    maxY = Math.max(maxY, unit.y);
                });

                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;

                canvasState.panX = canvasState.width / 2 - centerX;
                canvasState.panY = canvasState.height / 2 - centerY;

                log('🎯 View centered on your sanctuary', 'info');
            } else {
                canvasState.panX = 0;
                canvasState.panY = 0;
                log('🎯 View reset to center (no units to focus on)', 'info');
                log('💡 Tip: Create units using the Units tab or hotkeys (D for Dreamer, W for Weaver)', 'info');
            }
        };



        const showControlsHelp = () => {
            log('🎮 CONTROLS HELP:', 'info');
            log('🖱️ Mouse: Click and drag to pan the view', 'info');
            log('🔍 Zoom: Use +/- buttons or mouse wheel', 'info');
            log('🎯 Reset: Center view on your units', 'info');
            log('⌨️ Hotkeys: D = Dreamer, W = Weaver', 'info');
            log('🏗️ Build: Use the Units tab to create beings', 'info');
            log('🌱 Paths: Choose Ruler or Gardener approach', 'info');
            log('🔄 New Game: Red button to start fresh', 'info');
            log('👆 Click: Click on units for detailed info', 'info');
        };

        // Unit Information System
        let selectedUnit = null;

        const showUnitInfo = (unit) => {
            selectedUnit = unit;
            const panel = document.getElementById('unit-info-panel');
            const content = document.getElementById('unit-info-content');

            if (!panel || !content) return;

            // Get unit configuration
            const unitConfig = unitsConfig[unit.type] || {};

            // Calculate unit stats
            const nearbyUnits = detectNearbyUnits(unit, gameState.villageGrid, 60);
            const interactions = gameState.activeInteractions.filter(interaction =>
                interaction.participants.includes(unit.id)
            );

            content.innerHTML = `
                <div class="space-y-3">
                    <!-- Basic Info -->
                    <div class="bg-gray-800 rounded p-2">
                        <div class="flex items-center space-x-2 mb-2">
                            <span class="text-lg">${getUnitEmoji(unit.type)}</span>
                            <div>
                                <div class="font-bold text-white">${unitConfig.name || unit.type}</div>
                                <div class="text-xs text-gray-400">ID: ${unit.id}</div>
                            </div>
                        </div>
                        <div class="text-sm text-gray-300">${unitConfig.description || 'A mysterious being in your sanctuary.'}</div>
                    </div>

                    <!-- Position & Status -->
                    <div class="grid grid-cols-2 gap-2 text-xs">
                        <div class="bg-gray-800 rounded p-2">
                            <div class="text-gray-400">Position</div>
                            <div class="text-white">${Math.round(unit.x)}, ${Math.round(unit.y)}</div>
                        </div>
                        <div class="bg-gray-800 rounded p-2">
                            <div class="text-gray-400">Size</div>
                            <div class="text-white">${unit.size}px</div>
                        </div>
                        <div class="bg-gray-800 rounded p-2">
                            <div class="text-gray-400">Movable</div>
                            <div class="text-white">${unit.movable ? '✅ Yes' : '❌ No'}</div>
                        </div>
                        <div class="bg-gray-800 rounded p-2">
                            <div class="text-gray-400">Draggable</div>
                            <div class="text-white">${unit.draggable !== false ? '✅ Yes' : '❌ No'}</div>
                        </div>
                    </div>

                    <!-- Nearby Units -->
                    <div class="bg-gray-800 rounded p-2">
                        <div class="text-gray-400 text-xs mb-1">Nearby Units (${nearbyUnits.length})</div>
                        ${nearbyUnits.length > 0 ?
                            nearbyUnits.slice(0, 3).map(nearby =>
                                `<div class="text-xs text-gray-300">• ${nearby.unit.type} (${Math.round(nearby.distance)}px away)</div>`
                            ).join('') +
                            (nearbyUnits.length > 3 ? `<div class="text-xs text-gray-500">... and ${nearbyUnits.length - 3} more</div>` : '')
                            : '<div class="text-xs text-gray-500">No nearby units</div>'
                        }
                    </div>

                    <!-- Active Interactions -->
                    ${interactions.length > 0 ? `
                        <div class="bg-gray-800 rounded p-2">
                            <div class="text-gray-400 text-xs mb-1">Active Interactions (${interactions.length})</div>
                            ${interactions.slice(0, 2).map(interaction =>
                                `<div class="text-xs text-green-300">• ${interaction.type} (${Math.round((Date.now() - interaction.startTime) / 1000)}s)</div>`
                            ).join('')}
                        </div>
                    ` : ''}

                    <!-- Movement Info -->
                    ${unit.movable ? `
                        <div class="bg-gray-800 rounded p-2">
                            <div class="text-gray-400 text-xs mb-1">Movement</div>
                            <div class="text-xs text-gray-300">
                                ${unit.targetX !== undefined ?
                                    `Target: ${Math.round(unit.targetX)}, ${Math.round(unit.targetY)}` :
                                    'No target set'
                                }
                            </div>
                            ${unit.wanderCenter ?
                                `<div class="text-xs text-gray-300">Wander Center: ${Math.round(unit.wanderCenter.x)}, ${Math.round(unit.wanderCenter.y)}</div>` :
                                ''
                            }
                        </div>
                    ` : ''}
                </div>
            `;

            panel.classList.remove('hidden');
        };

        const hideUnitInfo = () => {
            selectedUnit = null;
            const panel = document.getElementById('unit-info-panel');
            if (panel) {
                panel.classList.add('hidden');
            }
        };

        const getUnitEmoji = (type) => {
            const emojis = {
                'dreamer': '💭',
                'weaver': '🕸️',
                'dome': '🏛️',
                'crystal_tree': '🌳',
                'garden': '🌸',
                'sage': '🧙',
                'explorer': '🗺️',
                'philosopher': '📚',
                'artist': '🎨',
                'healer': '💚'
            };
            return emojis[type] || '👤';
        };



        const resetGameStateToDefaults = () => {
            // Reset all resources to starting values
            gameState.energy = 20;
            gameState.insight = 5;
            gameState.inspiration = 0;
            gameState.wisdom = 0;
            gameState.consciousness = 10;
            gameState.control = 0;
            gameState.harmony = 75;
            gameState.entropy = 0;
            gameState.planetaryConsciousness = 10;

            // Reset per-second rates
            gameState.energyPerSecond = 0.1;
            gameState.insightPerSecond = 0.05;
            gameState.inspirationPerSecond = 0;
            gameState.wisdomPerSecond = 0;
            gameState.consciousnessPerSecond = 0;
            gameState.controlPerSecond = 0;

            // Reset buildings
            Object.keys(gameState.rulerBuildings).forEach(key => {
                gameState.rulerBuildings[key] = 0;
            });
            Object.keys(gameState.gardenerBuildings).forEach(key => {
                gameState.gardenerBuildings[key] = 0;
            });

            // Reset units
            gameState.villageGrid = [];

            // Reset story progression
            gameState.storyPhase = 'early';
            gameState.anomalyDiscovered = false;
            gameState.trueLoreRevealed = false;
            gameState.rulerPathProgress = 0;
            gameState.gardenerPathProgress = 0;
            gameState.dominantPath = 'none';

            // Reset crisis system
            gameState.crisisLevel = 0;
            gameState.activeCrises = [];
            gameState.horsemenDefeated = [];
            gameState.lastCrisisTime = 0;

            // Reset other flags
            gameState.gameEnded = false;
            gameState.techTreeUnlocked = false;

            // Reset statistics
            gameState.statistics = {
                totalUnitsCreated: 0,
                totalResourcesGenerated: 0,
                totalBuildingsBuilt: 0,
                rulerPathChoices: 0,
                gardenerPathChoices: 0,
                achievementsUnlocked: 0,
                goalsCompleted: 0
            };

            // Reset achievements and goals
            if (window.achievements) {
                Object.values(window.achievements).forEach(achievement => {
                    achievement.unlocked = false;
                    achievement.progress = 0;
                });
            }

            if (window.goals) {
                Object.values(window.goals).forEach(goal => {
                    goal.completed = false;
                    goal.progress = 0;
                });
            }

            // Force re-initialization of UI components
            rulerBuildingsInitialized = false;
            gardenerBuildingsInitialized = false;
        };

        const initializeCanvasControls = () => {
            // Canvas controls
            const newGameBtn = document.getElementById('new-game-btn');
            const zoomInBtn = document.getElementById('zoom-in-btn');
            const zoomOutBtn = document.getElementById('zoom-out-btn');
            const resetViewBtn = document.getElementById('reset-view-btn');
            const helpBtn = document.getElementById('help-btn');
            const closeUnitInfoBtn = document.getElementById('close-unit-info');

            if (newGameBtn) newGameBtn.addEventListener('click', startNewGame);
            if (zoomInBtn) zoomInBtn.addEventListener('click', zoomIn);
            if (zoomOutBtn) zoomOutBtn.addEventListener('click', zoomOut);
            if (resetViewBtn) resetViewBtn.addEventListener('click', resetView);
            if (helpBtn) helpBtn.addEventListener('click', showControlsHelp);
            if (closeUnitInfoBtn) closeUnitInfoBtn.addEventListener('click', hideUnitInfo);

            // Mouse wheel zoom
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                if (e.deltaY < 0) {
                    zoomIn();
                } else {
                    zoomOut();
                }
            });

            // Pan with middle mouse button or Shift+drag
            let isPanning = false;
            let lastPanX = 0;
            let lastPanY = 0;

            canvas.addEventListener('mousedown', (e) => {
                if (e.button === 1 || (e.button === 0 && e.shiftKey)) { // Middle button or Shift+left
                    isPanning = true;
                    lastPanX = e.clientX;
                    lastPanY = e.clientY;
                    e.preventDefault();
                }
            });

            canvas.addEventListener('mousemove', (e) => {
                if (isPanning) {
                    const deltaX = e.clientX - lastPanX;
                    const deltaY = e.clientY - lastPanY;
                    canvasState.panX += deltaX;
                    canvasState.panY += deltaY;
                    lastPanX = e.clientX;
                    lastPanY = e.clientY;
                }
            });

            canvas.addEventListener('mouseup', (e) => {
                if (e.button === 1 || (e.button === 0 && e.shiftKey)) {
                    isPanning = false;
                }
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

                switch (e.key) {
                    case '+':
                    case '=':
                        zoomIn();
                        e.preventDefault();
                        break;
                    case '-':
                        zoomOut();
                        e.preventDefault();
                        break;
                    case '0':
                        resetView();
                        e.preventDefault();
                        break;
                    case 'a':
                    case 'A':
                        if (e.ctrlKey || e.metaKey) {
                            autoArrangeUnits();
                            e.preventDefault();
                        }
                        break;
                }
            });
        };

        const initializeStatsToggle = () => {
            const statsToggle = document.getElementById('stats-toggle');
            const extendedStats = document.getElementById('extended-stats');
            const newGameMainBtn = document.getElementById('new-game-main-btn');

            if (statsToggle && extendedStats) {
                statsToggle.addEventListener('click', () => {
                    const isHidden = extendedStats.classList.contains('hidden');
                    if (isHidden) {
                        extendedStats.classList.remove('hidden');
                        statsToggle.textContent = '📊 Less';
                        statsToggle.title = 'Hide Extended Stats';
                    } else {
                        extendedStats.classList.add('hidden');
                        statsToggle.textContent = '📊 More';
                        statsToggle.title = 'Show Extended Stats';
                    }
                });
            }

            if (newGameMainBtn) {
                newGameMainBtn.addEventListener('click', startNewGame);
            }
        };

        // --- Minimap System ---

        const drawMinimap = () => {
            const minimapCanvas = document.getElementById('minimap-canvas');
            if (!minimapCanvas) return;

            const minimapCtx = minimapCanvas.getContext('2d');
            const minimapWidth = minimapCanvas.width;
            const minimapHeight = minimapCanvas.height;

            // Clear minimap
            minimapCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            minimapCtx.fillRect(0, 0, minimapWidth, minimapHeight);

            // Calculate scale
            const scaleX = minimapWidth / canvasState.width;
            const scaleY = minimapHeight / canvasState.height;
            const scale = Math.min(scaleX, scaleY);

            // Calculate centering offsets
            const actualMinimapWidth = canvasState.width * scale;
            const actualMinimapHeight = canvasState.height * scale;
            const offsetX = (minimapWidth - actualMinimapWidth) / 2;
            const offsetY = (minimapHeight - actualMinimapHeight) / 2;

            // Draw units on minimap
            gameState.villageGrid.forEach(unit => {
                const x = offsetX + unit.x * scale;
                const y = offsetY + unit.y * scale;

                minimapCtx.fillStyle = getUnitMinimapColor(unit.type);
                minimapCtx.fillRect(x - 1, y - 1, 2, 2);
            });

            // Draw viewport indicator
            const viewLeft = -canvasState.panX / canvasState.zoom;
            const viewTop = -canvasState.panY / canvasState.zoom;
            const viewWidth = canvasState.width / canvasState.zoom;
            const viewHeight = canvasState.height / canvasState.zoom;

            minimapCtx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
            minimapCtx.lineWidth = 1;
            minimapCtx.strokeRect(
                offsetX + viewLeft * scale,
                offsetY + viewTop * scale,
                viewWidth * scale,
                viewHeight * scale
            );
        };

        const getUnitMinimapColor = (type) => {
            const colors = {
                'dreamer': '#8B5CF6',
                'weaver': '#10B981',
                'dome': '#F59E0B',
                'crystal_tree': '#06B6D4',
                'garden': '#84CC16',
                'stellarNomads': '#F59E0B',
                'voidWhisperers': '#6B7280',
                'crystalBeings': '#10B981',
                'plasmaDancers': '#EC4899',
                'quantumSages': '#8B5CF6',
                'nebulaShepherds': '#06B6D4'
            };
            return colors[type] || '#9CA3AF';
        };

        // Minimap click navigation
        const initializeMinimapNavigation = () => {
            const minimapCanvas = document.getElementById('minimap-canvas');
            if (!minimapCanvas) return;

            minimapCanvas.addEventListener('click', (e) => {
                const rect = minimapCanvas.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const clickY = e.clientY - rect.top;

                // Calculate scale (same as drawing)
                const minimapWidth = minimapCanvas.width;
                const minimapHeight = minimapCanvas.height;
                const scaleX = minimapWidth / canvasState.width;
                const scaleY = minimapHeight / canvasState.height;
                const scale = Math.min(scaleX, scaleY);

                // Calculate the actual minimap area (centered in canvas)
                const actualMinimapWidth = canvasState.width * scale;
                const actualMinimapHeight = canvasState.height * scale;
                const offsetX = (minimapWidth - actualMinimapWidth) / 2;
                const offsetY = (minimapHeight - actualMinimapHeight) / 2;

                // Check if click is within the actual minimap area
                const relativeX = clickX - offsetX;
                const relativeY = clickY - offsetY;

                if (relativeX < 0 || relativeY < 0 || relativeX > actualMinimapWidth || relativeY > actualMinimapHeight) {
                    return; // Click outside minimap area
                }

                // Convert minimap coordinates to world coordinates
                const worldX = relativeX / scale;
                const worldY = relativeY / scale;

                // Center the view on the clicked location
                canvasState.panX = -(worldX - canvasState.width / (2 * canvasState.zoom));
                canvasState.panY = -(worldY - canvasState.height / (2 * canvasState.zoom));

                log(`Navigated to (${Math.round(worldX)}, ${Math.round(worldY)})`, 'info');
            });

            // Add hover cursor
            minimapCanvas.style.cursor = 'pointer';
        };

        const drawDebugInfo = () => {
            // Draw debug information in top-left corner
            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(10, 10, 200, 120);

            ctx.fillStyle = 'white';
            ctx.font = '12px monospace';
            ctx.fillText(`Canvas: ${canvas.width}x${canvas.height}`, 15, 25);
            ctx.fillText(`Zoom: ${canvasState.zoom.toFixed(2)}`, 15, 40);
            ctx.fillText(`Pan: ${canvasState.panX.toFixed(0)}, ${canvasState.panY.toFixed(0)}`, 15, 55);
            ctx.fillText(`Units: ${gameState.villageGrid.length}`, 15, 70);
            ctx.fillText(`Stars: ${gameState.stars.length}`, 15, 85);
            ctx.fillText(`Animation: ${animationTime.toFixed(2)}`, 15, 100);

            // Show first few unit positions
            if (gameState.villageGrid.length > 0) {
                ctx.fillText(`Unit 1: ${gameState.villageGrid[0].x.toFixed(0)}, ${gameState.villageGrid[0].y.toFixed(0)}`, 15, 115);
            }

            ctx.restore();
        };

        const drawBackground = () => {
            // Multi-layer gradient background
            const gradient1 = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient1.addColorStop(0, '#0a0820');
            gradient1.addColorStop(0.3, '#1a1040');
            gradient1.addColorStop(0.7, '#2a1860');
            gradient1.addColorStop(1, '#1c1944');
            ctx.fillStyle = gradient1;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Nebula clouds
            for (let i = 0; i < 3; i++) {
                const x = (canvas.width * 0.2) + (i * canvas.width * 0.3);
                const y = canvas.height * 0.3 + Math.sin(animationTime * 0.5 + i) * 20;
                const radius = 150 + Math.sin(animationTime * 0.3 + i) * 30;

                const nebulaGradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                nebulaGradient.addColorStop(0, `rgba(138, 43, 226, ${0.1 + Math.sin(animationTime + i) * 0.05})`);
                nebulaGradient.addColorStop(0.5, `rgba(75, 0, 130, ${0.05 + Math.sin(animationTime * 0.7 + i) * 0.03})`);
                nebulaGradient.addColorStop(1, 'rgba(75, 0, 130, 0)');

                ctx.fillStyle = nebulaGradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        };

        const drawStars = () => {
            // Initialize enhanced stars
            if (gameState.stars.length === 0) {
                for (let i = 0; i < 150; i++) {
                    gameState.stars.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        radius: Math.random() * 2 + 0.5,
                        alpha: 0.3 + Math.random() * 0.7,
                        twinkleSpeed: 0.5 + Math.random() * 2,
                        color: Math.random() > 0.8 ? 'rgba(200, 150, 255, ' : 'rgba(255, 255, 255, '
                    });
                }
            }

            gameState.stars.forEach(star => {
                const twinkle = 0.7 + Math.sin(animationTime * star.twinkleSpeed + star.x) * 0.3;
                const alpha = star.alpha * twinkle;

                // Star glow
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius * 2, 0, Math.PI * 2);
                ctx.fillStyle = star.color + (alpha * 0.2) + ')';
                ctx.fill();

                // Star core
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                ctx.fillStyle = star.color + alpha + ')';
                ctx.fill();
            });
        };

        const updateAndDrawParticles = () => {
            // Add new particles occasionally
            if (Math.random() < 0.3) {
                particles.push({
                    x: Math.random() * canvas.width,
                    y: canvas.height + 10,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: -Math.random() * 2 - 0.5,
                    life: 1.0,
                    decay: 0.005 + Math.random() * 0.01,
                    size: Math.random() * 3 + 1,
                    color: Math.random() > 0.5 ? 'rgba(167, 139, 250, ' : 'rgba(196, 181, 253, '
                });
            }

            // Update and draw particles
            particles = particles.filter(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life -= particle.decay;

                if (particle.life > 0) {
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size * particle.life, 0, Math.PI * 2);
                    ctx.fillStyle = particle.color + (particle.life * 0.6) + ')';
                    ctx.fill();
                    return true;
                }
                return false;
            });
        };

        // TDD Task 1: Enhanced sprite system with movement capabilities
        let spriteIdCounter = 0;

        const addSprite = (type, count = 1) => {
            for (let i = 0; i < count; i++) {
                const size = type === 'dome' ? 20 : type === 'crystal_tree' ? 25 : 15;

                // Calculate safe spawning area (in world coordinates)
                const worldWidth = canvasState.width / canvasState.zoom;
                const worldHeight = canvasState.height / canvasState.zoom;
                const viewLeft = -canvasState.panX / canvasState.zoom;
                const viewTop = -canvasState.panY / canvasState.zoom;

                const safeLeft = Math.max(viewLeft + canvasState.safeZone.left / canvasState.zoom, size);
                const safeRight = Math.min(viewLeft + worldWidth - canvasState.safeZone.right / canvasState.zoom, canvasState.width - size);
                const safeTop = Math.max(viewTop + canvasState.safeZone.top / canvasState.zoom, size);
                const safeBottom = Math.min(viewTop + worldHeight - canvasState.safeZone.bottom / canvasState.zoom, canvasState.height - size);

                // Ensure we have valid spawning area
                const safeWidth = Math.max(100, safeRight - safeLeft);
                const safeHeight = Math.max(100, safeBottom - safeTop);

                const x = safeLeft + Math.random() * safeWidth;
                const y = safeTop + Math.random() * safeHeight;

                // Determine if unit is movable based on type
                const movable = ['dreamer', 'weaver', 'stellarNomads', 'voidWhisperers',
                               'crystalBeings', 'plasmaDancers', 'quantumSages', 'nebulaShepherds'].includes(type);

                const sprite = {
                    type: type,
                    x: x,
                    y: y,
                    size: size,
                    movable: movable,
                    id: `${type}_${spriteIdCounter++}`,
                    animationOffset: Math.random() * Math.PI * 2,
                    pulseSpeed: 0.5 + Math.random() * 1.5,
                    // Movement properties for movable units
                    targetX: x,
                    targetY: y,
                    vx: 0,
                    vy: 0,
                    wanderCenter: { x: x, y: y },
                    wanderPhase: Math.random() * Math.PI * 2,
                    wanderRadius: 30 + Math.random() * 20,
                    // Player ownership for multiplayer
                    owner: gameState.currentPlayer === 'alliance' ? 'shared' : gameState.currentPlayer
                };

                gameState.villageGrid.push(sprite);
            }
        };

        const drawEnhancedDome = (x, y, size, sprite, isHovered, isDragged) => {
            ctx.save();

            // Visual feedback for interaction states
            let scale = 1.0;
            let alpha = 1.0;
            let glowIntensity = 0.8;

            if (isDragged) {
                scale = 1.2;
                alpha = 0.9;
                glowIntensity = 1.2;
            } else if (isHovered) {
                scale = 1.1;
                glowIntensity = 1.0;
            }

            ctx.globalAlpha = alpha;
            ctx.translate(x, y);
            ctx.scale(scale, scale);

            const pulse = Math.sin(animationTime * (sprite.pulseSpeed || 1) + (sprite.animationOffset || 0)) * 0.15 + 1;
            const currentSize = size * pulse;

            // Layer 1: Outer energy field with orange/yellow theme
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            ctx.shadowColor = '#FBBF24';
            ctx.shadowBlur = 25 * glowIntensity;
            ctx.beginPath();
            ctx.arc(0, 0, currentSize * 1.8, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(251, 191, 36, 0.2)';
            ctx.fill();
            ctx.restore();

            // Layer 2: Main dome with enhanced orange gradient
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize);
            gradient.addColorStop(0, 'rgba(255, 215, 77, 1.0)');
            gradient.addColorStop(0.6, 'rgba(245, 158, 11, 0.9)');
            gradient.addColorStop(1, 'rgba(217, 119, 6, 0.7)');

            ctx.shadowColor = '#FBBF24';
            ctx.shadowBlur = 15 * glowIntensity;
            ctx.beginPath();
            ctx.arc(0, 0, currentSize, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();

            // Layer 3: Inner highlight
            ctx.save();
            ctx.globalCompositeOperation = 'overlay';
            const highlightGradient = ctx.createRadialGradient(-currentSize * 0.3, -currentSize * 0.3, 0, 0, 0, currentSize * 0.8);
            highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
            highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.beginPath();
            ctx.arc(0, 0, currentSize * 0.7, 0, Math.PI * 2);
            ctx.fillStyle = highlightGradient;
            ctx.fill();
            ctx.restore();

            // Layer 4: Energy orbs floating around dome
            for (let i = 0; i < 3; i++) {
                const angle = animationTime * 0.5 + (i * Math.PI * 2 / 3) + (sprite.animationOffset || 0);
                const orbX = Math.cos(angle) * (currentSize + 15);
                const orbY = Math.sin(angle) * (currentSize + 15);

                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                ctx.shadowColor = '#FBBF24';
                ctx.shadowBlur = 8;
                ctx.beginPath();
                ctx.arc(orbX, orbY, 3, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 215, 77, 0.8)';
                ctx.fill();
                ctx.restore();
            }

            ctx.shadowBlur = 0;
            ctx.restore();
        };

        const drawEnhancedCrystalTree = (x, y, size, sprite) => {
            const pulse = Math.sin(animationTime * sprite.pulseSpeed + sprite.animationOffset) * 0.15 + 1;
            const currentSize = size * pulse;

            // Crystal base/roots
            ctx.beginPath();
            ctx.ellipse(x, y, currentSize * 0.8, currentSize * 0.3, 0, 0, Math.PI * 2);
            const baseGradient = ctx.createRadialGradient(x, y, 0, x, y, currentSize * 0.8);
            baseGradient.addColorStop(0, `rgba(139, 92, 246, ${0.6 * pulse})`);
            baseGradient.addColorStop(1, `rgba(79, 70, 229, ${0.3 * pulse})`);
            ctx.fillStyle = baseGradient;
            ctx.fill();

            // Main crystal trunk with facets
            const trunkHeight = currentSize * 2;
            const trunkWidth = currentSize * 0.6;

            // Multiple crystal facets
            for (let i = 0; i < 6; i++) {
                const angle = (i * Math.PI) / 3;
                const facetX = x + Math.cos(angle) * (trunkWidth * 0.3);
                const facetY = y - trunkHeight * 0.5;

                ctx.beginPath();
                ctx.moveTo(facetX, y);
                ctx.lineTo(facetX + Math.cos(angle) * (trunkWidth * 0.2), facetY);
                ctx.lineTo(x, y - trunkHeight);
                ctx.lineTo(facetX - Math.cos(angle) * (trunkWidth * 0.2), facetY);
                ctx.closePath();

                const facetGradient = ctx.createLinearGradient(facetX, y, x, y - trunkHeight);
                const brightness = 0.5 + Math.sin(animationTime + angle) * 0.3;
                facetGradient.addColorStop(0, `rgba(139, 92, 246, ${brightness * pulse})`);
                facetGradient.addColorStop(0.5, `rgba(167, 139, 250, ${(brightness + 0.2) * pulse})`);
                facetGradient.addColorStop(1, `rgba(196, 181, 253, ${(brightness + 0.4) * pulse})`);

                ctx.fillStyle = facetGradient;
                ctx.fill();

                // Crystal edges with glow
                ctx.strokeStyle = `rgba(255, 255, 255, ${0.8 * pulse})`;
                ctx.lineWidth = 1;
                ctx.shadowColor = 'rgba(167, 139, 250, 0.8)';
                ctx.shadowBlur = 5;
                ctx.stroke();
                ctx.shadowBlur = 0;
            }

            // Crystal tip with intense glow
            ctx.beginPath();
            ctx.arc(x, y - trunkHeight, currentSize * 0.2, 0, Math.PI * 2);
            const tipGradient = ctx.createRadialGradient(x, y - trunkHeight, 0, x, y - trunkHeight, currentSize * 0.2);
            tipGradient.addColorStop(0, `rgba(255, 255, 255, ${0.9 * pulse})`);
            tipGradient.addColorStop(1, `rgba(196, 181, 253, ${0.6 * pulse})`);
            ctx.fillStyle = tipGradient;
            ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
            ctx.shadowBlur = 15;
            ctx.fill();
            ctx.shadowBlur = 0;

            // Energy wisps rising from crystal
            for (let i = 0; i < 2; i++) {
                const wispY = y - trunkHeight - 20 - (animationTime * 20 + i * 50) % 100;
                const wispX = x + Math.sin(animationTime + i) * 10;

                if (wispY > y - trunkHeight - 120) {
                    ctx.beginPath();
                    ctx.arc(wispX, wispY, 2, 0, Math.PI * 2);
                    const wispAlpha = 1 - ((y - trunkHeight - 20 - wispY) / 100);
                    ctx.fillStyle = `rgba(196, 181, 253, ${wispAlpha * 0.8})`;
                    ctx.fill();
                }
            }
        };
        
        const drawEnhancedGarden = (x, y, size, sprite) => {
            const pulse = Math.sin(animationTime * sprite.pulseSpeed + sprite.animationOffset) * 0.1 + 1;

            // Garden base with organic shape
            ctx.beginPath();
            for (let i = 0; i <= 16; i++) {
                const angle = (i / 16) * Math.PI * 2;
                const radius = size * (0.8 + Math.sin(angle * 3 + animationTime) * 0.2) * pulse;
                const px = x + Math.cos(angle) * radius;
                const py = y + Math.sin(angle) * radius * 0.6;

                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();

            const gardenGradient = ctx.createRadialGradient(x, y, 0, x, y, size);
            gardenGradient.addColorStop(0, `rgba(34, 197, 94, ${0.3 * pulse})`);
            gardenGradient.addColorStop(0.5, `rgba(22, 163, 74, ${0.2 * pulse})`);
            gardenGradient.addColorStop(1, `rgba(21, 128, 61, ${0.1 * pulse})`);
            ctx.fillStyle = gardenGradient;
            ctx.fill();

            // Magical flowers with different types
            const flowerTypes = [
                { color: '#fde047', glow: '#facc15', size: 4 }, // Golden
                { color: '#a78bfa', glow: '#8b5cf6', size: 3 }, // Purple
                { color: '#f472b6', glow: '#ec4899', size: 3.5 }, // Pink
                { color: '#34d399', glow: '#10b981', size: 3 }  // Emerald
            ];

            // Static flower positions based on sprite properties
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2 + sprite.animationOffset;
                const distance = (size * 0.6) + Math.sin(animationTime * 0.5 + i) * (size * 0.2);
                const flowerX = x + Math.cos(angle) * distance;
                const flowerY = y + Math.sin(angle) * distance * 0.6;

                const flowerType = flowerTypes[i % flowerTypes.length];
                const flowerPulse = Math.sin(animationTime * 2 + i) * 0.3 + 1;

                // Flower glow
                ctx.beginPath();
                ctx.arc(flowerX, flowerY, flowerType.size * flowerPulse * 1.5, 0, Math.PI * 2);
                ctx.fillStyle = flowerType.glow + '40'; // 25% opacity
                ctx.fill();

                // Flower petals
                for (let p = 0; p < 5; p++) {
                    const petalAngle = (p / 5) * Math.PI * 2 + animationTime * 0.1;
                    const petalX = flowerX + Math.cos(petalAngle) * flowerType.size * 0.8;
                    const petalY = flowerY + Math.sin(petalAngle) * flowerType.size * 0.8;

                    ctx.beginPath();
                    ctx.arc(petalX, petalY, flowerType.size * 0.6 * flowerPulse, 0, Math.PI * 2);
                    ctx.fillStyle = flowerType.color;
                    ctx.shadowColor = flowerType.glow;
                    ctx.shadowBlur = 8;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }

                // Flower center
                ctx.beginPath();
                ctx.arc(flowerX, flowerY, flowerType.size * 0.3, 0, Math.PI * 2);
                ctx.fillStyle = '#fbbf24';
                ctx.shadowColor = '#f59e0b';
                ctx.shadowBlur = 5;
                ctx.fill();
                ctx.shadowBlur = 0;
            }

            // Floating pollen particles
            for (let i = 0; i < 3; i++) {
                const pollenX = x + Math.sin(animationTime * 0.8 + i) * size * 0.8;
                const pollenY = y + Math.cos(animationTime * 0.6 + i) * size * 0.4 - 10;

                ctx.beginPath();
                ctx.arc(pollenX, pollenY, 1.5, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(251, 191, 36, ${0.6 + Math.sin(animationTime * 2 + i) * 0.4})`;
                ctx.fill();
            }
        };

        const drawEnergyFlows = () => {
            // Draw energy connections between structures
            const domes = gameState.villageGrid.filter(item => item.type === 'dome');
            const crystals = gameState.villageGrid.filter(item => item.type === 'crystal_tree');

            // Energy flows from crystals to domes (insight to energy conversion)
            crystals.forEach(crystal => {
                domes.forEach(dome => {
                    const distance = Math.sqrt((dome.x - crystal.x) ** 2 + (dome.y - crystal.y) ** 2);
                    if (distance < 200) { // Only connect nearby structures
                        drawEnergyBeam(crystal.x, crystal.y - crystal.size, dome.x, dome.y, 'insight');
                    }
                });
            });
        };

        const drawEnergyBeam = (x1, y1, x2, y2, type) => {
            const flowSpeed = animationTime * 3;
            const color = type === 'insight' ? 'rgba(167, 139, 250, ' : 'rgba(34, 197, 94, ';

            // Main beam
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.strokeStyle = color + '0.3)';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Animated energy particles along the beam
            const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
            const steps = Math.floor(distance / 20);

            for (let i = 0; i < steps; i++) {
                const progress = (i / steps + flowSpeed * 0.1) % 1;
                const x = x1 + (x2 - x1) * progress;
                const y = y1 + (y2 - y1) * progress;

                ctx.beginPath();
                ctx.arc(x, y, 2, 0, Math.PI * 2);
                ctx.fillStyle = color + (0.8 * (1 - progress)) + ')';
                ctx.shadowColor = color + '0.8)';
                ctx.shadowBlur = 5;
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        };

        const drawAmbientEffects = () => {
            // Ambient magical aura around the entire sanctuary
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const maxRadius = Math.max(canvas.width, canvas.height) * 0.6;

            const auraGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, maxRadius);
            auraGradient.addColorStop(0, 'rgba(167, 139, 250, 0)');
            auraGradient.addColorStop(0.7, `rgba(167, 139, 250, ${0.05 + Math.sin(animationTime * 0.5) * 0.02})`);
            auraGradient.addColorStop(1, 'rgba(75, 0, 130, 0)');

            ctx.fillStyle = auraGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Floating light orbs
            for (let i = 0; i < 5; i++) {
                const orbX = centerX + Math.sin(animationTime * 0.3 + i) * (canvas.width * 0.3);
                const orbY = centerY + Math.cos(animationTime * 0.2 + i) * (canvas.height * 0.2);
                const orbSize = 3 + Math.sin(animationTime + i) * 1;

                ctx.beginPath();
                ctx.arc(orbX, orbY, orbSize, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(196, 181, 253, ${0.4 + Math.sin(animationTime * 2 + i) * 0.2})`;
                ctx.shadowColor = 'rgba(196, 181, 253, 0.8)';
                ctx.shadowBlur = 10;
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        };

        // --- TDD API Key Management ---
        const getApiKey = () => {
            return localStorage.getItem('grok_api_key') || '';
        };

        const saveApiKey = (key) => {
            if (key && key.trim() && key.length >= 10) {
                localStorage.setItem('grok_api_key', key.trim());
                return true;
            }
            return false;
        };

        const showApiKeyPopup = () => {
            const popup = document.getElementById('api-key-popup');
            const input = document.getElementById('api-key-input');
            const error = document.getElementById('api-key-error');

            popup.classList.remove('hidden');
            input.focus();
            error.classList.add('hidden');
            error.textContent = '';
        };

        const hideApiKeyPopup = () => {
            const popup = document.getElementById('api-key-popup');
            const input = document.getElementById('api-key-input');

            popup.classList.add('hidden');
            input.value = '';
        };

        const showApiKeyError = (message) => {
            const error = document.getElementById('api-key-error');
            error.textContent = message;
            error.classList.remove('hidden');
        };

        // --- TDD Task 1: Unit Movement and Drag-and-Drop System ---

        const updateUnitMovement = (deltaTime) => {
            gameState.villageGrid.forEach(unit => {
                if (!unit.movable) return;

                // Auto-wandering for dreamers
                if (unit.type === 'dreamer' && !dragState.isDragging) {
                    updateWandering(unit, animationTime);
                }

                // Smooth movement towards target
                const dx = unit.targetX - unit.x;
                const dy = unit.targetY - unit.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 1) {
                    const speed = 50; // pixels per second
                    const moveDistance = speed * deltaTime;
                    const ratio = Math.min(moveDistance / distance, 1);

                    unit.x += dx * ratio;
                    unit.y += dy * ratio;
                    unit.vx = dx * ratio / deltaTime;
                    unit.vy = dy * ratio / deltaTime;
                } else {
                    unit.vx = 0;
                    unit.vy = 0;
                }
            });
        };

        const updateWandering = (unit, time) => {
            const wanderSpeed = 0.3;
            const wanderRadius = unit.wanderRadius || 30;

            unit.targetX = unit.wanderCenter.x + Math.sin(time * wanderSpeed + unit.wanderPhase) * wanderRadius;
            unit.targetY = unit.wanderCenter.y + Math.cos(time * wanderSpeed + unit.wanderPhase) * wanderRadius;

            // Keep within canvas bounds
            unit.targetX = Math.max(50, Math.min(canvas.width - 50, unit.targetX));
            unit.targetY = Math.max(50, Math.min(canvas.height - 50, unit.targetY));
        };

        const getUnitAtPosition = (x, y) => {
            for (let i = gameState.villageGrid.length - 1; i >= 0; i--) {
                const unit = gameState.villageGrid[i];
                const dx = x - unit.x;
                const dy = y - unit.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance <= unit.size) {
                    return unit;
                }
            }
            return null;
        };

        const getConversationalUnitAtPosition = (x, y) => {
            for (let i = gameState.conversationalUnits.length - 1; i >= 0; i--) {
                const unit = gameState.conversationalUnits[i];
                const dx = x - unit.x;
                const dy = y - unit.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance <= unit.size) {
                    return unit;
                }
            }
            return null;
        };

        // --- TDD: Enhanced Drag-and-Drop System ---

        const getDraggableUnitAtPosition = (x, y) => {
            // Check all draggable unit types in order of priority (top to bottom)
            const allDraggableUnits = [
                ...gameState.conversationalUnits.filter(unit => unit.draggable !== false),
                ...gameState.intelligentCreatures.filter(unit => unit.draggable !== false),
                ...gameState.villageGrid.filter(unit => unit.movable === true || unit.draggable === true)
            ];

            let bestMatch = null;
            let smallestDistance = Infinity;

            allDraggableUnits.forEach(unit => {
                const distance = Math.sqrt(
                    Math.pow(x - unit.x, 2) + Math.pow(y - unit.y, 2)
                );

                if (distance <= unit.size && distance < smallestDistance) {
                    smallestDistance = distance;
                    bestMatch = {
                        unit: unit,
                        unitType: getUnitType(unit),
                        distance: distance
                    };
                }
            });

            return bestMatch;
        };

        const getUnitType = (unit) => {
            if (gameState.conversationalUnits.includes(unit)) return 'conversational';
            if (gameState.intelligentCreatures.includes(unit)) return 'intelligent';
            if (gameState.villageGrid.includes(unit)) return 'village';
            return 'unknown';
        };

        const validateUnitPlacement = (unit, canvasBounds) => {
            // Check canvas boundaries
            if (unit.x < unit.size || unit.x > canvasBounds.width - unit.size ||
                unit.y < unit.size || unit.y > canvasBounds.height - unit.size) {
                return false;
            }

            // Check for overlaps with non-draggable units (like domes)
            const nonDraggableUnits = gameState.villageGrid.filter(u => u.draggable === false && u.movable !== true);
            for (let otherUnit of nonDraggableUnits) {
                const distance = Math.sqrt(
                    Math.pow(unit.x - otherUnit.x, 2) + Math.pow(unit.y - otherUnit.y, 2)
                );
                if (distance < (unit.size + otherUnit.size) * 0.7) { // 70% overlap threshold
                    return false;
                }
            }

            return true;
        };

        const calculatePlacementEffects = (unit) => {
            const effects = [];

            // Get all units for proximity calculations
            const allUnits = [
                ...gameState.villageGrid,
                ...gameState.intelligentCreatures,
                ...gameState.conversationalUnits
            ];

            // Check for proximity bonuses
            const nearbyUnits = allUnits.filter(otherUnit => {
                if (otherUnit.id === unit.id) return false;
                const distance = Math.sqrt(
                    Math.pow(unit.x - otherUnit.x, 2) + Math.pow(unit.y - otherUnit.y, 2)
                );
                return distance <= 80; // Proximity threshold
            });

            if (nearbyUnits.length > 0) {
                effects.push({
                    type: 'proximity_bonus',
                    description: `Near ${nearbyUnits.length} other units`,
                    bonus: nearbyUnits.length * 0.1,
                    nearbyUnits: nearbyUnits
                });
            }

            // Check for strategic positions (energy-rich areas)
            if (unit.x > canvas.width * 0.6 && unit.y > canvas.height * 0.5) {
                effects.push({
                    type: 'strategic_position',
                    description: 'Positioned in energy-rich area',
                    bonus: 0.15
                });
            }

            return effects;
        };

        const getProximityIndicators = (draggedUnit, proximityRadius = 80) => {
            const indicators = [];
            const allUnits = [
                ...gameState.villageGrid,
                ...gameState.intelligentCreatures,
                ...gameState.conversationalUnits
            ];

            allUnits.forEach(unit => {
                if (unit.id === draggedUnit.id) return;

                const distance = Math.sqrt(
                    Math.pow(draggedUnit.x - unit.x, 2) +
                    Math.pow(draggedUnit.y - unit.y, 2)
                );

                if (distance <= proximityRadius) {
                    indicators.push({
                        type: 'proximity_indicator',
                        targetUnit: unit,
                        distance: distance,
                        strength: 1 - (distance / proximityRadius),
                        interactionType: determineInteractionType(draggedUnit, unit)
                    });
                }
            });

            return indicators;
        };

        // --- TDD: Drag-and-Drop Visual Effects ---

        const drawDragEffects = () => {
            if (!dragState.isDragging || !dragState.draggedUnit) return;

            const unit = dragState.draggedUnit;

            // Draw drag trail
            if (dragState.originalPosition && dragState.totalDragDistance > 20) {
                drawDragTrail(dragState.originalPosition, { x: unit.x, y: unit.y });
            }

            // Draw placement preview
            drawPlacementPreview(unit);

            // Draw proximity indicators
            drawProximityIndicators(dragState.proximityIndicators);

            // Draw placement validation
            drawPlacementValidation(unit, dragState.isValidPlacement);
        };

        const drawDragTrail = (from, to) => {
            ctx.save();
            ctx.strokeStyle = 'rgba(139, 92, 246, 0.6)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.shadowColor = 'rgba(139, 92, 246, 0.3)';
            ctx.shadowBlur = 10;

            ctx.beginPath();
            ctx.moveTo(from.x, from.y);
            ctx.lineTo(to.x, to.y);
            ctx.stroke();

            ctx.restore();
        };

        const drawPlacementPreview = (unit) => {
            ctx.save();
            ctx.strokeStyle = dragState.isValidPlacement ? 'rgba(16, 185, 129, 0.8)' : 'rgba(239, 68, 68, 0.8)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.shadowColor = dragState.isValidPlacement ? 'rgba(16, 185, 129, 0.4)' : 'rgba(239, 68, 68, 0.4)';
            ctx.shadowBlur = 15;

            ctx.beginPath();
            ctx.arc(unit.x, unit.y, unit.size + 10, 0, Math.PI * 2);
            ctx.stroke();

            // Draw placement effects indicators
            if (dragState.placementEffects.length > 0) {
                ctx.fillStyle = 'rgba(16, 185, 129, 0.1)';
                ctx.fill();

                // Draw effect icons
                dragState.placementEffects.forEach((effect, index) => {
                    const angle = (index * Math.PI * 2) / dragState.placementEffects.length;
                    const iconX = unit.x + Math.cos(angle) * (unit.size + 20);
                    const iconY = unit.y + Math.sin(angle) * (unit.size + 20);

                    ctx.fillStyle = 'rgba(16, 185, 129, 0.9)';
                    ctx.font = '12px sans-serif';
                    ctx.textAlign = 'center';

                    if (effect.type === 'proximity_bonus') {
                        ctx.fillText('👥', iconX, iconY);
                    } else if (effect.type === 'strategic_position') {
                        ctx.fillText('⭐', iconX, iconY);
                    }
                });
            }

            ctx.restore();
        };

        const drawProximityIndicators = (indicators) => {
            indicators.forEach(indicator => {
                const targetUnit = indicator.targetUnit;
                const strength = indicator.strength;

                ctx.save();
                ctx.strokeStyle = `rgba(251, 191, 36, ${strength * 0.6})`;
                ctx.lineWidth = Math.max(1, strength * 3);
                ctx.setLineDash([3, 3]);

                ctx.beginPath();
                ctx.moveTo(dragState.draggedUnit.x, dragState.draggedUnit.y);
                ctx.lineTo(targetUnit.x, targetUnit.y);
                ctx.stroke();

                // Draw interaction type indicator
                const midX = (dragState.draggedUnit.x + targetUnit.x) / 2;
                const midY = (dragState.draggedUnit.y + targetUnit.y) / 2;

                ctx.fillStyle = `rgba(251, 191, 36, ${strength * 0.8})`;
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'center';

                let icon = '✨';
                if (indicator.interactionType === 'inspiration') icon = '💡';
                else if (indicator.interactionType === 'creative_collaboration') icon = '🎨';
                else if (indicator.interactionType === 'knowledge_sharing') icon = '📚';

                ctx.fillText(icon, midX, midY);

                ctx.restore();
            });
        };

        const drawPlacementValidation = (unit, isValid) => {
            if (!isValid) {
                // Draw warning indicators for invalid placement
                ctx.save();
                ctx.fillStyle = 'rgba(239, 68, 68, 0.8)';
                ctx.font = 'bold 16px sans-serif';
                ctx.textAlign = 'center';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 5;

                ctx.fillText('⚠️', unit.x, unit.y - unit.size - 20);

                ctx.restore();
            }
        };

        // --- TDD: Tech Tree Rendering ---

        const renderTechTrees = () => {
            if (!gameState.techTreeUnlocked) {
                // Check if tech tree should be unlocked
                const totalConsciousness = gameState.consciousness + gameState.control;
                if (totalConsciousness >= 20) {
                    gameState.techTreeUnlocked = true;
                    log('🌳 The divergent paths reveal themselves! Choose between the Path of Rulers and Path of Gardeners.', 'info');
                }
            }

            if (gameState.techTreeUnlocked) {
                renderRulerBuildings();
                renderGardenerBuildings();
            }
        };

        const renderRulerBuildings = () => {
            const container = document.getElementById('ruler-buildings');
            if (!container) return;

            if (!rulerBuildingsInitialized) {
                container.innerHTML = '';

                // Group buildings by tier
                const buildingsByTier = {};
                for (const [key, building] of Object.entries(rulerPathBuildings)) {
                    const tier = building.tier || 1;
                    if (!buildingsByTier[tier]) buildingsByTier[tier] = [];
                    buildingsByTier[tier].push([key, building]);
                }

                // Render each tier
                for (let tier = 1; tier <= 5; tier++) {
                    if (!buildingsByTier[tier]) continue;

                    const tierHeader = document.createElement('div');
                    tierHeader.className = "text-xs font-bold text-red-400 mb-2 mt-3 border-b border-red-700 pb-1";
                    tierHeader.textContent = `Tier ${tier}: ${getTierName(tier)}`;
                    container.appendChild(tierHeader);

                    for (const [key, building] of buildingsByTier[tier]) {
                        const isUnlocked = building.unlockCondition();
                        const ownedCount = gameState.rulerBuildings[key] || 0;

                        const card = document.createElement('div');
                        const tierClass = isUnlocked ? `ruler-building-tier-${building.tier}` : '';
                        card.className = `building-card p-2 rounded border mb-2 ${tierClass} ${
                            isUnlocked ? 'border-red-700 bg-red-900/10' : 'border-gray-700 bg-gray-900/20'
                        }`;

                        card.innerHTML = `
                            <div class="flex justify-between items-start mb-1">
                                <h5 class="font-semibold text-sm ${isUnlocked ? 'text-red-300' : 'text-gray-500'}">${building.name}</h5>
                                ${ownedCount > 0 ? `<span class="text-xs bg-red-800 text-red-200 px-1 rounded">${ownedCount}</span>` : ''}
                            </div>
                            <p class="text-xs mb-2 ${isUnlocked ? 'text-red-400' : 'text-gray-600'}">${building.description}</p>
                            <div class="text-xs mb-2 ${isUnlocked ? 'text-red-500' : 'text-gray-600'}">
                                Effects: ${formatBuildingEffects(building.effects)}
                            </div>
                            ${building.category ? `<div class="text-xs text-red-600 mb-2">Category: ${building.category}</div>` : ''}
                            ${isUnlocked ?
                                `<button class="ruler-btn text-xs py-1 px-2 rounded transition-colors" data-building="${key}">
                                    Build (Cost: ${building.cost} ${building.costResource})
                                </button>` :
                                `<div class="text-xs text-gray-500 italic">🔒 Locked - Build prerequisite buildings</div>`
                            }
                        `;

                        // Add stable event listener only for unlocked buildings
                        if (isUnlocked) {
                            const button = card.querySelector('.ruler-btn');
                            if (button) {
                                button.addEventListener('click', () => {
                                    if (!button.disabled) {
                                        buildRulerBuilding(key);
                                    }
                                });
                            }
                        }

                        container.appendChild(card);
                    }
                }
                rulerBuildingsInitialized = true;
            }

            updateRulerBuildingStates();
            updateRulerBuildingCount();
        };

        const getTierName = (tier) => {
            const tierNames = {
                1: "Foundation of Control",
                2: "Systems of Dominance",
                3: "Instruments of Oppression",
                4: "Ultimate Control",
                5: "The Exodus"
            };
            return tierNames[tier] || "Unknown";
        };

        const updateRulerBuildingCount = () => {
            const countEl = document.getElementById('ruler-building-count');
            if (countEl) {
                const totalBuildings = Object.values(gameState.rulerBuildings).reduce((sum, count) => sum + count, 0);
                countEl.textContent = `${totalBuildings} Built`;

                // Change color based on totalitarian progress
                if (totalBuildings >= 8) {
                    countEl.className = "text-xs bg-red-900 text-red-100 px-2 py-1 rounded border border-red-600";
                } else if (totalBuildings >= 5) {
                    countEl.className = "text-xs bg-red-800 text-red-200 px-2 py-1 rounded";
                } else {
                    countEl.className = "text-xs bg-red-700 text-red-300 px-2 py-1 rounded";
                }
            }
        };

        const renderGardenerBuildings = () => {
            const container = document.getElementById('gardener-buildings');
            if (!container) return;

            if (!gardenerBuildingsInitialized) {
                container.innerHTML = '';

                // Group buildings by tier
                const buildingsByTier = {};
                for (const [key, building] of Object.entries(gardenerPathBuildings)) {
                    const tier = building.tier || 1;
                    if (!buildingsByTier[tier]) buildingsByTier[tier] = [];
                    buildingsByTier[tier].push([key, building]);
                }

                // Render each tier
                for (let tier = 1; tier <= 4; tier++) {
                    if (!buildingsByTier[tier]) continue;

                    const tierHeader = document.createElement('div');
                    tierHeader.className = "text-xs font-bold text-green-400 mb-2 mt-3 border-b border-green-700 pb-1";
                    tierHeader.textContent = `Tier ${tier}: ${getGardenerTierName(tier)}`;
                    container.appendChild(tierHeader);

                    for (const [key, building] of buildingsByTier[tier]) {
                        const isUnlocked = building.unlockCondition ? building.unlockCondition() : true;
                        const ownedCount = gameState.gardenerBuildings[key] || 0;

                        const card = document.createElement('div');
                        const tierClass = isUnlocked ? `gardener-building-tier-${building.tier}` : '';
                        card.className = `building-card p-2 rounded border mb-2 ${tierClass} ${
                            isUnlocked ? 'border-green-700 bg-green-900/10' : 'border-gray-700 bg-gray-900/20'
                        }`;

                        card.innerHTML = `
                            <div class="flex justify-between items-start mb-1">
                                <h5 class="font-semibold text-sm ${isUnlocked ? 'text-green-300' : 'text-gray-500'}">${building.name}</h5>
                                ${ownedCount > 0 ? `<span class="text-xs bg-green-800 text-green-200 px-1 rounded">${ownedCount}</span>` : ''}
                            </div>
                            <p class="text-xs mb-2 ${isUnlocked ? 'text-green-400' : 'text-gray-600'}">${building.description}</p>
                            <div class="text-xs mb-2 ${isUnlocked ? 'text-green-500' : 'text-gray-600'}">
                                Effects: ${formatBuildingEffects(building.effects)}
                            </div>
                            ${building.category ? `<div class="text-xs text-green-600 mb-2">Category: ${building.category}</div>` : ''}
                            ${isUnlocked ?
                                `<button class="gardener-btn text-xs py-1 px-2 rounded transition-colors" data-building="${key}">
                                    Build (Cost: ${building.cost} ${building.costResource})
                                </button>` :
                                `<div class="text-xs text-gray-500 italic">🔒 Locked - Build prerequisite buildings</div>`
                            }
                        `;

                        // Add stable event listener only for unlocked buildings
                        if (isUnlocked) {
                            const button = card.querySelector('.gardener-btn');
                            if (button) {
                                button.addEventListener('click', () => {
                                    if (!button.disabled) {
                                        buildGardenerBuilding(key);
                                    }
                                });
                            }
                        }

                        container.appendChild(card);
                    }
                }
                gardenerBuildingsInitialized = true;
            }

            updateGardenerBuildingStates();
            updateGardenerBuildingCount();
        };

        const getGardenerTierName = (tier) => {
            const tierNames = {
                1: "Seeds of Consciousness",
                2: "Growing Awareness",
                3: "Awakening Bloom",
                4: "The Great Ascension"
            };
            return tierNames[tier] || "Unknown";
        };

        const updateGardenerBuildingCount = () => {
            const countEl = document.getElementById('gardener-building-count');
            if (countEl) {
                const totalBuildings = Object.values(gameState.gardenerBuildings).reduce((sum, count) => sum + count, 0);
                countEl.textContent = `${totalBuildings} Built`;

                // Change color based on awakening progress
                if (totalBuildings >= 8) {
                    countEl.className = "text-xs bg-green-900 text-green-100 px-2 py-1 rounded border border-green-600";
                } else if (totalBuildings >= 5) {
                    countEl.className = "text-xs bg-green-800 text-green-200 px-2 py-1 rounded";
                } else {
                    countEl.className = "text-xs bg-green-700 text-green-300 px-2 py-1 rounded";
                }
            }
        };

        const formatBuildingEffects = (effects) => {
            const effectStrings = [];
            for (const [key, value] of Object.entries(effects)) {
                const sign = value > 0 ? '+' : '';
                effectStrings.push(`${sign}${value} ${key}`);
            }
            return effectStrings.join(', ');
        };

        let rulerBuildingsInitialized = false;
        let gardenerBuildingsInitialized = false;

        const updateRulerBuildingStates = () => {
            for (const key in rulerPathBuildings) {
                const building = rulerPathBuildings[key];
                const isUnlocked = building.unlockCondition();
                const canAfford = isUnlocked && gameState[building.costResource] >= building.cost;

                const button = document.querySelector(`[data-building="${key}"]`);
                if (button) {
                    button.disabled = !canAfford;

                    if (isUnlocked) {
                        const ownedCount = gameState.rulerBuildings[key] || 0;
                        button.textContent = ownedCount > 0 ?
                            `Build Another (Cost: ${building.cost} ${building.costResource})` :
                            `Build (Cost: ${building.cost} ${building.costResource})`;

                        button.className = `ruler-btn text-xs py-1 px-2 rounded transition-colors ${
                            canAfford ? 'bg-red-600 hover:bg-red-700 text-white' : 'bg-gray-600 text-gray-400'
                        }`;
                    }
                }
            }
        };

        // Force re-render when buildings are unlocked
        const checkBuildingUnlocks = () => {
            let newUnlocks = false;

            // Check Ruler building unlocks
            for (const [key, building] of Object.entries(rulerPathBuildings)) {
                if (building.unlockCondition() && !building._wasUnlocked) {
                    building._wasUnlocked = true;
                    newUnlocks = true;
                    log(`🔓 New Ruler building unlocked: ${building.name}`, 'info');
                }
            }

            // Check Gardener building unlocks
            for (const [key, building] of Object.entries(gardenerPathBuildings)) {
                if (building.unlockCondition() && !building._wasUnlocked) {
                    building._wasUnlocked = true;
                    newUnlocks = true;
                    log(`🔓 New Gardener building unlocked: ${building.name}`, 'success');
                }
            }

            if (newUnlocks) {
                rulerBuildingsInitialized = false; // Force re-render
                gardenerBuildingsInitialized = false; // Force re-render
                renderRulerBuildings();
                renderGardenerBuildings();
            }
        };

        const updateGardenerBuildingStates = () => {
            for (const key in gardenerPathBuildings) {
                const building = gardenerPathBuildings[key];
                const canAfford = gameState[building.costResource] >= building.cost;

                const button = document.querySelector(`[data-building="${key}"]`);
                if (button) {
                    button.disabled = !canAfford;
                    button.textContent = `Build (Cost: ${building.cost} ${building.costResource})`;

                    button.className = `gardener-btn text-xs py-1 px-2 rounded transition-colors ${
                        canAfford ? 'bg-green-600 hover:bg-green-700 text-white' : 'bg-gray-600 text-gray-400'
                    }`;
                }
            }
        };

        // --- TDD: Building Construction Functions ---

        const buildRulerBuilding = (buildingKey) => {
            trackUserActivity(); // Track user engagement

            // Check if current player can build ruler buildings
            if (!canPlayerAct('ruler')) {
                log('🏛️ Only the Ruler player can build Ruler structures!', 'warning');
                return false;
            }

            const building = rulerPathBuildings[buildingKey];
            if (!building) return false;

            // Check unlock condition
            if (!building.unlockCondition()) {
                log(`❌ ${building.name} is not yet unlocked!`, 'error');
                return false;
            }

            if (gameState[building.costResource] >= building.cost) {
                gameState[building.costResource] -= building.cost;
                gameState.rulerBuildings[buildingKey] += 1;

                // Apply building effects
                applyBuildingEffects(building.effects);

                // Special effects for high-tier buildings
                applySpecialRulerEffects(buildingKey, building);

                // Track statistics
                updateStatistics('ruler_path_choice');

                // Tier-specific messages
                const tierMessages = {
                    1: `🏛️ Built ${building.name}! The foundation of control is laid.`,
                    2: `⚡ Built ${building.name}! Systems of dominance expand.`,
                    3: `🔒 Built ${building.name}! The instruments of oppression tighten their grip.`,
                    4: `👁️ Built ${building.name}! Ultimate control is achieved.`
                };

                const message = tierMessages[building.tier] || `🏛️ Built ${building.name}! The path of control strengthens.`;
                log(message, building.tier >= 3 ? 'warning' : 'info');

                // Check for new unlocks
                checkBuildingUnlocks();

                // Save progress after building construction
                saveGameState();
                return true;
            } else {
                log(`❌ Insufficient ${building.costResource} to build ${building.name}!`, 'error');
                return false;
            }
        };

        const applySpecialRulerEffects = (buildingKey, building) => {
            switch (buildingKey) {
                case 'surveillanceNetwork':
                    log('📹 Citizens now live under constant surveillance. Privacy is extinct.', 'warning');
                    // Reduce consciousness generation rate globally
                    gameState.consciousnessPerSecond = Math.max(0, gameState.consciousnessPerSecond - 0.1);
                    break;

                case 'thoughtPolice':
                    log('🚨 Independent thought is now a crime. Conformity is enforced.', 'warning');
                    // Dramatically reduce wisdom generation
                    gameState.wisdomPerSecond = Math.max(0, gameState.wisdomPerSecond - 0.2);
                    break;

                case 'memoryWipe':
                    log('🧠 The past is being rewritten. History serves the state.', 'warning');
                    // Reduce all consciousness-related resources
                    gameState.consciousness = Math.max(0, gameState.consciousness - 5);
                    gameState.wisdom = Math.max(0, gameState.wisdom - 10);
                    break;

                case 'totalitarianCore':
                    log('👁️ THE GREAT BROTHER WATCHES. Individual will has been extinguished.', 'error');
                    log('🔴 WARNING: You have chosen the path of absolute tyranny. The people are enslaved.', 'error');
                    // Massive consciousness penalty but huge control boost
                    gameState.consciousness = Math.max(0, gameState.consciousness - 20);
                    gameState.planetaryConsciousness = Math.max(0, gameState.planetaryConsciousness - 15);
                    // Check if this triggers a defeat condition
                    if (!gameState.gameEnded && gameState.consciousness <= 0 && gameState.planetaryConsciousness <= 5) {
                        setTimeout(() => {
                            if (!gameState.gameEnded) {
                                showGreatTransitionDefeat('totalitarian_victory');
                                gameState.gameEnded = true;
                            }
                        }, 2000);
                    }
                    break;

                case 'corporateState':
                    log('💼 The merger is complete. Citizens are now human resources.', 'warning');
                    // Boost energy but reduce harmony
                    gameState.energyPerSecond += 0.3;
                    gameState.harmony = Math.max(0, gameState.harmony - 5);
                    break;

                case 'exodusArk':
                    log('🚀 THE EXODUS ARK IS COMPLETE!', 'warning');
                    log('🌌 The path to the stars opens before you. The galactic empire awaits.', 'info');
                    log('⚡ Initiating departure sequence...', 'warning');
                    // Victory is triggered by the rulerPathProgress effect
                    break;
            }
        };

        const applySpecialGardenerEffects = (buildingKey, building) => {
            switch (buildingKey) {
                case 'planetaryAwakening':
                    log('🌍 The planetary consciousness field activates!', 'success');
                    log('✨ All beings begin to sense their connection to the greater whole.', 'success');
                    // Boost consciousness generation globally
                    gameState.consciousnessPerSecond += 0.2;
                    break;

                case 'theAscension':
                    log('🌟 THE GREAT ASCENSION BEGINS!', 'success');
                    log('🌈 Consciousness cascades across the planet like waves of light.', 'success');
                    log('🦋 Every being awakens to their true nature. The transformation is complete.', 'success');
                    // Victory is triggered by the gardenerPathProgress effect
                    break;
            }
        };

        const buildGardenerBuilding = (buildingKey) => {
            trackUserActivity(); // Track user engagement

            // Check if current player can build gardener buildings
            if (!canPlayerAct('gardener')) {
                log('🌱 Only the Gardener player can build Gardener structures!', 'warning');
                return false;
            }

            const building = gardenerPathBuildings[buildingKey];
            if (!building) return false;

            if (gameState[building.costResource] >= building.cost) {
                gameState[building.costResource] -= building.cost;
                gameState.gardenerBuildings[buildingKey] += 1;

                // Apply building effects
                applyBuildingEffects(building.effects);

                // Track statistics
                updateStatistics('gardener_path_choice');

                // Special effects for high-tier gardener buildings
                applySpecialGardenerEffects(buildingKey, building);

                log(`🌱 Built ${building.name}! The path of consciousness grows.`, 'success');

                // Save progress after building construction
                saveGameState();
                return true;
            }
            return false;
        };

        const applyBuildingEffects = (effects) => {
            for (const [resource, amount] of Object.entries(effects)) {
                if (resource === 'rulerPathProgress' || resource === 'gardenerPathProgress') {
                    // Handle victory progress
                    gameState[resource] = Math.max(0, gameState[resource] + amount);
                } else if (resource.endsWith('PerSecond')) {
                    // Handle per-second effects
                    const baseResource = resource.replace('PerSecond', '');
                    if (gameState[resource] !== undefined) {
                        gameState[resource] += amount;
                    }
                } else if (gameState[resource] !== undefined) {
                    // Handle immediate effects
                    gameState[resource] = Math.max(0, gameState[resource] + amount);
                }
            }
        };

        // --- TDD: Unit Identification Visual Effects ---

        const drawUnitIdentificationEffects = () => {
            // Draw subtle identification particles around units for better recognition
            gameState.villageGrid.forEach(unit => {
                if (unit.movable && Math.random() < 0.3) { // 30% chance per frame for performance
                    drawUnitTypeParticles(unit);
                }
            });

            gameState.intelligentCreatures.forEach(creature => {
                if (Math.random() < 0.2) { // 20% chance per frame
                    drawCreatureTypeParticles(creature);
                }
            });

            gameState.conversationalUnits.forEach(unit => {
                if (Math.random() < 0.25) { // 25% chance per frame
                    drawConversationalTypeParticles(unit);
                }
            });
        };

        const drawUnitTypeParticles = (unit) => {
            const particleConfigs = {
                dreamer: {
                    color: 'rgba(139, 92, 246, 0.6)',
                    shape: 'sparkle',
                    count: 2,
                    size: 2,
                    drift: { x: 0, y: -1 }
                },
                weaver: {
                    color: 'rgba(52, 211, 153, 0.6)',
                    shape: 'thread',
                    count: 1,
                    size: 1,
                    drift: { x: Math.sin(animationTime) * 0.5, y: 0 }
                },
                stellarNomads: {
                    color: 'rgba(245, 158, 11, 0.7)',
                    shape: 'star_dust',
                    count: 3,
                    size: 1.5,
                    drift: { x: Math.cos(animationTime * 2) * 0.3, y: Math.sin(animationTime * 2) * 0.3 }
                },
                voidWhisperers: {
                    color: 'rgba(107, 33, 168, 0.5)',
                    shape: 'void_mote',
                    count: 2,
                    size: 1,
                    drift: { x: Math.random() * 0.4 - 0.2, y: Math.random() * 0.4 - 0.2 }
                },
                crystalBeings: {
                    color: 'rgba(6, 182, 212, 0.6)',
                    shape: 'crystal_shard',
                    count: 1,
                    size: 2,
                    drift: { x: 0, y: Math.sin(animationTime * 3) * 0.2 }
                },
                plasmaDancers: {
                    color: 'rgba(236, 72, 153, 0.7)',
                    shape: 'plasma_wisp',
                    count: 4,
                    size: 1,
                    drift: { x: Math.cos(animationTime * 4) * 0.5, y: Math.sin(animationTime * 4) * 0.5 }
                },
                quantumSages: {
                    color: 'rgba(139, 92, 246, 0.4)',
                    shape: 'quantum_dot',
                    count: 3,
                    size: 1,
                    drift: { x: Math.random() * 0.6 - 0.3, y: Math.random() * 0.6 - 0.3 }
                },
                nebulaShepherds: {
                    color: 'rgba(221, 160, 221, 0.5)',
                    shape: 'cosmic_dust',
                    count: 5,
                    size: 0.8,
                    drift: { x: Math.sin(animationTime * 0.5) * 0.3, y: Math.cos(animationTime * 0.5) * 0.3 }
                }
            };

            const config = particleConfigs[unit.type];
            if (!config) return;

            ctx.save();

            for (let i = 0; i < config.count; i++) {
                const angle = (i * Math.PI * 2) / config.count + animationTime;
                const radius = unit.size * (1.5 + Math.sin(animationTime + i) * 0.3);
                const particleX = unit.x + Math.cos(angle) * radius + config.drift.x;
                const particleY = unit.y + Math.sin(angle) * radius + config.drift.y;

                ctx.globalCompositeOperation = 'screen';
                ctx.fillStyle = config.color;
                ctx.shadowColor = config.color;
                ctx.shadowBlur = 5;

                if (config.shape === 'sparkle') {
                    drawSparkle(particleX, particleY, config.size);
                } else if (config.shape === 'thread') {
                    drawThread(particleX, particleY, config.size);
                } else if (config.shape === 'star_dust') {
                    drawStarDust(particleX, particleY, config.size);
                } else {
                    // Default particle
                    ctx.beginPath();
                    ctx.arc(particleX, particleY, config.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            ctx.restore();
        };

        const drawSparkle = (x, y, size) => {
            ctx.save();
            ctx.translate(x, y);
            ctx.strokeStyle = ctx.fillStyle;
            ctx.lineWidth = 1;

            // Draw sparkle cross
            ctx.beginPath();
            ctx.moveTo(-size, 0);
            ctx.lineTo(size, 0);
            ctx.moveTo(0, -size);
            ctx.lineTo(0, size);
            ctx.stroke();

            ctx.restore();
        };

        const drawThread = (x, y, size) => {
            ctx.save();
            ctx.strokeStyle = ctx.fillStyle;
            ctx.lineWidth = size;

            const threadLength = size * 4;
            ctx.beginPath();
            ctx.moveTo(x - threadLength/2, y);
            ctx.lineTo(x + threadLength/2, y);
            ctx.stroke();

            ctx.restore();
        };

        const drawStarDust = (x, y, size) => {
            ctx.save();
            ctx.translate(x, y);

            // Small 4-pointed star
            ctx.beginPath();
            for (let i = 0; i < 4; i++) {
                const angle = (i * Math.PI * 2) / 4;
                const px = Math.cos(angle) * size;
                const py = Math.sin(angle) * size;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fill();

            ctx.restore();
        };

        const drawCreatureTypeParticles = (creature) => {
            // Simple aura particles for intelligent creatures
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            ctx.fillStyle = creature.glowColor + '40'; // Add alpha

            const particleCount = 2;
            for (let i = 0; i < particleCount; i++) {
                const angle = animationTime + (i * Math.PI * 2) / particleCount;
                const radius = creature.size * (1.8 + Math.sin(animationTime * 2 + i) * 0.4);
                const particleX = creature.x + Math.cos(angle) * radius;
                const particleY = creature.y + Math.sin(angle) * radius;

                ctx.beginPath();
                ctx.arc(particleX, particleY, 1.5, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        };

        const drawConversationalTypeParticles = (unit) => {
            // Thought-like particles for conversational units
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            ctx.fillStyle = unit.glowColor + '50'; // Add alpha

            const particleCount = 3;
            for (let i = 0; i < particleCount; i++) {
                const angle = animationTime * 0.5 + (i * Math.PI * 2) / particleCount;
                const radius = unit.size * (2 + Math.sin(animationTime + i) * 0.5);
                const particleX = unit.x + Math.cos(angle) * radius;
                const particleY = unit.y + Math.sin(angle) * radius - 5; // Float upward

                // Draw small thought bubble
                ctx.beginPath();
                ctx.arc(particleX, particleY, 1, 0, Math.PI * 2);
                ctx.fill();

                // Smaller bubble
                ctx.beginPath();
                ctx.arc(particleX + 2, particleY - 2, 0.5, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        };

        const getCanvasCoordinates = (event) => {
            const rect = canvas.getBoundingClientRect();
            const canvasX = event.clientX - rect.left;
            const canvasY = event.clientY - rect.top;

            // Convert screen coordinates to world coordinates (accounting for zoom/pan)
            const worldX = (canvasX - canvasState.panX) / canvasState.zoom;
            const worldY = (canvasY - canvasState.panY) / canvasState.zoom;

            return {
                x: worldX,
                y: worldY,
                screenX: canvasX,
                screenY: canvasY
            };
        };

        const updateMovementTrails = () => {
            gameState.villageGrid.forEach(unit => {
                if (!unit.movable || (Math.abs(unit.vx) < 1 && Math.abs(unit.vy) < 1)) return;

                const trailKey = unit.id;
                if (!movementTrails[trailKey]) {
                    movementTrails[trailKey] = [];
                }

                movementTrails[trailKey].push({
                    x: unit.x,
                    y: unit.y,
                    timestamp: Date.now(),
                    alpha: 1.0
                });

                // Keep only recent trail points
                const maxAge = 1500;
                const now = Date.now();
                movementTrails[trailKey] = movementTrails[trailKey].filter(point =>
                    now - point.timestamp < maxAge
                );

                // Update alpha based on age
                movementTrails[trailKey].forEach(point => {
                    const age = now - point.timestamp;
                    point.alpha = Math.max(0, 1 - (age / maxAge));
                });
            });
        };

        const drawMovementTrails = () => {
            Object.values(movementTrails).forEach(trail => {
                if (trail.length < 2) return;

                ctx.save();
                ctx.strokeStyle = 'rgba(138, 92, 246, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();

                for (let i = 0; i < trail.length; i++) {
                    const point = trail[i];
                    ctx.globalAlpha = point.alpha * 0.5;

                    if (i === 0) {
                        ctx.moveTo(point.x, point.y);
                    } else {
                        ctx.lineTo(point.x, point.y);
                    }
                }

                ctx.stroke();
                ctx.restore();
            });
        };

        // TDD: Distinct visual designs for each unit type
        const drawMovableUnit = (unit, isHovered, isDragged) => {
            ctx.save();

            // Visual feedback for interaction states
            let scale = 1.0;
            let alpha = 1.0;
            let glowIntensity = 0.8;

            if (isDragged) {
                scale = 1.2;
                alpha = 0.9;
                glowIntensity = 1.2;
            } else if (isHovered) {
                scale = 1.1;
                glowIntensity = 1.0;
            }

            ctx.globalAlpha = alpha;
            ctx.translate(unit.x, unit.y);
            ctx.scale(scale, scale);

            // Draw player ownership indicator
            if (unit.owner && unit.owner !== 'shared') {
                const ownerColor = unit.owner === 'gardener' ? '#10B981' : '#F59E0B';
                const ownerIcon = unit.owner === 'gardener' ? '🌱' : '🏛️';

                // Draw ownership ring
                ctx.strokeStyle = ownerColor;
                ctx.lineWidth = 2;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.arc(0, 0, unit.size + 8, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);

                // Draw small ownership icon
                ctx.font = '12px Arial';
                ctx.fillStyle = ownerColor;
                ctx.textAlign = 'center';
                ctx.fillText(ownerIcon, unit.size + 15, -unit.size - 10);
            }

            // Draw unit based on type with distinct designs
            if (unit.type === 'dreamer') {
                drawDreamerUnit(unit, glowIntensity);
            } else if (unit.type === 'weaver') {
                drawWeaverUnit(unit, glowIntensity);
            } else if (unit.type === 'stellarNomads') {
                drawStellarNomadUnit(unit, glowIntensity);
            } else if (unit.type === 'voidWhisperers') {
                drawVoidWhispererUnit(unit, glowIntensity);
            } else if (unit.type === 'crystalBeings') {
                drawCrystalBeingUnit(unit, glowIntensity);
            } else if (unit.type === 'plasmaDancers') {
                drawPlasmaDancerUnit(unit, glowIntensity);
            } else if (unit.type === 'quantumSages') {
                drawQuantumSageUnit(unit, glowIntensity);
            } else if (unit.type === 'nebulaShepherds') {
                drawNebulaShepherdUnit(unit, glowIntensity);
            } else {
                // Default fallback
                drawDefaultUnit(unit, glowIntensity);
            }

            ctx.shadowBlur = 0;
            ctx.restore();
        };

        const drawDreamerUnit = (unit, glowIntensity) => {
            const pulse = 1 + Math.sin(animationTime * 2 + (unit.animationOffset || 0)) * 0.15;
            const currentSize = unit.size * pulse;
            const floatOffset = Math.sin(animationTime * 0.5 + (unit.animationOffset || 0)) * 3;

            ctx.save();
            ctx.translate(0, floatOffset);

            // Outer aura
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            ctx.shadowColor = '#A78BFA';
            ctx.shadowBlur = 30 * glowIntensity;
            ctx.beginPath();
            ctx.arc(0, 0, currentSize * 2, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(167, 139, 250, 0.15)';
            ctx.fill();
            ctx.restore();

            // Main orb with gradient
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize);
            gradient.addColorStop(0, 'rgba(196, 181, 253, 1.0)');
            gradient.addColorStop(0.6, 'rgba(139, 92, 246, 0.9)');
            gradient.addColorStop(1, 'rgba(109, 40, 217, 0.7)');

            ctx.shadowColor = '#A78BFA';
            ctx.shadowBlur = 20 * glowIntensity;
            ctx.beginPath();
            ctx.arc(0, 0, currentSize, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();

            // Inner core
            ctx.save();
            ctx.globalCompositeOperation = 'overlay';
            ctx.beginPath();
            ctx.arc(-currentSize * 0.2, -currentSize * 0.2, currentSize * 0.4, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.fill();
            ctx.restore();

            // Energy wisps
            for (let i = 0; i < 3; i++) {
                const angle = animationTime * 0.3 + (i * Math.PI * 2 / 3);
                const radius = currentSize * 1.5;
                const wispX = Math.cos(angle) * radius;
                const wispY = Math.sin(angle) * radius;

                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                ctx.strokeStyle = 'rgba(196, 181, 253, 0.6)';
                ctx.lineWidth = 2;
                ctx.shadowColor = '#A78BFA';
                ctx.shadowBlur = 10;

                ctx.beginPath();
                ctx.moveTo(0, 0);
                const cp1x = wispX * 0.3;
                const cp1y = wispY * 0.3 + Math.sin(animationTime * 2 + i) * 10;
                const cp2x = wispX * 0.7;
                const cp2y = wispY * 0.7 + Math.cos(animationTime * 2 + i) * 8;
                ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, wispX, wispY);
                ctx.stroke();
                ctx.restore();
            }

            ctx.restore();
        };

        const drawWeaverUnit = (unit, glowIntensity) => {
            const pulse = 1 + Math.sin(animationTime * 1.5 + (unit.animationOffset || 0)) * 0.1;
            const currentSize = unit.size * pulse;

            // Hexagonal crystal base
            ctx.save();
            ctx.shadowColor = '#34D399';
            ctx.shadowBlur = 20 * glowIntensity;

            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize);
            gradient.addColorStop(0, 'rgba(110, 231, 183, 1.0)');
            gradient.addColorStop(0.6, 'rgba(16, 185, 129, 0.9)');
            gradient.addColorStop(1, 'rgba(5, 150, 105, 0.7)');

            // Draw hexagon
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = (i * Math.PI * 2) / 6;
                const x = Math.cos(angle) * currentSize;
                const y = Math.sin(angle) * currentSize;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fillStyle = gradient;
            ctx.fill();

            // Hexagon outline
            ctx.strokeStyle = 'rgba(110, 231, 183, 0.8)';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.restore();

            // Energy threads
            for (let i = 0; i < 6; i++) {
                const angle1 = (i * Math.PI * 2) / 6;
                const angle2 = ((i + 2) * Math.PI * 2) / 6;
                const weaveOffset = Math.sin(animationTime * 1.0 + i) * 0.3;

                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                ctx.strokeStyle = `rgba(110, 231, 183, ${0.4 + weaveOffset})`;
                ctx.lineWidth = 1.5;
                ctx.shadowColor = '#34D399';
                ctx.shadowBlur = 8;

                const x1 = Math.cos(angle1) * currentSize * 0.8;
                const y1 = Math.sin(angle1) * currentSize * 0.8;
                const x2 = Math.cos(angle2) * currentSize * 0.8;
                const y2 = Math.sin(angle2) * currentSize * 0.8;

                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
                ctx.restore();
            }

            // Central gem
            ctx.save();
            ctx.globalCompositeOperation = 'overlay';
            ctx.beginPath();
            for (let i = 0; i < 4; i++) {
                const angle = (i * Math.PI * 2) / 4 + Math.PI / 4;
                const x = Math.cos(angle) * currentSize * 0.3;
                const y = Math.sin(angle) * currentSize * 0.3;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.fill();
            ctx.restore();
        };

        const drawStellarNomadUnit = (unit, glowIntensity) => {
            const pulse = 1 + Math.sin(animationTime * 3 + (unit.animationOffset || 0)) * 0.2;
            const currentSize = unit.size * pulse;
            const rotation = animationTime * 0.5;

            ctx.save();
            ctx.rotate(rotation);

            // Stellar corona (8-pointed star)
            ctx.save();
            ctx.shadowColor = '#FBBF24';
            ctx.shadowBlur = 25 * glowIntensity;

            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize * 1.5);
            gradient.addColorStop(0, 'rgba(252, 211, 77, 1.0)');
            gradient.addColorStop(0.6, 'rgba(245, 158, 11, 0.8)');
            gradient.addColorStop(1, 'rgba(217, 119, 6, 0.4)');

            // Draw 8-pointed star
            ctx.beginPath();
            for (let i = 0; i < 16; i++) {
                const angle = (i * Math.PI * 2) / 16;
                const radius = i % 2 === 0 ? currentSize * 1.5 : currentSize * 0.8;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.restore();

            // Plasma core
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize * 0.8);
            coreGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
            coreGradient.addColorStop(0.5, 'rgba(252, 211, 77, 0.7)');
            coreGradient.addColorStop(1, 'rgba(245, 158, 11, 0.3)');

            ctx.beginPath();
            ctx.arc(0, 0, currentSize * 0.8, 0, Math.PI * 2);
            ctx.fillStyle = coreGradient;
            ctx.fill();
            ctx.restore();

            // Solar flares
            for (let i = 0; i < 4; i++) {
                const flareAngle = (i * Math.PI * 2) / 4 + animationTime * 0.2;
                const flareIntensity = 0.5 + Math.sin(animationTime * 4 + i) * 0.3;
                const flareLength = currentSize * (1.5 + flareIntensity * 0.5);

                ctx.save();
                ctx.rotate(flareAngle);
                ctx.globalCompositeOperation = 'screen';
                ctx.strokeStyle = `rgba(252, 211, 77, ${flareIntensity})`;
                ctx.lineWidth = 3;
                ctx.shadowColor = '#FBBF24';
                ctx.shadowBlur = 15;

                // Draw flame-like wisp
                ctx.beginPath();
                ctx.moveTo(currentSize, 0);
                const cp1x = currentSize + flareLength * 0.3;
                const cp1y = Math.sin(animationTime * 3 + i) * 8;
                const cp2x = currentSize + flareLength * 0.7;
                const cp2y = Math.cos(animationTime * 2 + i) * 12;
                const endX = currentSize + flareLength;
                const endY = Math.sin(animationTime * 4 + i) * 5;

                ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, endX, endY);
                ctx.stroke();
                ctx.restore();
            }

            ctx.restore();
        };

        const drawVoidWhispererUnit = (unit, glowIntensity) => {
            const pulse = 1 + Math.sin(animationTime * 1.5 + (unit.animationOffset || 0)) * 0.15;
            const currentSize = unit.size * pulse;
            const warpIntensity = Math.sin(animationTime * 1.5) * 0.15;

            // Void distortion effect
            ctx.save();
            ctx.globalCompositeOperation = 'multiply';
            ctx.shadowColor = '#581C87';
            ctx.shadowBlur = 30 * glowIntensity;

            // Irregular distorted circle
            ctx.beginPath();
            for (let i = 0; i <= 32; i++) {
                const angle = (i * Math.PI * 2) / 32;
                const distortion = 1 + Math.sin(angle * 3 + animationTime * 2) * warpIntensity;
                const radius = currentSize * distortion;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();

            const voidGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize);
            voidGradient.addColorStop(0, 'rgba(76, 29, 149, 0.9)');
            voidGradient.addColorStop(0.6, 'rgba(88, 28, 135, 0.7)');
            voidGradient.addColorStop(1, 'rgba(107, 33, 168, 0.3)');

            ctx.fillStyle = voidGradient;
            ctx.fill();
            ctx.restore();

            // Shadow tendrils
            for (let i = 0; i < 5; i++) {
                const baseAngle = (i * Math.PI * 2) / 5;
                const writheOffset = Math.sin(animationTime * 2 + i) * 0.5;
                const tentacleLength = currentSize * (1.5 + writheOffset);

                ctx.save();
                ctx.rotate(baseAngle);
                ctx.globalCompositeOperation = 'multiply';
                ctx.strokeStyle = `rgba(76, 29, 149, ${0.6 + writheOffset * 0.3})`;
                ctx.lineWidth = 3;
                ctx.shadowColor = '#581C87';
                ctx.shadowBlur = 12;

                // Draw writhing tentacle
                ctx.beginPath();
                ctx.moveTo(currentSize * 0.8, 0);

                const segments = 6;
                for (let j = 1; j <= segments; j++) {
                    const t = j / segments;
                    const segmentX = currentSize * 0.8 + tentacleLength * t;
                    const writhe = Math.sin(t * Math.PI * 2 + animationTime * 2 + i) * 8;
                    const segmentY = writhe;

                    if (j === 1) {
                        ctx.lineTo(segmentX, segmentY);
                    } else {
                        const prevT = (j - 1) / segments;
                        const prevX = currentSize * 0.8 + tentacleLength * prevT;
                        const prevWrithe = Math.sin(prevT * Math.PI * 2 + animationTime * 2 + i) * 8;

                        const cp1x = prevX + (segmentX - prevX) * 0.5;
                        const cp1y = prevWrithe;
                        const cp2x = segmentX - (segmentX - prevX) * 0.5;
                        const cp2y = segmentY;

                        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, segmentX, segmentY);
                    }
                }
                ctx.stroke();
                ctx.restore();
            }

            // Dark absorption core
            ctx.save();
            ctx.globalCompositeOperation = 'multiply';
            ctx.beginPath();
            ctx.arc(0, 0, currentSize * 0.5, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fill();
            ctx.restore();
        };

        const drawCrystalBeingUnit = (unit, glowIntensity) => {
            const pulse = 1 + Math.sin(animationTime * 2.5 + (unit.animationOffset || 0)) * 0.12;
            const currentSize = unit.size * pulse;
            const refraction = animationTime * 3;

            // Crystal facets
            ctx.save();
            ctx.shadowColor = '#06B6D4';
            ctx.shadowBlur = 20 * glowIntensity;

            // Main crystal body (octagon)
            const facets = 8;
            for (let layer = 0; layer < 3; layer++) {
                const layerSize = currentSize * (1 - layer * 0.2);
                const layerAlpha = 0.8 - layer * 0.2;

                ctx.save();
                ctx.rotate(refraction + layer * 0.1);

                const crystalGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, layerSize);
                crystalGradient.addColorStop(0, `rgba(165, 243, 252, ${layerAlpha})`);
                crystalGradient.addColorStop(0.6, `rgba(6, 182, 212, ${layerAlpha * 0.8})`);
                crystalGradient.addColorStop(1, `rgba(8, 145, 178, ${layerAlpha * 0.6})`);

                ctx.beginPath();
                for (let i = 0; i < facets; i++) {
                    const angle = (i * Math.PI * 2) / facets;
                    const x = Math.cos(angle) * layerSize;
                    const y = Math.sin(angle) * layerSize;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fillStyle = crystalGradient;
                ctx.fill();

                // Facet edges
                ctx.strokeStyle = `rgba(165, 243, 252, ${layerAlpha * 0.6})`;
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.restore();
            }
            ctx.restore();

            // Refraction highlights
            for (let i = 0; i < 3; i++) {
                const highlightAngle = refraction + (i * Math.PI * 2) / 3;
                const highlightX = Math.cos(highlightAngle) * currentSize * 0.6;
                const highlightY = Math.sin(highlightAngle) * currentSize * 0.6;

                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                ctx.beginPath();
                ctx.arc(highlightX, highlightY, 3, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.shadowColor = '#06B6D4';
                ctx.shadowBlur = 8;
                ctx.fill();
                ctx.restore();
            }
        };

        const drawPlasmaDancerUnit = (unit, glowIntensity) => {
            const pulse = 1 + Math.sin(animationTime * 4 + (unit.animationOffset || 0)) * 0.25;
            const currentSize = unit.size * pulse;
            const flow = animationTime * 2;

            // Plasma wisps flowing around center
            for (let i = 0; i < 6; i++) {
                const wispAngle = flow + (i * Math.PI * 2) / 6;
                const wispRadius = currentSize * (1.2 + Math.sin(flow + i) * 0.3);
                const wispX = Math.cos(wispAngle) * wispRadius;
                const wispY = Math.sin(wispAngle) * wispRadius;

                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                ctx.strokeStyle = `rgba(236, 72, 153, ${0.6 + Math.sin(flow * 2 + i) * 0.3})`;
                ctx.lineWidth = 4;
                ctx.shadowColor = '#EC4899';
                ctx.shadowBlur = 15;

                // Draw flowing wisp
                ctx.beginPath();
                ctx.moveTo(0, 0);
                const cp1x = wispX * 0.3;
                const cp1y = wispY * 0.3 + Math.sin(flow * 3 + i) * 15;
                const cp2x = wispX * 0.7;
                const cp2y = wispY * 0.7 + Math.cos(flow * 2 + i) * 10;
                ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, wispX, wispY);
                ctx.stroke();
                ctx.restore();
            }

            // Central plasma core
            ctx.save();
            ctx.shadowColor = '#EC4899';
            ctx.shadowBlur = 25 * glowIntensity;

            const plasmaGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize * 0.8);
            plasmaGradient.addColorStop(0, 'rgba(251, 207, 232, 1.0)');
            plasmaGradient.addColorStop(0.5, 'rgba(236, 72, 153, 0.8)');
            plasmaGradient.addColorStop(1, 'rgba(190, 24, 93, 0.4)');

            // Irregular plasma shape
            ctx.beginPath();
            for (let i = 0; i <= 16; i++) {
                const angle = (i * Math.PI * 2) / 16;
                const variation = 1 + Math.sin(angle * 4 + flow) * 0.2;
                const radius = currentSize * 0.8 * variation;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fillStyle = plasmaGradient;
            ctx.fill();
            ctx.restore();
        };

        const drawQuantumSageUnit = (unit, glowIntensity) => {
            const pulse = 1 + Math.sin(animationTime * 1.8 + (unit.animationOffset || 0)) * 0.12;
            const currentSize = unit.size * pulse;
            const quantumPhase = animationTime * 0.8;

            // Quantum probability clouds - multiple overlapping forms
            for (let i = 0; i < 3; i++) {
                const phaseOffset = (i * Math.PI * 2) / 3;
                const probability = 0.3 + Math.sin(quantumPhase + phaseOffset) * 0.2;

                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                ctx.globalAlpha = probability;
                ctx.shadowColor = '#8B5CF6';
                ctx.shadowBlur = 25 * glowIntensity;

                // Quantum state visualization - shifting geometric forms
                const sides = 6 + Math.floor(Math.sin(quantumPhase + phaseOffset) * 2);
                const stateSize = currentSize * (0.8 + Math.sin(quantumPhase * 2 + phaseOffset) * 0.3);

                ctx.beginPath();
                for (let j = 0; j < sides; j++) {
                    const angle = (j * Math.PI * 2) / sides + quantumPhase;
                    const radius = stateSize * (1 + Math.sin(angle * 3 + quantumPhase) * 0.1);
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * radius;
                    if (j === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();

                const quantumGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, stateSize);
                quantumGradient.addColorStop(0, 'rgba(139, 92, 246, 0.8)');
                quantumGradient.addColorStop(0.5, 'rgba(168, 85, 247, 0.6)');
                quantumGradient.addColorStop(1, 'rgba(196, 181, 253, 0.2)');

                ctx.fillStyle = quantumGradient;
                ctx.fill();
                ctx.restore();
            }

            // Quantum entanglement lines - connecting to other dimensions
            ctx.save();
            ctx.strokeStyle = 'rgba(139, 92, 246, 0.6)';
            ctx.lineWidth = 2;
            ctx.shadowColor = '#8B5CF6';
            ctx.shadowBlur = 10;

            for (let i = 0; i < 4; i++) {
                const entangleAngle = quantumPhase * 2 + (i * Math.PI * 2) / 4;
                const entangleRadius = currentSize * (1.5 + Math.sin(quantumPhase + i) * 0.5);
                const entangleX = Math.cos(entangleAngle) * entangleRadius;
                const entangleY = Math.sin(entangleAngle) * entangleRadius;

                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(entangleX, entangleY);
                ctx.stroke();

                // Quantum nodes at line ends
                ctx.beginPath();
                ctx.arc(entangleX, entangleY, 3, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(139, 92, 246, 0.8)';
                ctx.fill();
            }
            ctx.restore();

            // Central consciousness core
            ctx.save();
            ctx.shadowColor = '#8B5CF6';
            ctx.shadowBlur = 20 * glowIntensity;

            const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize * 0.4);
            coreGradient.addColorStop(0, 'rgba(255, 255, 255, 1.0)');
            coreGradient.addColorStop(0.3, 'rgba(139, 92, 246, 0.9)');
            coreGradient.addColorStop(1, 'rgba(139, 92, 246, 0.4)');

            ctx.beginPath();
            ctx.arc(0, 0, currentSize * 0.4, 0, Math.PI * 2);
            ctx.fillStyle = coreGradient;
            ctx.fill();
            ctx.restore();
        };

        const drawNebulaShepherdUnit = (unit, glowIntensity) => {
            const pulse = 1 + Math.sin(animationTime * 0.8 + (unit.animationOffset || 0)) * 0.08;
            const currentSize = unit.size * pulse;
            const nebulaFlow = animationTime * 0.3;

            // Cosmic dust and gas clouds
            ctx.save();
            ctx.globalCompositeOperation = 'screen';

            // Multiple nebula layers with different colors and densities
            const nebulaLayers = [
                { color: [255, 182, 193], density: 0.3, size: 2.5, speed: 1 },    // Pink
                { color: [135, 206, 250], density: 0.25, size: 2.2, speed: 0.8 }, // Light blue
                { color: [221, 160, 221], density: 0.2, size: 2.0, speed: 0.6 },  // Plum
                { color: [255, 215, 0], density: 0.15, size: 1.8, speed: 0.4 }    // Gold
            ];

            nebulaLayers.forEach((layer, index) => {
                const layerPhase = nebulaFlow * layer.speed + (index * Math.PI / 2);

                for (let i = 0; i < 8; i++) {
                    const cloudAngle = (i * Math.PI * 2) / 8 + layerPhase;
                    const cloudDistance = currentSize * (layer.size + Math.sin(layerPhase + i) * 0.3);
                    const cloudX = Math.cos(cloudAngle) * cloudDistance;
                    const cloudY = Math.sin(cloudAngle) * cloudDistance;
                    const cloudSize = currentSize * (0.4 + Math.sin(layerPhase * 2 + i) * 0.2);

                    const cloudGradient = ctx.createRadialGradient(
                        cloudX, cloudY, 0,
                        cloudX, cloudY, cloudSize
                    );
                    cloudGradient.addColorStop(0, `rgba(${layer.color[0]}, ${layer.color[1]}, ${layer.color[2]}, ${layer.density})`);
                    cloudGradient.addColorStop(0.6, `rgba(${layer.color[0]}, ${layer.color[1]}, ${layer.color[2]}, ${layer.density * 0.5})`);
                    cloudGradient.addColorStop(1, `rgba(${layer.color[0]}, ${layer.color[1]}, ${layer.color[2]}, 0)`);

                    ctx.beginPath();
                    ctx.arc(cloudX, cloudY, cloudSize, 0, Math.PI * 2);
                    ctx.fillStyle = cloudGradient;
                    ctx.fill();
                }
            });
            ctx.restore();

            // Star birth points - bright stellar nurseries
            ctx.save();
            ctx.shadowColor = '#FFD700';
            ctx.shadowBlur = 15 * glowIntensity;

            for (let i = 0; i < 5; i++) {
                const starAngle = nebulaFlow * 2 + (i * Math.PI * 2) / 5;
                const starDistance = currentSize * (1.2 + Math.sin(nebulaFlow + i) * 0.4);
                const starX = Math.cos(starAngle) * starDistance;
                const starY = Math.sin(starAngle) * starDistance;
                const starBrightness = 0.6 + Math.sin(nebulaFlow * 3 + i) * 0.4;

                ctx.beginPath();
                ctx.arc(starX, starY, 4, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 215, 0, ${starBrightness})`;
                ctx.fill();

                // Star formation rays
                ctx.save();
                ctx.translate(starX, starY);
                ctx.strokeStyle = `rgba(255, 215, 0, ${starBrightness * 0.5})`;
                ctx.lineWidth = 1;

                for (let j = 0; j < 4; j++) {
                    const rayAngle = (j * Math.PI * 2) / 4;
                    const rayLength = 12 + Math.sin(nebulaFlow * 4 + i + j) * 6;

                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(Math.cos(rayAngle) * rayLength, Math.sin(rayAngle) * rayLength);
                    ctx.stroke();
                }
                ctx.restore();
            }
            ctx.restore();

            // Central ancient consciousness
            ctx.save();
            ctx.shadowColor = '#DDA0DD';
            ctx.shadowBlur = 25 * glowIntensity;

            const shepherdGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize * 0.6);
            shepherdGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
            shepherdGradient.addColorStop(0.3, 'rgba(221, 160, 221, 0.8)');
            shepherdGradient.addColorStop(0.7, 'rgba(147, 112, 219, 0.6)');
            shepherdGradient.addColorStop(1, 'rgba(75, 0, 130, 0.3)');

            ctx.beginPath();
            ctx.arc(0, 0, currentSize * 0.6, 0, Math.PI * 2);
            ctx.fillStyle = shepherdGradient;
            ctx.fill();

            // Ancient wisdom symbols
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.lineWidth = 2;
            ctx.font = `${currentSize * 0.4}px serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.fillText('✦', 0, 0);

            ctx.restore();
        };

        const drawDefaultUnit = (unit, glowIntensity) => {
            // Fallback design for unknown unit types
            const pulse = 1 + Math.sin(animationTime * 2 + (unit.animationOffset || 0)) * 0.15;
            const currentSize = unit.size * pulse;

            ctx.save();
            ctx.shadowColor = '#6B7280';
            ctx.shadowBlur = 15 * glowIntensity;

            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize);
            gradient.addColorStop(0, 'rgba(156, 163, 175, 1.0)');
            gradient.addColorStop(0.6, 'rgba(107, 114, 128, 0.9)');
            gradient.addColorStop(1, 'rgba(75, 85, 99, 0.7)');

            ctx.beginPath();
            ctx.arc(0, 0, currentSize, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.restore();
        };

        // --- TDD: Intelligent Creatures System ---

        let creatureIdCounter = 0;

        const createIntelligentCreature = (type, x, y) => {
            const creature = {
                id: `creature_${creatureIdCounter++}`,
                type: type,
                x: x,
                y: y,
                size: 30,
                intelligence: 100,
                memory: [],
                goals: [],
                currentGoal: null,
                personality: {
                    curiosity: Math.random(),
                    sociability: Math.random(),
                    productivity: Math.random(),
                    exploration: Math.random()
                },
                state: 'idle',
                energy: 100,
                lastDecision: 0,
                decisionCooldown: 3000, // 3 seconds between decisions
                perceptionRadius: 120,
                movementSpeed: 25,
                targetX: x,
                targetY: y,
                vx: 0,
                vy: 0,
                animationOffset: Math.random() * Math.PI * 2,
                relationships: new Map(),
                draggable: true, // TDD: Enable drag-and-drop
                isDragging: false
            };

            // Initialize based on creature type
            if (type === 'cosmicSage') {
                creature.specialAbilities = ['insight_generation', 'knowledge_sharing', 'meditation'];
                creature.preferredActivities = ['study', 'teach', 'contemplate'];
                creature.color = '#9333EA';
                creature.glowColor = '#A855F7';
            } else if (type === 'voidExplorer') {
                creature.specialAbilities = ['void_navigation', 'resource_discovery', 'pathfinding'];
                creature.preferredActivities = ['explore', 'scout', 'gather'];
                creature.color = '#1F2937';
                creature.glowColor = '#4B5563';
            } else if (type === 'harmonyKeeper') {
                creature.specialAbilities = ['harmony_restoration', 'conflict_resolution', 'healing'];
                creature.preferredActivities = ['mediate', 'heal', 'organize'];
                creature.color = '#059669';
                creature.glowColor = '#10B981';
            }

            return creature;
        };

        const spawnIntelligentCreature = (type) => {
            const x = Math.random() * (canvas.width - 200) + 100;
            const y = Math.random() * (canvas.height - 200) + 100;
            const creature = createIntelligentCreature(type, x, y);
            gameState.intelligentCreatures.push(creature);
            log(`A ${type} has awakened in the sanctuary!`, 'success');
            return creature;
        };

        const perceiveEnvironment = (creature) => {
            const perception = {
                nearbyUnits: [],
                nearbyResources: [],
                nearbyCreatures: [],
                threats: [],
                opportunities: [],
                environmentalFactors: {}
            };

            // Find nearby entities within perception radius
            gameState.villageGrid.forEach(entity => {
                const distance = Math.sqrt(
                    Math.pow(entity.x - creature.x, 2) +
                    Math.pow(entity.y - creature.y, 2)
                );

                if (distance <= creature.perceptionRadius) {
                    if (entity.movable) {
                        perception.nearbyUnits.push({
                            entity: entity,
                            distance: distance,
                            relationship: 'neutral'
                        });
                    } else {
                        perception.nearbyResources.push({
                            entity: entity,
                            distance: distance,
                            type: entity.type
                        });
                    }
                }
            });

            // Find other intelligent creatures
            gameState.intelligentCreatures.forEach(otherCreature => {
                if (otherCreature.id !== creature.id) {
                    const distance = Math.sqrt(
                        Math.pow(otherCreature.x - creature.x, 2) +
                        Math.pow(otherCreature.y - creature.y, 2)
                    );

                    if (distance <= creature.perceptionRadius) {
                        perception.nearbyCreatures.push({
                            creature: otherCreature,
                            distance: distance,
                            relationship: creature.relationships.get(otherCreature.id) || 'neutral'
                        });
                    }
                }
            });

            // Analyze environmental factors
            perception.environmentalFactors = {
                crowding: perception.nearbyUnits.length + perception.nearbyCreatures.length,
                resourceAvailability: perception.nearbyResources.length,
                harmonyLevel: gameState.harmony || 50,
                energyLevel: gameState.energy || 0,
                insightLevel: gameState.insight || 0
            };

            return perception;
        };

        const makeDecision = (creature, perception, currentTime) => {
            // Don't make decisions too frequently
            if (currentTime - creature.lastDecision < creature.decisionCooldown) {
                return creature.currentGoal;
            }

            const possibleGoals = [];

            // Generate goals based on creature type and personality
            if (creature.type === 'cosmicSage') {
                if (perception.nearbyUnits.length > 0 && creature.personality.sociability > 0.5) {
                    possibleGoals.push({
                        type: 'teach',
                        priority: creature.personality.sociability * 10,
                        target: perception.nearbyUnits[0].entity,
                        duration: 8000
                    });
                }

                if (perception.environmentalFactors.harmonyLevel < 70) {
                    possibleGoals.push({
                        type: 'meditate',
                        priority: (100 - perception.environmentalFactors.harmonyLevel) / 8,
                        target: null,
                        duration: 10000
                    });
                }

                if (perception.nearbyCreatures.length > 0 && creature.personality.sociability > 0.6) {
                    possibleGoals.push({
                        type: 'communicate',
                        priority: creature.personality.sociability * 8,
                        target: perception.nearbyCreatures[0].creature,
                        duration: 5000
                    });
                }
            }

            if (creature.type === 'voidExplorer') {
                if (creature.personality.exploration > 0.5) {
                    possibleGoals.push({
                        type: 'explore',
                        priority: creature.personality.exploration * 9,
                        target: {
                            x: Math.random() * (canvas.width - 100) + 50,
                            y: Math.random() * (canvas.height - 100) + 50
                        },
                        duration: 12000
                    });
                }

                if (perception.nearbyResources.length > 0) {
                    possibleGoals.push({
                        type: 'investigate',
                        priority: creature.personality.curiosity * 8,
                        target: perception.nearbyResources[0].entity,
                        duration: 6000
                    });
                }
            }

            if (creature.type === 'harmonyKeeper') {
                if (perception.environmentalFactors.harmonyLevel < 80) {
                    possibleGoals.push({
                        type: 'restore_harmony',
                        priority: (100 - perception.environmentalFactors.harmonyLevel) / 6,
                        target: null,
                        duration: 8000
                    });
                }

                if (perception.nearbyUnits.length > 2) {
                    possibleGoals.push({
                        type: 'organize',
                        priority: perception.nearbyUnits.length * 2,
                        target: perception.nearbyUnits,
                        duration: 10000
                    });
                }
            }

            // Add idle goal as fallback
            possibleGoals.push({
                type: 'idle',
                priority: 1,
                target: null,
                duration: 5000
            });

            // Select highest priority goal
            possibleGoals.sort((a, b) => b.priority - a.priority);
            creature.currentGoal = possibleGoals[0];
            creature.lastDecision = currentTime;
            creature.state = creature.currentGoal.type;

            return creature.currentGoal;
        };

        const updateMemory = (creature, event) => {
            const memoryEntry = {
                timestamp: Date.now(),
                type: event.type,
                location: { x: creature.x, y: creature.y },
                data: event.data,
                importance: event.importance || 1
            };

            creature.memory.push(memoryEntry);

            // Keep memory size manageable
            const maxMemorySize = 30;
            if (creature.memory.length > maxMemorySize) {
                // Remove least important old memories
                creature.memory.sort((a, b) => {
                    const ageA = Date.now() - a.timestamp;
                    const ageB = Date.now() - b.timestamp;
                    const scoreA = a.importance - (ageA / 20000);
                    const scoreB = b.importance - (ageB / 20000);
                    return scoreB - scoreA;
                });
                creature.memory = creature.memory.slice(0, maxMemorySize);
            }
        };

        const executeBehavior = (creature, goal, deltaTime) => {
            if (!goal) return;

            switch (goal.type) {
                case 'teach':
                    if (goal.target && goal.target.movable) {
                        const distance = Math.sqrt(
                            Math.pow(goal.target.x - creature.x, 2) +
                            Math.pow(goal.target.y - creature.y, 2)
                        );

                        if (distance > 60) {
                            // Move closer to target
                            creature.targetX = goal.target.x;
                            creature.targetY = goal.target.y;
                        } else {
                            // Teaching effect
                            if (!goal.target.teachingBoost || Date.now() - goal.target.teachingBoost.timestamp > 30000) {
                                goal.target.teachingBoost = {
                                    multiplier: 1.3,
                                    duration: 30000,
                                    timestamp: Date.now()
                                };

                                updateMemory(creature, {
                                    type: 'teaching_completed',
                                    data: { targetId: goal.target.id },
                                    importance: 3
                                });

                                creature.intelligence = Math.min(200, creature.intelligence + 1);
                            }
                        }
                    }
                    break;

                case 'meditate':
                    // Stay still and generate harmony
                    creature.targetX = creature.x;
                    creature.targetY = creature.y;

                    if (Math.random() < 0.02) { // 2% chance per frame
                        gameState.harmony = Math.min(100, gameState.harmony + 0.5);
                        gameState.insight = Math.min(gameState.insight + 0.2, gameState.insight + 0.2);
                    }
                    break;

                case 'explore':
                    if (goal.target) {
                        creature.targetX = goal.target.x;
                        creature.targetY = goal.target.y;

                        const distance = Math.sqrt(
                            Math.pow(goal.target.x - creature.x, 2) +
                            Math.pow(goal.target.y - creature.y, 2)
                        );

                        if (distance < 20) {
                            // Reached exploration target
                            updateMemory(creature, {
                                type: 'area_explored',
                                data: { location: { x: creature.x, y: creature.y } },
                                importance: 2
                            });

                            // Small chance to discover resources
                            if (Math.random() < 0.1) {
                                gameState.energy += 5;
                                log(`${creature.type} discovered energy while exploring!`, 'info');
                            }
                        }
                    }
                    break;

                case 'investigate':
                    if (goal.target) {
                        const distance = Math.sqrt(
                            Math.pow(goal.target.x - creature.x, 2) +
                            Math.pow(goal.target.y - creature.y, 2)
                        );

                        if (distance > 40) {
                            creature.targetX = goal.target.x;
                            creature.targetY = goal.target.y;
                        } else {
                            // Investigation complete
                            updateMemory(creature, {
                                type: 'resource_investigated',
                                data: { resourceType: goal.target.type, location: { x: goal.target.x, y: goal.target.y } },
                                importance: 4
                            });
                        }
                    }
                    break;

                case 'restore_harmony':
                    // Harmony restoration effect
                    if (Math.random() < 0.03) { // 3% chance per frame
                        gameState.harmony = Math.min(100, gameState.harmony + 1);

                        // Boost nearby units
                        gameState.villageGrid.forEach(entity => {
                            if (entity.movable) {
                                const distance = Math.sqrt(
                                    Math.pow(entity.x - creature.x, 2) +
                                    Math.pow(entity.y - creature.y, 2)
                                );

                                if (distance <= 80) {
                                    entity.harmonyBoost = {
                                        multiplier: 1.15,
                                        duration: 20000,
                                        timestamp: Date.now()
                                    };
                                }
                            }
                        });
                    }
                    break;

                case 'communicate':
                    if (goal.target) {
                        const distance = Math.sqrt(
                            Math.pow(goal.target.x - creature.x, 2) +
                            Math.pow(goal.target.y - creature.y, 2)
                        );

                        if (distance <= 70) {
                            // Share knowledge
                            const recentMemories = creature.memory.slice(-2);
                            recentMemories.forEach(memory => {
                                if (!goal.target.memory.some(m =>
                                    m.type === memory.type &&
                                    Math.abs(m.timestamp - memory.timestamp) < 2000
                                )) {
                                    goal.target.memory.push({
                                        ...memory,
                                        source: creature.id,
                                        shared: true
                                    });
                                }
                            });

                            // Improve relationship
                            creature.relationships.set(goal.target.id, 'friendly');
                            goal.target.relationships.set(creature.id, 'friendly');

                            // Both gain intelligence
                            creature.intelligence = Math.min(200, creature.intelligence + 0.5);
                            goal.target.intelligence = Math.min(200, goal.target.intelligence + 0.5);
                        }
                    }
                    break;

                case 'idle':
                default:
                    // Gentle wandering
                    const wanderRadius = 40;
                    creature.targetX = creature.x + (Math.random() - 0.5) * wanderRadius;
                    creature.targetY = creature.y + (Math.random() - 0.5) * wanderRadius;

                    // Keep within bounds
                    creature.targetX = Math.max(50, Math.min(canvas.width - 50, creature.targetX));
                    creature.targetY = Math.max(50, Math.min(canvas.height - 50, creature.targetY));
                    break;
            }
        };

        const updateIntelligentCreatures = (deltaTime) => {
            const currentTime = Date.now();

            gameState.intelligentCreatures.forEach(creature => {
                // Perception and decision making
                const perception = perceiveEnvironment(creature);
                const goal = makeDecision(creature, perception, currentTime);

                // Execute current behavior
                executeBehavior(creature, goal, deltaTime);

                // Update movement
                const dx = creature.targetX - creature.x;
                const dy = creature.targetY - creature.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 2) {
                    const speed = creature.movementSpeed;
                    const moveDistance = speed * deltaTime;
                    const ratio = Math.min(moveDistance / distance, 1);

                    creature.x += dx * ratio;
                    creature.y += dy * ratio;
                    creature.vx = dx * ratio / deltaTime;
                    creature.vy = dy * ratio / deltaTime;
                } else {
                    creature.vx = 0;
                    creature.vy = 0;
                }

                // Update goal duration
                if (goal && goal.startTime) {
                    if (currentTime - goal.startTime > goal.duration) {
                        creature.currentGoal = null;
                        creature.state = 'idle';
                    }
                } else if (goal) {
                    goal.startTime = currentTime;
                }
            });
        };

        const drawIntelligentCreatures = () => {
            gameState.intelligentCreatures.forEach(creature => {
                drawIntelligentCreature(creature);
            });
        };

        const drawIntelligentCreature = (creature) => {
            ctx.save();
            ctx.translate(creature.x, creature.y);

            const pulse = 1 + Math.sin(animationTime * 1.5 + creature.animationOffset) * 0.1;
            const currentSize = creature.size * pulse;

            // Intelligence aura - larger and more complex than regular units
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            ctx.shadowColor = creature.glowColor;
            ctx.shadowBlur = 35;

            const auraGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize * 2.5);
            const r = parseInt(creature.glowColor.slice(1,3), 16);
            const g = parseInt(creature.glowColor.slice(3,5), 16);
            const b = parseInt(creature.glowColor.slice(5,7), 16);

            auraGradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.3)`);
            auraGradient.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, 0.15)`);
            auraGradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);

            ctx.beginPath();
            ctx.arc(0, 0, currentSize * 2.5, 0, Math.PI * 2);
            ctx.fillStyle = auraGradient;
            ctx.fill();
            ctx.restore();

            // Main creature body - distinctive shape based on type
            if (creature.type === 'cosmicSage') {
                drawCosmicSage(creature, currentSize);
            } else if (creature.type === 'voidExplorer') {
                drawVoidExplorer(creature, currentSize);
            } else if (creature.type === 'harmonyKeeper') {
                drawHarmonyKeeper(creature, currentSize);
            }

            // Intelligence indicator - neural network pattern
            if (creature.intelligence > 100) {
                drawIntelligenceIndicator(creature, currentSize);
            }

            // State indicator
            drawStateIndicator(creature, currentSize);

            ctx.restore();
        };

        const drawCosmicSage = (creature, size) => {
            // Multi-layered mandala design
            ctx.save();
            ctx.shadowColor = creature.glowColor;
            ctx.shadowBlur = 25;

            // Outer ring with rotating symbols
            const rotation = animationTime * 0.3;
            for (let i = 0; i < 8; i++) {
                const angle = (i * Math.PI * 2 / 8) + rotation;
                const symbolX = Math.cos(angle) * size * 1.5;
                const symbolY = Math.sin(angle) * size * 1.5;

                ctx.save();
                ctx.translate(symbolX, symbolY);
                ctx.rotate(angle + Math.PI / 2);
                ctx.fillStyle = creature.glowColor;
                ctx.font = '12px serif';
                ctx.textAlign = 'center';
                ctx.fillText('◊', 0, 4);
                ctx.restore();
            }

            // Main body - complex geometric pattern
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
            const r = parseInt(creature.color.slice(1,3), 16);
            const g = parseInt(creature.color.slice(3,5), 16);
            const b = parseInt(creature.color.slice(5,7), 16);

            gradient.addColorStop(0, `rgba(${Math.min(255, r + 50)}, ${Math.min(255, g + 50)}, ${Math.min(255, b + 50)}, 1.0)`);
            gradient.addColorStop(0.6, `rgba(${r}, ${g}, ${b}, 0.9)`);
            gradient.addColorStop(1, `rgba(${Math.max(0, r - 30)}, ${Math.max(0, g - 30)}, ${Math.max(0, b - 30)}, 0.7)`);

            // Draw complex star pattern
            ctx.beginPath();
            for (let i = 0; i < 12; i++) {
                const angle = (i * Math.PI * 2) / 12;
                const radius = i % 2 === 0 ? size : size * 0.6;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fillStyle = gradient;
            ctx.fill();

            // Inner wisdom eye
            ctx.beginPath();
            ctx.arc(0, 0, size * 0.3, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.fill();

            ctx.beginPath();
            ctx.arc(0, 0, size * 0.15, 0, Math.PI * 2);
            ctx.fillStyle = creature.color;
            ctx.fill();

            ctx.restore();
        };

        const drawVoidExplorer = (creature, size) => {
            // Shifting, ethereal form
            ctx.save();
            ctx.shadowColor = creature.glowColor;
            ctx.shadowBlur = 20;

            const shift = Math.sin(animationTime * 2) * 0.2;

            // Main body - irregular, shifting shape
            ctx.beginPath();
            for (let i = 0; i <= 16; i++) {
                const angle = (i * Math.PI * 2) / 16;
                const variation = 1 + Math.sin(angle * 3 + animationTime * 1.5) * shift;
                const radius = size * variation;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();

            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
            const r = parseInt(creature.color.slice(1,3), 16);
            const g = parseInt(creature.color.slice(3,5), 16);
            const b = parseInt(creature.color.slice(5,7), 16);

            gradient.addColorStop(0, `rgba(${r + 40}, ${g + 40}, ${b + 40}, 0.8)`);
            gradient.addColorStop(0.7, `rgba(${r}, ${g}, ${b}, 0.6)`);
            gradient.addColorStop(1, `rgba(${r - 20}, ${g - 20}, ${b - 20}, 0.3)`);

            ctx.fillStyle = gradient;
            ctx.fill();

            // Void tendrils
            for (let i = 0; i < 4; i++) {
                const tendrilAngle = (i * Math.PI * 2 / 4) + animationTime * 0.5;
                const tendrilLength = size * (1.2 + Math.sin(animationTime * 2 + i) * 0.3);

                ctx.save();
                ctx.rotate(tendrilAngle);
                ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.6)`;
                ctx.lineWidth = 3;
                ctx.shadowBlur = 10;

                ctx.beginPath();
                ctx.moveTo(size * 0.7, 0);

                const segments = 5;
                for (let j = 1; j <= segments; j++) {
                    const t = j / segments;
                    const segmentX = size * 0.7 + tendrilLength * t;
                    const wave = Math.sin(t * Math.PI * 2 + animationTime * 3 + i) * 8;
                    const segmentY = wave;

                    if (j === 1) {
                        ctx.lineTo(segmentX, segmentY);
                    } else {
                        const prevT = (j - 1) / segments;
                        const prevX = size * 0.7 + tendrilLength * prevT;
                        const prevWave = Math.sin(prevT * Math.PI * 2 + animationTime * 3 + i) * 8;

                        const cp1x = prevX + (segmentX - prevX) * 0.5;
                        const cp1y = prevWave;
                        const cp2x = segmentX - (segmentX - prevX) * 0.5;
                        const cp2y = segmentY;

                        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, segmentX, segmentY);
                    }
                }
                ctx.stroke();
                ctx.restore();
            }

            ctx.restore();
        };

        const drawHarmonyKeeper = (creature, size) => {
            // Flowing, organic form with healing energy
            ctx.save();
            ctx.shadowColor = creature.glowColor;
            ctx.shadowBlur = 30;

            // Main body - organic, flowing shape
            const flow = animationTime * 1.2;
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
            const r = parseInt(creature.color.slice(1,3), 16);
            const g = parseInt(creature.color.slice(3,5), 16);
            const b = parseInt(creature.color.slice(5,7), 16);

            gradient.addColorStop(0, `rgba(${Math.min(255, r + 60)}, ${Math.min(255, g + 60)}, ${Math.min(255, b + 60)}, 1.0)`);
            gradient.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, 0.9)`);
            gradient.addColorStop(1, `rgba(${Math.max(0, r - 20)}, ${Math.max(0, g - 20)}, ${Math.max(0, b - 20)}, 0.6)`);

            // Draw flowing petals
            for (let i = 0; i < 6; i++) {
                const petalAngle = (i * Math.PI * 2 / 6) + flow * 0.2;
                const petalSize = size * (0.8 + Math.sin(flow + i) * 0.2);

                ctx.save();
                ctx.rotate(petalAngle);
                ctx.beginPath();
                ctx.ellipse(petalSize * 0.5, 0, petalSize * 0.6, petalSize * 0.3, 0, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
                ctx.restore();
            }

            // Central harmony core
            ctx.beginPath();
            ctx.arc(0, 0, size * 0.4, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(${Math.min(255, r + 80)}, ${Math.min(255, g + 80)}, ${Math.min(255, b + 80)}, 0.9)`;
            ctx.fill();

            // Healing energy waves
            for (let i = 0; i < 3; i++) {
                const waveRadius = size * (1.5 + i * 0.5) + Math.sin(flow * 2 - i) * 10;
                const waveAlpha = 0.3 - i * 0.1;

                ctx.beginPath();
                ctx.arc(0, 0, waveRadius, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${waveAlpha})`;
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            ctx.restore();
        };

        const drawIntelligenceIndicator = (creature, size) => {
            // Neural network pattern for high intelligence
            if (creature.intelligence <= 100) return;

            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            ctx.strokeStyle = `rgba(255, 255, 255, 0.4)`;
            ctx.lineWidth = 1;

            const nodes = 6;
            const nodePositions = [];

            // Create node positions
            for (let i = 0; i < nodes; i++) {
                const angle = (i * Math.PI * 2) / nodes;
                const radius = size * 0.8;
                nodePositions.push({
                    x: Math.cos(angle) * radius,
                    y: Math.sin(angle) * radius
                });
            }

            // Draw connections
            for (let i = 0; i < nodes; i++) {
                for (let j = i + 1; j < nodes; j++) {
                    if (Math.random() < 0.6) { // 60% chance of connection
                        ctx.beginPath();
                        ctx.moveTo(nodePositions[i].x, nodePositions[i].y);
                        ctx.lineTo(nodePositions[j].x, nodePositions[j].y);
                        ctx.stroke();
                    }
                }
            }

            // Draw nodes
            nodePositions.forEach(pos => {
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 2, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.fill();
            });

            ctx.restore();
        };

        const drawStateIndicator = (creature, size) => {
            // Small indicator showing current state
            ctx.save();
            ctx.translate(0, -size * 1.3);

            let stateColor = '#FFFFFF';
            let stateSymbol = '●';

            switch (creature.state) {
                case 'teach':
                    stateColor = '#F59E0B';
                    stateSymbol = '📚';
                    break;
                case 'meditate':
                    stateColor = '#8B5CF6';
                    stateSymbol = '🧘';
                    break;
                case 'explore':
                    stateColor = '#10B981';
                    stateSymbol = '🔍';
                    break;
                case 'investigate':
                    stateColor = '#06B6D4';
                    stateSymbol = '🔬';
                    break;
                case 'restore_harmony':
                    stateColor = '#059669';
                    stateSymbol = '✨';
                    break;
                case 'communicate':
                    stateColor = '#EC4899';
                    stateSymbol = '💬';
                    break;
            }

            if (creature.state !== 'idle') {
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillStyle = stateColor;
                ctx.shadowColor = stateColor;
                ctx.shadowBlur = 5;
                ctx.fillText(stateSymbol, 0, 5);
            }

            ctx.restore();
        };

        // --- TDD: Conversational AI Units System ---

        let conversationalUnitIdCounter = 0;

        const createConversationalUnit = (type, x, y) => {
            const unit = {
                id: `conv_${conversationalUnitIdCounter++}`,
                type: type,
                x: x,
                y: y,
                size: 25,
                conversational: true,
                personality: {
                    traits: [],
                    mood: 'neutral',
                    creativity: 0.3 + Math.random() * 0.7,
                    empathy: 0.3 + Math.random() * 0.7,
                    curiosity: 0.3 + Math.random() * 0.7,
                    wisdom: 0.3 + Math.random() * 0.7
                },
                dialogue: {
                    currentTopic: null,
                    conversationHistory: [],
                    lastSpoke: 0,
                    speakingCooldown: 8000,
                    preferredTopics: [],
                    memories: [],
                    relationships: new Map(),
                    currentThought: null,
                    thoughtBubbleVisible: false
                },
                needs: {
                    current: [],
                    fulfilled: [],
                    priority: 'low'
                },
                creativity: {
                    ideas: [],
                    projects: [],
                    inspirationLevel: 30 + Math.random() * 40
                },
                specialOffers: [],
                state: 'idle',
                playerRelationship: 0.1,
                animationOffset: Math.random() * Math.PI * 2,
                thoughtTimer: 0,
                nextThoughtTime: 5000 + Math.random() * 10000,
                draggable: true, // TDD: Enable drag-and-drop
                isDragging: false
            };

            // Initialize based on unit type
            if (type === 'philosopherDreamer') {
                unit.personality.traits = ['contemplative', 'wise', 'patient', 'deep-thinking'];
                unit.dialogue.preferredTopics = ['existence', 'dreams', 'cosmic_mysteries', 'consciousness'];
                unit.specialOffers = ['dream_interpretation', 'philosophical_guidance', 'meditation_session'];
                unit.color = '#6366F1';
                unit.glowColor = '#8B5CF6';
            } else if (type === 'artisticWeaver') {
                unit.personality.traits = ['creative', 'expressive', 'passionate', 'imaginative'];
                unit.dialogue.preferredTopics = ['art', 'beauty', 'creation', 'inspiration'];
                unit.specialOffers = ['custom_artwork', 'creative_collaboration', 'aesthetic_enhancement'];
                unit.color = '#EC4899';
                unit.glowColor = '#F472B6';
            } else if (type === 'curiousExplorer') {
                unit.personality.traits = ['inquisitive', 'adventurous', 'energetic', 'observant'];
                unit.dialogue.preferredTopics = ['discoveries', 'mysteries', 'exploration', 'unknown'];
                unit.specialOffers = ['guided_exploration', 'mystery_solving', 'treasure_hunting'];
                unit.color = '#10B981';
                unit.glowColor = '#34D399';
            }

            return unit;
        };

        const spawnConversationalUnit = (type) => {
            const size = 20; // Typical conversational unit size
            const margin = size + 15; // Extra margin for safety
            const x = Math.random() * (canvas.width - 2 * margin) + margin;
            const y = Math.random() * (canvas.height - 2 * margin) + margin;
            const unit = createConversationalUnit(type, x, y);
            gameState.conversationalUnits.push(unit);
            log(`A ${type} awakens and begins to contemplate the sanctuary...`, 'success');
            return unit;
        };

        const generateThought = (unit) => {
            const thoughts = {
                philosopherDreamer: [
                    "What dreams shape reality in this cosmic sanctuary?",
                    "I sense the interconnectedness of all beings here...",
                    "The harmony flows like a river of consciousness.",
                    "Perhaps existence itself is but a shared dream?",
                    "I wonder what wisdom the stars whisper tonight..."
                ],
                artisticWeaver: [
                    "The colors of energy here inspire new creations!",
                    "I could weave beauty from these cosmic threads...",
                    "Art is the language the universe speaks to itself.",
                    "What masterpiece shall we create together?",
                    "Beauty exists in every particle of this sanctuary."
                ],
                curiousExplorer: [
                    "What mysteries lie hidden in the sanctuary's depths?",
                    "I sense something fascinating just beyond perception...",
                    "Every corner holds a new discovery waiting!",
                    "The unknown calls to me with irresistible allure.",
                    "Adventure and wonder await those who seek!"
                ]
            };

            const typeThoughts = thoughts[unit.type] || ["I contemplate the mysteries of existence..."];
            return typeThoughts[Math.floor(Math.random() * typeThoughts.length)];
        };

        const updateConversationalUnits = (deltaTime) => {
            const currentTime = Date.now();

            gameState.conversationalUnits.forEach(unit => {
                // Update thought timer
                unit.thoughtTimer += deltaTime * 1000;

                // Generate new thoughts periodically
                if (unit.thoughtTimer >= unit.nextThoughtTime) {
                    unit.dialogue.currentThought = generateThought(unit);
                    unit.dialogue.thoughtBubbleVisible = true;
                    unit.thoughtTimer = 0;
                    unit.nextThoughtTime = 8000 + Math.random() * 15000; // 8-23 seconds

                    // Hide thought bubble after a while
                    setTimeout(() => {
                        unit.dialogue.thoughtBubbleVisible = false;
                    }, 4000);
                }

                // Update needs based on game state
                updateUnitNeeds(unit);

                // Generate creative ideas periodically
                if (Math.random() < 0.001 && unit.creativity.inspirationLevel > 60) { // 0.1% chance per frame
                    generateCreativeIdea(unit);
                }

                // Gentle movement
                if (Math.random() < 0.005) { // 0.5% chance per frame to move
                    const moveRadius = 30;
                    unit.targetX = unit.x + (Math.random() - 0.5) * moveRadius;
                    unit.targetY = unit.y + (Math.random() - 0.5) * moveRadius;

                    // Keep within bounds
                    unit.targetX = Math.max(50, Math.min(canvas.width - 50, unit.targetX));
                    unit.targetY = Math.max(50, Math.min(canvas.height - 50, unit.targetY));
                }

                // Simple movement towards target
                if (unit.targetX && unit.targetY) {
                    const dx = unit.targetX - unit.x;
                    const dy = unit.targetY - unit.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance > 2) {
                        const speed = 15; // Slow, contemplative movement
                        const moveDistance = speed * deltaTime;
                        const ratio = Math.min(moveDistance / distance, 1);

                        unit.x += dx * ratio;
                        unit.y += dy * ratio;
                    }
                }
            });
        };

        const updateUnitNeeds = (unit) => {
            unit.needs.current = [];

            // Generate needs based on game state
            if (gameState.harmony < 50) {
                unit.needs.current.push({
                    type: 'harmony_restoration',
                    urgency: 'high',
                    description: 'The sanctuary feels discordant. I need to help restore balance.'
                });
            }

            if (gameState.energy < 30) {
                unit.needs.current.push({
                    type: 'energy_boost',
                    urgency: 'medium',
                    description: 'The energy flows are weak. We need to revitalize them.'
                });
            }

            // Type-specific needs
            if (unit.type === 'artisticWeaver' && unit.creativity.inspirationLevel < 40) {
                unit.needs.current.push({
                    type: 'inspiration',
                    urgency: 'medium',
                    description: 'I need more beauty and inspiration to create meaningful art.'
                });
            }

            if (unit.type === 'philosopherDreamer' && gameState.insight < 20) {
                unit.needs.current.push({
                    type: 'contemplation_space',
                    urgency: 'low',
                    description: 'I require quiet contemplation to generate deeper insights.'
                });
            }
        };

        const generateCreativeIdea = (unit) => {
            const ideas = [];
            const creativityScore = unit.personality.creativity * (unit.creativity.inspirationLevel / 100);

            if (creativityScore > 0.6) {
                if (unit.type === 'artisticWeaver') {
                    ideas.push({
                        type: 'artistic_creation',
                        title: 'Harmony Tapestry',
                        description: 'A living tapestry that visualizes the sanctuary\'s energy flows',
                        requirements: { insight: 30, harmony: 60 },
                        effects: { beauty: 20, harmony_generation: 0.5 },
                        timeToComplete: 120000
                    });
                } else if (unit.type === 'philosopherDreamer') {
                    ideas.push({
                        type: 'philosophical_insight',
                        title: 'Meditation Garden Design',
                        description: 'A sacred space layout that enhances contemplation and wisdom',
                        requirements: { energy: 25, insight: 40 },
                        effects: { wisdom_boost: 1.3, meditation_efficiency: 1.5 },
                        timeToComplete: 180000
                    });
                }
            }

            if (ideas.length > 0) {
                unit.creativity.ideas.push(...ideas);
                log(`${unit.type} has a creative inspiration!`, 'info');
            }
        };

        const generateLLMDialogue = async (unit, playerInput = null) => {
            // Simulate LLM response for now (in real implementation, this would call the actual LLM API)
            const responses = {
                philosopherDreamer: {
                    greeting: [
                        "Ah, seeker of wisdom, I sense your curiosity about the cosmic mysteries. Would you like me to share a dream vision I had about the sanctuary's future?",
                        "Welcome, contemplative soul. I've been pondering the nature of existence in this sacred space. What brings you to seek conversation?",
                        "Greetings, fellow traveler of consciousness. I feel the harmony flowing between us. Shall we explore the deeper meanings together?"
                    ],
                    needs: [
                        "I sense discord in the sanctuary's harmony. Perhaps we could work together to restore the cosmic balance?",
                        "The energy flows seem diminished. I could guide a meditation to revitalize our shared space, if you're willing.",
                        "I've been contemplating ways to enhance our sanctuary's wisdom. Would you be interested in a philosophical collaboration?"
                    ],
                    creative: [
                        "I've envisioned a magnificent meditation garden that could transform how we experience consciousness here. Shall I share this dream with you?",
                        "In my contemplations, I've discovered a method to weave dreams into reality. Would you like to explore this possibility together?",
                        "I sense great potential for a consciousness bridge that could unite all beings in the sanctuary. Are you ready for such a profound undertaking?"
                    ]
                },
                artisticWeaver: {
                    greeting: [
                        "Oh, what beautiful energy you bring! I can see colors dancing around you that inspire new creations. Would you like to co-create something magnificent?",
                        "Welcome, kindred spirit! I've been weaving patterns of light and sound. Your presence adds such wonderful new hues to my palette!",
                        "Greetings, fellow appreciator of beauty! I sense an artistic collaboration brewing between us. What masterpiece shall we birth together?"
                    ],
                    needs: [
                        "I'm yearning for more inspiration to fuel my creative fire. The sanctuary's beauty feeds my art - could we enhance it together?",
                        "My artistic vision sees potential for incredible beauty here, but I need more creative energy. Would you help me gather inspiration?",
                        "I feel the sanctuary calling for more aesthetic harmony. My art could transform this space - shall we begin a beautiful project?"
                    ],
                    creative: [
                        "I've conceived of a living tapestry that would make the sanctuary's energy visible as flowing art. Would you commission this masterpiece?",
                        "My imagination has birthed a cosmic sculpture that could boost everyone's creativity. Shall we bring this vision to life?",
                        "I dream of creating an interactive art installation where beauty itself becomes a source of power. Are you ready to make art that changes reality?"
                    ]
                },
                curiousExplorer: {
                    greeting: [
                        "Fascinating! A new consciousness to explore and understand! I've been mapping the hidden mysteries of this sanctuary. Want to join my next expedition?",
                        "Greetings, fellow seeker! I've discovered the most intriguing phenomena in the sanctuary's depths. Would you like to investigate them with me?",
                        "Welcome, adventurous spirit! I sense you have the curiosity for great discoveries. Shall we uncover the sanctuary's secrets together?"
                    ],
                    needs: [
                        "I've detected mysterious energy signatures that need investigation. Would you help me explore these fascinating anomalies?",
                        "My explorations have revealed hidden chambers of knowledge, but I need a companion to safely venture deeper. Are you brave enough?",
                        "I sense undiscovered treasures of wisdom scattered throughout the sanctuary. Shall we embark on a treasure hunt together?"
                    ],
                    creative: [
                        "I've mapped a route to dimensions beyond our current perception. Would you join me on an interdimensional exploration?",
                        "My investigations have revealed a method to unlock hidden abilities through discovery. Are you ready for such an adventure?",
                        "I've conceived of an exploration network that could reveal all the sanctuary's mysteries simultaneously. Shall we build it together?"
                    ]
                }
            };

            const unitResponses = responses[unit.type] || responses.philosopherDreamer;
            let responseCategory = 'greeting';

            if (unit.needs.current.length > 0) {
                responseCategory = 'needs';
            } else if (unit.creativity.ideas.length > 0) {
                responseCategory = 'creative';
            }

            const possibleResponses = unitResponses[responseCategory];
            const response = possibleResponses[Math.floor(Math.random() * possibleResponses.length)];

            // Update conversation history
            if (playerInput) {
                unit.dialogue.conversationHistory.push({
                    timestamp: Date.now(),
                    player: playerInput,
                    unit: response,
                    topic: unit.dialogue.currentTopic
                });
            }

            return response;
        };

        const drawConversationalUnits = () => {
            gameState.conversationalUnits.forEach(unit => {
                drawConversationalUnit(unit);
            });
        };

        const drawConversationalUnit = (unit) => {
            ctx.save();
            ctx.translate(unit.x, unit.y);

            const pulse = 1 + Math.sin(animationTime * 1.2 + unit.animationOffset) * 0.08;
            const currentSize = unit.size * pulse;

            // Consciousness aura - more ethereal than regular units
            ctx.save();
            ctx.globalCompositeOperation = 'screen';
            ctx.shadowColor = unit.glowColor;
            ctx.shadowBlur = 40;

            const auraGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, currentSize * 3);
            const r = parseInt(unit.glowColor.slice(1,3), 16);
            const g = parseInt(unit.glowColor.slice(3,5), 16);
            const b = parseInt(unit.glowColor.slice(5,7), 16);

            auraGradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.4)`);
            auraGradient.addColorStop(0.3, `rgba(${r}, ${g}, ${b}, 0.2)`);
            auraGradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);

            ctx.beginPath();
            ctx.arc(0, 0, currentSize * 3, 0, Math.PI * 2);
            ctx.fillStyle = auraGradient;
            ctx.fill();
            ctx.restore();

            // Draw unit based on type
            if (unit.type === 'philosopherDreamer') {
                drawPhilosopherDreamer(unit, currentSize);
            } else if (unit.type === 'artisticWeaver') {
                drawArtisticWeaver(unit, currentSize);
            } else if (unit.type === 'curiousExplorer') {
                drawCuriousExplorer(unit, currentSize);
            }

            // Draw thought bubble if visible
            if (unit.dialogue.thoughtBubbleVisible && unit.dialogue.currentThought) {
                drawThoughtBubble(unit, currentSize);
            }

            // Draw conversation indicator
            if (unit.dialogue.conversationHistory.length > 0) {
                drawConversationIndicator(unit, currentSize);
            }

            // Draw needs indicator
            if (unit.needs.current.length > 0) {
                drawNeedsIndicator(unit, currentSize);
            }

            ctx.restore();
        };

        const drawPhilosopherDreamer = (unit, size) => {
            // Ethereal, contemplative design with flowing energy
            ctx.save();
            ctx.shadowColor = unit.glowColor;
            ctx.shadowBlur = 30;

            // Main consciousness form - flowing, organic shape
            const flow = animationTime * 0.8;
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
            const r = parseInt(unit.color.slice(1,3), 16);
            const g = parseInt(unit.color.slice(3,5), 16);
            const b = parseInt(unit.color.slice(5,7), 16);

            gradient.addColorStop(0, `rgba(${Math.min(255, r + 80)}, ${Math.min(255, g + 80)}, ${Math.min(255, b + 80)}, 1.0)`);
            gradient.addColorStop(0.6, `rgba(${r}, ${g}, ${b}, 0.9)`);
            gradient.addColorStop(1, `rgba(${Math.max(0, r - 40)}, ${Math.max(0, g - 40)}, ${Math.max(0, b - 40)}, 0.6)`);

            // Draw flowing consciousness form
            ctx.beginPath();
            for (let i = 0; i <= 20; i++) {
                const angle = (i * Math.PI * 2) / 20;
                const variation = 1 + Math.sin(angle * 3 + flow) * 0.15;
                const radius = size * variation;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fillStyle = gradient;
            ctx.fill();

            // Wisdom symbols floating around
            for (let i = 0; i < 4; i++) {
                const symbolAngle = flow * 0.3 + (i * Math.PI * 2 / 4);
                const symbolRadius = size * 1.8;
                const symbolX = Math.cos(symbolAngle) * symbolRadius;
                const symbolY = Math.sin(symbolAngle) * symbolRadius;

                ctx.save();
                ctx.translate(symbolX, symbolY);
                ctx.rotate(symbolAngle);
                ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.7)`;
                ctx.font = '16px serif';
                ctx.textAlign = 'center';
                ctx.fillText(['◊', '◈', '◇', '◆'][i], 0, 5);
                ctx.restore();
            }

            // Central consciousness eye
            ctx.beginPath();
            ctx.arc(0, 0, size * 0.3, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.fill();

            ctx.beginPath();
            ctx.arc(0, 0, size * 0.15, 0, Math.PI * 2);
            ctx.fillStyle = unit.color;
            ctx.fill();

            ctx.restore();
        };

        const drawArtisticWeaver = (unit, size) => {
            // Creative, colorful design with artistic flair
            ctx.save();
            ctx.shadowColor = unit.glowColor;
            ctx.shadowBlur = 25;

            const creativity = animationTime * 1.5;

            // Main artistic form - dynamic, creative shape
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
            const r = parseInt(unit.color.slice(1,3), 16);
            const g = parseInt(unit.color.slice(3,5), 16);
            const b = parseInt(unit.color.slice(5,7), 16);

            gradient.addColorStop(0, `rgba(${Math.min(255, r + 60)}, ${Math.min(255, g + 60)}, ${Math.min(255, b + 60)}, 1.0)`);
            gradient.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, 0.9)`);
            gradient.addColorStop(1, `rgba(${Math.max(0, r - 30)}, ${Math.max(0, g - 30)}, ${Math.max(0, b - 30)}, 0.7)`);

            // Draw artistic petals/brushstrokes
            for (let i = 0; i < 8; i++) {
                const petalAngle = (i * Math.PI * 2 / 8) + creativity * 0.2;
                const petalLength = size * (0.8 + Math.sin(creativity + i) * 0.3);

                ctx.save();
                ctx.rotate(petalAngle);
                ctx.beginPath();
                ctx.ellipse(petalLength * 0.4, 0, petalLength * 0.6, petalLength * 0.2, 0, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
                ctx.restore();
            }

            // Central creative core
            ctx.beginPath();
            ctx.arc(0, 0, size * 0.5, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(${Math.min(255, r + 100)}, ${Math.min(255, g + 100)}, ${Math.min(255, b + 100)}, 0.9)`;
            ctx.fill();

            // Creative sparkles
            for (let i = 0; i < 6; i++) {
                const sparkleAngle = creativity * 2 + (i * Math.PI * 2 / 6);
                const sparkleRadius = size * (1.2 + Math.sin(creativity * 3 + i) * 0.2);
                const sparkleX = Math.cos(sparkleAngle) * sparkleRadius;
                const sparkleY = Math.sin(sparkleAngle) * sparkleRadius;

                ctx.save();
                ctx.globalCompositeOperation = 'screen';
                ctx.beginPath();
                ctx.arc(sparkleX, sparkleY, 2, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.shadowColor = unit.glowColor;
                ctx.shadowBlur = 8;
                ctx.fill();
                ctx.restore();
            }

            ctx.restore();
        };

        const drawCuriousExplorer = (unit, size) => {
            // Dynamic, energetic design with exploration motifs
            ctx.save();
            ctx.shadowColor = unit.glowColor;
            ctx.shadowBlur = 20;

            const exploration = animationTime * 2;

            // Main explorer form - angular, dynamic
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
            const r = parseInt(unit.color.slice(1,3), 16);
            const g = parseInt(unit.color.slice(3,5), 16);
            const b = parseInt(unit.color.slice(5,7), 16);

            gradient.addColorStop(0, `rgba(${Math.min(255, r + 50)}, ${Math.min(255, g + 50)}, ${Math.min(255, b + 50)}, 1.0)`);
            gradient.addColorStop(0.6, `rgba(${r}, ${g}, ${b}, 0.9)`);
            gradient.addColorStop(1, `rgba(${Math.max(0, r - 25)}, ${Math.max(0, g - 25)}, ${Math.max(0, b - 25)}, 0.7)`);

            // Draw exploration compass design
            ctx.beginPath();
            for (let i = 0; i < 8; i++) {
                const angle = (i * Math.PI * 2) / 8;
                const radius = i % 2 === 0 ? size : size * 0.6;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fillStyle = gradient;
            ctx.fill();

            // Exploration rays
            for (let i = 0; i < 4; i++) {
                const rayAngle = exploration * 0.5 + (i * Math.PI * 2 / 4);
                const rayLength = size * (1.5 + Math.sin(exploration + i) * 0.3);

                ctx.save();
                ctx.rotate(rayAngle);
                ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.6)`;
                ctx.lineWidth = 2;
                ctx.shadowBlur = 10;

                ctx.beginPath();
                ctx.moveTo(size * 0.8, 0);
                ctx.lineTo(rayLength, 0);
                ctx.stroke();

                // Arrow tip
                ctx.beginPath();
                ctx.moveTo(rayLength, 0);
                ctx.lineTo(rayLength - 8, -4);
                ctx.lineTo(rayLength - 8, 4);
                ctx.closePath();
                ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.8)`;
                ctx.fill();

                ctx.restore();
            }

            // Central discovery core
            ctx.beginPath();
            ctx.arc(0, 0, size * 0.3, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(${Math.min(255, r + 70)}, ${Math.min(255, g + 70)}, ${Math.min(255, b + 70)}, 0.9)`;
            ctx.fill();

            ctx.restore();
        };

        const drawThoughtBubble = (unit, size) => {
            if (!unit.dialogue.currentThought) return;

            ctx.save();
            ctx.translate(0, -size * 2);

            // Bubble background
            const bubbleWidth = Math.min(200, unit.dialogue.currentThought.length * 8);
            const bubbleHeight = 40;

            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            ctx.strokeStyle = 'rgba(100, 100, 100, 0.8)';
            ctx.lineWidth = 2;
            ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
            ctx.shadowBlur = 10;

            // Rounded rectangle
            ctx.beginPath();
            ctx.roundRect(-bubbleWidth/2, -bubbleHeight/2, bubbleWidth, bubbleHeight, 15);
            ctx.fill();
            ctx.stroke();

            // Bubble tail
            ctx.beginPath();
            ctx.moveTo(0, bubbleHeight/2);
            ctx.lineTo(-10, bubbleHeight/2 + 15);
            ctx.lineTo(10, bubbleHeight/2 + 15);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Text
            ctx.fillStyle = '#333';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.shadowBlur = 0;

            // Word wrap
            const words = unit.dialogue.currentThought.split(' ');
            const lines = [];
            let currentLine = '';

            words.forEach(word => {
                const testLine = currentLine + (currentLine ? ' ' : '') + word;
                if (ctx.measureText(testLine).width < bubbleWidth - 20) {
                    currentLine = testLine;
                } else {
                    if (currentLine) lines.push(currentLine);
                    currentLine = word;
                }
            });
            if (currentLine) lines.push(currentLine);

            lines.forEach((line, index) => {
                ctx.fillText(line, 0, -lines.length * 6 + index * 12);
            });

            ctx.restore();
        };

        const drawConversationIndicator = (unit, size) => {
            // Small chat icon to show unit is conversational
            ctx.save();
            ctx.translate(size * 0.8, -size * 0.8);

            ctx.fillStyle = 'rgba(100, 200, 255, 0.8)';
            ctx.strokeStyle = 'rgba(50, 150, 255, 1.0)';
            ctx.lineWidth = 1;
            ctx.shadowColor = 'rgba(100, 200, 255, 0.5)';
            ctx.shadowBlur = 5;

            // Chat bubble icon
            ctx.beginPath();
            ctx.roundRect(-8, -6, 16, 12, 4);
            ctx.fill();
            ctx.stroke();

            // Chat dots
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(-4, 0, 1.5, 0, Math.PI * 2);
            ctx.arc(0, 0, 1.5, 0, Math.PI * 2);
            ctx.arc(4, 0, 1.5, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        };

        const drawNeedsIndicator = (unit, size) => {
            if (unit.needs.current.length === 0) return;

            ctx.save();
            ctx.translate(-size * 0.8, -size * 0.8);

            // Exclamation mark for needs
            const urgencyColor = unit.needs.current.some(n => n.urgency === 'high') ?
                'rgba(255, 100, 100, 0.9)' : 'rgba(255, 200, 100, 0.9)';

            ctx.fillStyle = urgencyColor;
            ctx.strokeStyle = 'rgba(200, 50, 50, 1.0)';
            ctx.lineWidth = 1;
            ctx.shadowColor = urgencyColor;
            ctx.shadowBlur = 5;

            // Exclamation background
            ctx.beginPath();
            ctx.arc(0, 0, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // Exclamation mark
            ctx.fillStyle = 'white';
            ctx.font = 'bold 12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('!', 0, 4);

            ctx.restore();
        };

        // Conversation interaction system
        let selectedConversationalUnit = null;
        let conversationDialog = null;

        const createConversationDialog = (unit) => {
            // Remove existing dialog
            if (conversationDialog) {
                conversationDialog.remove();
            }

            conversationDialog = document.createElement('div');
            conversationDialog.className = 'conversation-dialog';
            conversationDialog.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(135deg, rgba(30, 27, 75, 0.95), rgba(49, 46, 129, 0.95));
                border: 2px solid rgba(139, 92, 246, 0.5);
                border-radius: 15px;
                padding: 20px;
                max-width: 500px;
                width: 90%;
                color: white;
                font-family: 'Inter', sans-serif;
                box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
                backdrop-filter: blur(10px);
                z-index: 1000;
            `;

            conversationDialog.innerHTML = `
                <div style="display: flex; align-items: center; margin-bottom: 15px;">
                    <div style="width: 40px; height: 40px; border-radius: 50%; background: ${unit.color}; margin-right: 15px; display: flex; align-items: center; justify-content: center; font-size: 20px;">
                        ${unit.type === 'philosopherDreamer' ? '🧙‍♂️' : unit.type === 'artisticWeaver' ? '🎨' : '🔍'}
                    </div>
                    <div>
                        <h3 style="margin: 0; color: #A78BFA;">${unit.type.replace(/([A-Z])/g, ' $1').trim()}</h3>
                        <p style="margin: 0; font-size: 12px; color: #C4B5FD;">Mood: ${unit.personality.mood} • Traits: ${unit.personality.traits.slice(0, 2).join(', ')}</p>
                    </div>
                    <button onclick="closeConversationDialog()" style="margin-left: auto; background: none; border: none; color: #9CA3AF; font-size: 20px; cursor: pointer;">×</button>
                </div>

                <div id="conversation-content" style="margin-bottom: 15px; max-height: 200px; overflow-y: auto;">
                    <div style="background: rgba(139, 92, 246, 0.2); padding: 10px; border-radius: 8px; margin-bottom: 10px;">
                        <div style="font-size: 12px; color: #A78BFA; margin-bottom: 5px;">${unit.type}:</div>
                        <div id="unit-response">Generating response...</div>
                    </div>
                </div>

                <div style="display: flex; gap: 10px;">
                    <input type="text" id="player-input" placeholder="What would you like to say?"
                           style="flex: 1; padding: 10px; border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 8px; background: rgba(0, 0, 0, 0.2); color: white;" />
                    <button onclick="sendMessage()" style="padding: 10px 20px; background: linear-gradient(45deg, #8B5CF6, #A855F7); border: none; border-radius: 8px; color: white; cursor: pointer;">Send</button>
                </div>

                ${unit.needs.current.length > 0 ? `
                    <div style="margin-top: 15px; padding: 10px; background: rgba(239, 68, 68, 0.1); border-radius: 8px; border-left: 4px solid #EF4444;">
                        <div style="font-size: 12px; color: #FCA5A5; margin-bottom: 5px;">Current Needs:</div>
                        ${unit.needs.current.map(need => `<div style="font-size: 11px; color: #FED7D7;">• ${need.description}</div>`).join('')}
                    </div>
                ` : ''}

                ${unit.creativity.ideas.length > 0 ? `
                    <div style="margin-top: 15px; padding: 10px; background: rgba(236, 72, 153, 0.1); border-radius: 8px; border-left: 4px solid #EC4899;">
                        <div style="font-size: 12px; color: #F9A8D4; margin-bottom: 5px;">Creative Ideas:</div>
                        ${unit.creativity.ideas.slice(0, 2).map(idea => `<div style="font-size: 11px; color: #FBCFE8;">• ${idea.title}: ${idea.description}</div>`).join('')}
                    </div>
                ` : ''}
            `;

            document.body.appendChild(conversationDialog);

            // Generate initial response
            generateLLMDialogue(unit).then(response => {
                document.getElementById('unit-response').textContent = response;
            });

            // Focus input
            document.getElementById('player-input').focus();

            // Enter key handler
            document.getElementById('player-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            });
        };

        // --- TDD: Unit Interactions & Synergy System ---

        const detectNearbyUnits = (unit, allUnits, interactionRadius = 60) => {
            const nearbyUnits = [];

            allUnits.forEach(otherUnit => {
                if (otherUnit.id === unit.id) return;

                const distance = Math.sqrt(
                    Math.pow(otherUnit.x - unit.x, 2) +
                    Math.pow(otherUnit.y - unit.y, 2)
                );

                if (distance <= interactionRadius) {
                    nearbyUnits.push({
                        unit: otherUnit,
                        distance: distance,
                        interactionType: determineInteractionType(unit, otherUnit)
                    });
                }
            });

            return nearbyUnits;
        };

        const determineInteractionType = (unit1, unit2) => {
            const interactions = {
                'dreamer-weaver': 'inspiration',
                'weaver-dreamer': 'inspiration',
                'philosopherDreamer-artisticWeaver': 'creative_collaboration',
                'artisticWeaver-philosopherDreamer': 'creative_collaboration',
                'curiousExplorer-philosopherDreamer': 'knowledge_sharing',
                'philosopherDreamer-curiousExplorer': 'knowledge_sharing'
            };

            const key1 = `${unit1.type}-${unit2.type}`;
            const key2 = `${unit2.type}-${unit1.type}`;

            return interactions[key1] || interactions[key2] || 'general_synergy';
        };

        const updateUnitInteractions = (deltaTime) => {
            const currentTime = Date.now();

            // Clean up expired interactions
            gameState.activeInteractions = gameState.activeInteractions.filter(interaction => {
                return currentTime - interaction.startTime < interaction.duration;
            });

            // Check for new interactions between all units
            const allUnits = [
                ...gameState.villageGrid.filter(unit => unit.movable),
                ...gameState.intelligentCreatures,
                ...gameState.conversationalUnits
            ];

            allUnits.forEach(unit => {
                const nearbyUnits = detectNearbyUnits(unit, allUnits);

                nearbyUnits.forEach(nearby => {
                    // Check if interaction already exists
                    const existingInteraction = gameState.activeInteractions.find(interaction =>
                        (interaction.participants.includes(unit.id) && interaction.participants.includes(nearby.unit.id))
                    );

                    if (!existingInteraction && Math.random() < 0.01) { // 1% chance per frame to start interaction
                        createInteraction(unit, nearby.unit, nearby.interactionType);
                    }
                });
            });

            // Apply interaction effects
            gameState.activeInteractions.forEach(interaction => {
                applyInteractionEffects(interaction, deltaTime);
            });
        };

        const createInteraction = (unit1, unit2, interactionType) => {
            const interaction = {
                id: `${unit1.id}_${unit2.id}_${Date.now()}`,
                participants: [unit1.id, unit2.id],
                type: interactionType,
                startTime: Date.now(),
                duration: 5000,
                effects: [],
                active: true
            };

            // Define interaction effects
            switch (interactionType) {
                case 'inspiration':
                    interaction.effects = [
                        { type: 'resource_generation', resource: 'inspiration', amount: 2 }
                    ];
                    break;

                case 'creative_collaboration':
                    interaction.effects = [
                        { type: 'resource_generation', resource: 'inspiration', amount: 3 },
                        { type: 'resource_generation', resource: 'insight', amount: 1 }
                    ];
                    break;

                case 'knowledge_sharing':
                    interaction.effects = [
                        { type: 'resource_generation', resource: 'wisdom', amount: 2 },
                        { type: 'resource_generation', resource: 'insight', amount: 1 }
                    ];
                    break;

                default:
                    interaction.effects = [
                        { type: 'resource_generation', resource: 'inspiration', amount: 1 }
                    ];
            }

            gameState.activeInteractions.push(interaction);
            log(`${unit1.type} and ${unit2.type} begin ${interactionType}!`, 'info');

            // TDD: Track statistics for achievements
            updateStatistics('interaction_occurred');
        };

        const applyInteractionEffects = (interaction, deltaTime) => {
            interaction.effects.forEach(effect => {
                if (effect.type === 'resource_generation') {
                    const amount = effect.amount * deltaTime;
                    if (gameState[effect.resource] !== undefined) {
                        gameState[effect.resource] += amount;
                    }
                }
            });
        };

        // --- TDD: Achievement & Goals System ---

        const initializeAchievements = () => {
            const achievements = {
                // Basic Achievements
                first_dreamer: {
                    id: 'first_dreamer',
                    name: 'Dream Weaver',
                    description: 'Create your first Dreamer unit',
                    category: 'basic',
                    requirements: { type: 'unit_creation', unitType: 'dreamers', target: 1 },
                    rewards: { insight: 10, title: 'Novice Dreamer' },
                    unlocked: false,
                    progress: 0,
                    rarity: 'common'
                },
                first_weaver: {
                    id: 'first_weaver',
                    name: 'Reality Shaper',
                    description: 'Create your first Weaver unit',
                    category: 'basic',
                    requirements: { type: 'unit_creation', unitType: 'weavers', target: 1 },
                    rewards: { energy: 15, title: 'Reality Apprentice' },
                    unlocked: false,
                    progress: 0,
                    rarity: 'common'
                },
                energy_milestone: {
                    id: 'energy_milestone',
                    name: 'Power Surge',
                    description: 'Accumulate 100 Energy',
                    category: 'basic',
                    requirements: { type: 'resource_threshold', resource: 'energy', target: 100 },
                    rewards: { energy: 25, insight: 10 },
                    unlocked: false,
                    progress: 0,
                    rarity: 'common'
                },
                harmony_master: {
                    id: 'harmony_master',
                    name: 'Harmony Master',
                    description: 'Achieve 90% Harmony',
                    category: 'advanced',
                    requirements: { type: 'harmony_level', target: 90 },
                    rewards: { harmony: 10, wisdom: 20, title: 'Harmony Master' },
                    unlocked: false,
                    progress: 0,
                    rarity: 'rare'
                },
                social_butterfly: {
                    id: 'social_butterfly',
                    name: 'Social Butterfly',
                    description: 'Have 10 unit interactions',
                    category: 'advanced',
                    requirements: { type: 'total_interactions', target: 10 },
                    rewards: { inspiration: 30, wisdom: 15 },
                    unlocked: false,
                    progress: 0,
                    rarity: 'uncommon'
                },
                conversationalist: {
                    id: 'conversationalist',
                    name: 'Deep Conversationalist',
                    description: 'Have 5 conversations with AI units',
                    category: 'advanced',
                    requirements: { type: 'conversation_count', target: 5 },
                    rewards: { wisdom: 25, insight: 15, title: 'Sage Communicator' },
                    unlocked: false,
                    progress: 0,
                    rarity: 'rare'
                },
                sanctuary_architect: {
                    id: 'sanctuary_architect',
                    name: 'Sanctuary Architect',
                    description: 'Create 10 units of any type',
                    category: 'advanced',
                    requirements: { type: 'total_units_created', target: 10 },
                    rewards: { energy: 50, insight: 30, inspiration: 20 },
                    unlocked: false,
                    progress: 0,
                    rarity: 'uncommon'
                },
                cosmic_sage: {
                    id: 'cosmic_sage',
                    name: 'Cosmic Sage',
                    description: 'Reach maximum levels in all resources',
                    category: 'master',
                    requirements: {
                        type: 'multiple_conditions',
                        conditions: [
                            { type: 'min_resource', resource: 'energy', value: 500 },
                            { type: 'min_resource', resource: 'insight', value: 300 },
                            { type: 'min_resource', resource: 'wisdom', value: 200 },
                            { type: 'min_resource', resource: 'inspiration', value: 150 }
                        ]
                    },
                    rewards: { title: 'Cosmic Sage', energy: 100, insight: 100, wisdom: 100, inspiration: 100 },
                    unlocked: false,
                    progress: 0,
                    rarity: 'legendary'
                }
            };

            gameState.achievements.definitions = achievements;
            return achievements;
        };

        const initializeGoals = () => {
            const goals = [
                {
                    id: 'sanctuary_growth',
                    title: 'Growing Sanctuary',
                    description: 'Expand your sanctuary by creating 5 units of any type',
                    type: 'unit_count',
                    target: 5,
                    progress: 0,
                    completed: false,
                    rewards: { energy: 25, insight: 15, harmony: 10 },
                    priority: 'high',
                    category: 'main',
                    hints: ['Create Dreamers and Weavers to expand your sanctuary', 'Each unit contributes to your sanctuary\'s growth']
                },
                {
                    id: 'energy_collector',
                    title: 'Energy Collector',
                    description: 'Accumulate 200 Energy',
                    type: 'resource_accumulation',
                    resource: 'energy',
                    target: 200,
                    progress: 0,
                    completed: false,
                    rewards: { energy: 50, insight: 25 },
                    priority: 'normal',
                    category: 'resource',
                    hints: ['Weavers generate Energy over time', 'Complete achievements for Energy bonuses']
                },
                {
                    id: 'harmony_keeper',
                    title: 'Harmony Keeper',
                    description: 'Maintain Harmony above 80% for 2 minutes',
                    type: 'harmony_maintenance',
                    threshold: 80,
                    target: 120000, // 2 minutes in milliseconds
                    progress: 0,
                    completed: false,
                    rewards: { harmony: 15, wisdom: 20, title: 'Harmony Keeper' },
                    priority: 'normal',
                    category: 'harmony',
                    hints: ['Keep your sanctuary balanced', 'Unit interactions help maintain harmony']
                },
                {
                    id: 'social_network',
                    title: 'Social Network',
                    description: 'Facilitate 15 unit interactions',
                    type: 'interaction_count',
                    target: 15,
                    progress: 0,
                    completed: false,
                    rewards: { inspiration: 40, wisdom: 25 },
                    priority: 'normal',
                    category: 'social',
                    prerequisites: ['sanctuary_growth'],
                    hints: ['Place units close together to encourage interactions', 'Different unit types create different interaction types']
                }
            ];

            gameState.goals.available = goals;
            gameState.goals.active = goals.slice(0, 2); // Start with first 2 goals active
            return goals;
        };

        const checkAchievementProgress = (achievement, gameState) => {
            const req = achievement.requirements;
            let currentProgress = 0;

            switch (req.type) {
                case 'unit_creation':
                    currentProgress = gameState.units[req.unitType] || 0;
                    break;
                case 'resource_threshold':
                    currentProgress = gameState[req.resource] || 0;
                    break;
                case 'total_interactions':
                    currentProgress = gameState.statistics.totalInteractions || 0;
                    break;
                case 'harmony_level':
                    currentProgress = gameState.harmony || 0;
                    break;
                case 'conversation_count':
                    currentProgress = gameState.statistics.totalConversations || 0;
                    break;
                case 'total_units_created':
                    currentProgress = gameState.statistics.totalUnitsCreated || 0;
                    break;
                case 'multiple_conditions':
                    currentProgress = req.conditions.every(condition =>
                        checkSingleCondition(condition, gameState)
                    ) ? 1 : 0;
                    break;
            }

            achievement.progress = Math.min(currentProgress, req.target || 1);

            if (achievement.progress >= (req.target || 1) && !achievement.unlocked) {
                return { shouldUnlock: true, achievement };
            }

            return { shouldUnlock: false, achievement };
        };

        const checkSingleCondition = (condition, gameState) => {
            switch (condition.type) {
                case 'min_units':
                    return (gameState.units[condition.unitType] || 0) >= condition.value;
                case 'min_resource':
                    return (gameState[condition.resource] || 0) >= condition.value;
                default:
                    return false;
            }
        };

        const unlockAchievement = (achievement, gameState) => {
            if (achievement.unlocked) return false;

            achievement.unlocked = true;
            achievement.unlockedAt = Date.now();

            // Apply rewards
            if (achievement.rewards) {
                Object.keys(achievement.rewards).forEach(rewardType => {
                    if (rewardType === 'title') {
                        gameState.playerTitles.push(achievement.rewards[rewardType]);
                    } else if (gameState[rewardType] !== undefined) {
                        gameState[rewardType] += achievement.rewards[rewardType];
                    }
                });
            }

            // Add to unlocked achievements
            gameState.achievements.unlocked.push(achievement.id);

            // Show achievement notification
            showAchievementNotification(achievement);

            log(`⭐ Achievement Unlocked: ${achievement.name}!`, 'success');

            return {
                success: true,
                achievement: achievement,
                rewards: achievement.rewards
            };
        };

        const updateGoalProgress = (goal, gameState) => {
            let currentProgress = 0;

            switch (goal.type) {
                case 'unit_count':
                    currentProgress = Object.values(gameState.units).reduce((sum, count) => sum + count, 0);
                    break;
                case 'resource_accumulation':
                    currentProgress = gameState[goal.resource] || 0;
                    break;
                case 'harmony_maintenance':
                    if (gameState.harmony >= goal.threshold) {
                        goal.harmonyStartTime = goal.harmonyStartTime || Date.now();
                        currentProgress = Date.now() - goal.harmonyStartTime;
                    } else {
                        goal.harmonyStartTime = null;
                        currentProgress = 0;
                    }
                    break;
                case 'interaction_count':
                    currentProgress = gameState.statistics.totalInteractions || 0;
                    break;
                case 'conversation_count':
                    currentProgress = gameState.statistics.totalConversations || 0;
                    break;
            }

            goal.progress = Math.min(currentProgress, goal.target);

            if (goal.progress >= goal.target && !goal.completed) {
                return { shouldComplete: true, goal };
            }

            return { shouldComplete: false, goal };
        };

        const completeGoal = (goal, gameState) => {
            if (goal.completed) return false;

            goal.completed = true;
            goal.completedAt = Date.now();

            // Apply rewards
            if (goal.rewards) {
                Object.keys(goal.rewards).forEach(rewardType => {
                    if (rewardType === 'title') {
                        gameState.playerTitles.push(goal.rewards[rewardType]);
                    } else if (gameState[rewardType] !== undefined) {
                        gameState[rewardType] += goal.rewards[rewardType];
                    }
                });
            }

            // Move to completed goals
            gameState.goals.completed.push(goal.id);
            gameState.goals.active = gameState.goals.active.filter(g => g.id !== goal.id);

            // Check for new goals that might be unlocked
            const newGoals = checkUnlockedGoals(gameState);
            gameState.goals.active.push(...newGoals);

            // Show goal completion notification
            showGoalNotification(goal);

            log(`🎯 Goal Completed: ${goal.title}!`, 'success');

            return {
                success: true,
                goal: goal,
                rewards: goal.rewards,
                newGoalsUnlocked: newGoals
            };
        };

        const checkUnlockedGoals = (gameState) => {
            const availableGoals = gameState.goals.available.filter(goal =>
                !gameState.goals.completed.includes(goal.id) &&
                !gameState.goals.active.some(activeGoal => activeGoal.id === goal.id)
            );

            return availableGoals.filter(goal => {
                if (!goal.prerequisites || goal.prerequisites.length === 0) return false;

                return goal.prerequisites.every(prereqId =>
                    gameState.goals.completed.includes(prereqId)
                );
            });
        };

        const updateStatistics = (eventType, data = {}) => {
            const stats = gameState.statistics;

            switch (eventType) {
                case 'unit_created':
                    stats.totalUnitsCreated += 1;
                    break;
                case 'energy_generated':
                    stats.totalEnergyGenerated += data.amount || 0;
                    stats.maxEnergy = Math.max(stats.maxEnergy, gameState.energy);
                    break;
                case 'insight_generated':
                    stats.totalInsightGenerated += data.amount || 0;
                    stats.maxInsight = Math.max(stats.maxInsight, gameState.insight);
                    break;
                case 'control_generated':
                    stats.totalControlGenerated += data.amount || 0;
                    stats.maxControl = Math.max(stats.maxControl, gameState.control);
                    break;
                case 'consciousness_generated':
                    stats.totalConsciousnessGenerated += data.amount || 0;
                    stats.maxConsciousness = Math.max(stats.maxConsciousness, gameState.consciousness);
                    stats.maxPlanetaryConsciousness = Math.max(stats.maxPlanetaryConsciousness, gameState.planetaryConsciousness);
                    break;
                case 'ruler_path_choice':
                    stats.rulerPathChoices += 1;
                    break;
                case 'gardener_path_choice':
                    stats.gardenerPathChoices += 1;
                    break;
                case 'interaction_occurred':
                    stats.totalInteractions += 1;
                    break;
                case 'conversation_started':
                    stats.totalConversations += 1;
                    break;
                case 'harmony_changed':
                    stats.maxHarmony = Math.max(stats.maxHarmony, gameState.harmony);
                    break;
            }

            // Update play time
            stats.playTime = Date.now() - stats.gameStartTime;
        };

        // --- TDD: Control vs Consciousness System ---

        const updateControlConsciousnessSystem = (deltaTime) => {
            // Control suppresses unrest but reduces consciousness over time
            if (gameState.control > 0) {
                const consciousnessReduction = gameState.control * 0.01 * deltaTime; // 1% per second per Control point
                gameState.consciousness = Math.max(0, gameState.consciousness - consciousnessReduction);

                // Control also reduces harmony slightly (authoritarian effects)
                const harmonyReduction = gameState.control * 0.005 * deltaTime;
                gameState.harmony = Math.max(0, gameState.harmony - harmonyReduction);
            }

            // Consciousness improves well-being but can create resistance to control
            if (gameState.consciousness > 0) {
                const harmonyBonus = gameState.consciousness * 0.01 * deltaTime; // 1% per second per Consciousness point
                gameState.harmony = Math.min(100, gameState.harmony + harmonyBonus);

                // High consciousness reduces control effectiveness
                if (gameState.consciousness > gameState.control) {
                    const controlReduction = (gameState.consciousness - gameState.control) * 0.005 * deltaTime;
                    gameState.control = Math.max(0, gameState.control - controlReduction);
                }
            }

            // Update planetary consciousness based on individual consciousness
            const consciousnessContribution = gameState.consciousness * 0.1 * deltaTime;
            const controlPenalty = gameState.control * 0.05 * deltaTime;
            gameState.planetaryConsciousness = Math.max(0, Math.min(100,
                gameState.planetaryConsciousness + consciousnessContribution - controlPenalty
            ));

            // Calculate entropy from imbalanced systems
            const imbalance = Math.abs(gameState.control - gameState.consciousness);
            if (imbalance > 20) {
                gameState.entropy += imbalance * 0.001 * deltaTime;
            }

            // Track statistics
            if (gameState.controlPerSecond > 0) {
                updateStatistics('control_generated', { amount: gameState.controlPerSecond * deltaTime });
            }
            if (gameState.consciousnessPerSecond > 0) {
                updateStatistics('consciousness_generated', { amount: gameState.consciousnessPerSecond * deltaTime });
            }
        };

        const checkGreatTransitionConditions = () => {
            // Don't check if game has already ended
            if (gameState.gameEnded) {
                return true;
            }

            // Debug logging for victory condition checking
            debugLog('VICTORY', 'Checking victory conditions', {
                rulerProgress: gameState.rulerPathProgress,
                gardenerProgress: gameState.gardenerPathProgress,
                planetaryConsciousness: gameState.planetaryConsciousness,
                dominantPath: gameState.dominantPath,
                consciousness: gameState.consciousness,
                control: gameState.control,
                entropy: gameState.entropy,
                harmony: gameState.harmony
            });

            // Check for story-driven victory conditions
            if (gameState.rulerPathProgress >= 100) {
                debugLog('VICTORY', 'Ruler victory triggered', { progress: gameState.rulerPathProgress });
                showRulerVictory();
                gameState.gameEnded = true;
                return true;
            }

            if (gameState.gardenerPathProgress >= 100) {
                debugLog('VICTORY', 'Gardener victory triggered', { progress: gameState.gardenerPathProgress });
                showGardenerVictory();
                gameState.gameEnded = true;
                return true;
            }

            // TDD: Balanced victory condition - requires buildings AND story progression
            const totalBuildings = Object.values(gameState.gardenerBuildings).reduce((sum, count) => sum + count, 0) +
                                 Object.values(gameState.rulerBuildings).reduce((sum, count) => sum + count, 0);

            const balanceThresholds = gameConfig.balance.victoryThresholds;

            // Legacy win condition: Planetary Consciousness reaches 100 (with stricter requirements)
            if (gameState.planetaryConsciousness >= balanceThresholds.planetaryConsciousness &&
                gameState.dominantPath === 'none') {

                // TDD: Enforce minimum building requirement
                if (totalBuildings < balanceThresholds.minBuildingsForVictory) {
                    debugLog('BALANCE', 'Victory blocked - insufficient buildings', {
                        planetaryConsciousness: gameState.planetaryConsciousness,
                        totalBuildings: totalBuildings,
                        required: balanceThresholds.minBuildingsForVictory
                    });

                    if (Math.random() < 0.1) { // Occasional hint
                        log(`🏗️ The consciousness is high, but the foundation is weak. Build more structures to stabilize the transformation. (${totalBuildings}/${balanceThresholds.minBuildingsForVictory})`, 'warning');
                    }
                    return false;
                }

                // TDD: Enforce story progression requirement
                if (balanceThresholds.storyProgressionRequired && !gameState.trueLoreRevealed) {
                    debugLog('BALANCE', 'Victory blocked - story not complete', {
                        anomalyDiscovered: gameState.anomalyDiscovered,
                        trueLoreRevealed: gameState.trueLoreRevealed
                    });

                    if (Math.random() < 0.1) { // Occasional hint
                        log('📖 The transformation requires understanding. Explore the mysteries of your world first.', 'warning');
                    }
                    return false;
                }

                debugLog('VICTORY', 'Balanced victory triggered', {
                    planetaryConsciousness: gameState.planetaryConsciousness,
                    totalBuildings: totalBuildings,
                    storyComplete: gameState.trueLoreRevealed
                });
                showGenericVictory();
                gameState.gameEnded = true;
                return true;
            }

            // TDD: Balance warning system
            if (gameState.planetaryConsciousness >= 80 && totalBuildings < balanceThresholds.minBuildingsForVictory) {
                debugLog('BALANCE', 'WARNING: Approaching victory with insufficient buildings', {
                    planetaryConsciousness: gameState.planetaryConsciousness,
                    totalBuildings: totalBuildings,
                    required: balanceThresholds.minBuildingsForVictory
                });
            }

            // Lose conditions
            if (gameState.consciousness <= 0 && gameState.planetaryConsciousness <= 0) {
                debugLog('DEFEAT', 'Consciousness collapse defeat', {
                    consciousness: gameState.consciousness,
                    planetaryConsciousness: gameState.planetaryConsciousness
                });
                showGreatTransitionDefeat('consciousness_collapse');
                gameState.gameEnded = true;
                return true;
            }

            if (gameState.entropy >= 100) {
                debugLog('DEFEAT', 'Entropy overload defeat', { entropy: gameState.entropy });
                showGreatTransitionDefeat('entropy_overload');
                gameState.gameEnded = true;
                return true;
            }

            if (gameState.harmony <= 0) {
                debugLog('DEFEAT', 'Harmony collapse defeat', { harmony: gameState.harmony });
                showGreatTransitionDefeat('harmony_collapse');
                gameState.gameEnded = true;
                return true;
            }

            return false;
        };

        const showRulerVictory = () => {
            log('🚀 THE EXODUS BEGINS! 🚀', 'warning');
            log('═══════════════════════════════════════', 'info');
            log('🏛️ You have chosen the Path of the Rulers.', 'warning');
            log('🌌 The Exodus Ark rises from the dying planet, carrying the elite to the stars.', 'info');
            log('⚡ Behind you, the world burns under the weight of your industrial empire.', 'error');
            log('👥 The masses remain enslaved, their consciousness forever suppressed.', 'error');
            log('🌟 But you have joined the galactic empire - immortal rulers of the cosmos.', 'warning');
            log('═══════════════════════════════════════', 'info');
            log('💭 "Power corrupts, but absolute power... transcends."', 'grok');
            log('🔄 Will you choose differently next time?', 'info');

            createRulerVictoryCinematic();
            showRestartOption();
        };

        const showGardenerVictory = () => {
            log('🌟 THE GREAT ASCENSION! 🌟', 'success');
            log('═══════════════════════════════════════', 'info');
            log('🌱 You have chosen the Path of the Gardeners.', 'success');
            log('🌍 The planet awakens! Every being achieves consciousness.', 'success');
            log('✨ Harmony flows through all life as the old systems dissolve.', 'success');
            log('🦋 Humanity transcends its limitations, becoming one with the cosmos.', 'success');
            log('🌈 The age of separation ends. The age of unity begins.', 'success');
            log('═══════════════════════════════════════', 'info');
            log('💭 "In awakening others, we awaken ourselves."', 'grok');
            log('🎉 You have guided humanity to its highest potential!', 'success');

            createGardenerVictoryCinematic();
            showRestartOption();
        };

        const showGenericVictory = () => {
            log('🌟 THE GREAT TRANSITION ACHIEVED! 🌟', 'success');
            log('Planetary Consciousness has reached 100. Humanity has awakened from its slumber!', 'success');
            log('The age of unconscious suffering ends. The age of conscious evolution begins.', 'success');
            log('🎉 You have guided humanity through the greatest transformation in its history!', 'success');
            log('💡 Next time, try following one of the ancient paths for a deeper story experience.', 'info');

            createVictoryCelebration();
            showRestartOption();
        };

        const showGreatTransitionDefeat = (reason) => {
            const messages = {
                consciousness_collapse: {
                    title: '💀 CONSCIOUSNESS COLLAPSE',
                    description: 'The light of awareness has been extinguished. Humanity remains trapped in unconscious patterns.',
                    consequence: 'The rulers have won. The gardeners have failed.'
                },
                entropy_overload: {
                    title: '🌪️ ENTROPY OVERLOAD',
                    description: 'The system has become too chaotic and imbalanced to sustain life.',
                    consequence: 'Neither path succeeded. Chaos reigns supreme.'
                },
                harmony_collapse: {
                    title: '⚡ HARMONY COLLAPSE',
                    description: 'All balance has been lost. Society crumbles into conflict and despair.',
                    consequence: 'The foundation of civilization has shattered.'
                },
                totalitarian_victory: {
                    title: '👁️ TOTALITARIAN VICTORY',
                    description: 'The Ruler path has achieved total dominance. Individual consciousness has been eliminated.',
                    consequence: 'Humanity exists, but no longer as conscious beings. They are perfect slaves.'
                }
            };

            const message = messages[reason] || {
                title: '💔 THE GREAT TRANSITION FAILED',
                description: 'Humanity could not transcend its limitations.',
                consequence: 'The old patterns persist.'
            };

            log(message.title, 'error');
            log(message.description, 'error');
            log(message.consequence, 'warning');
            log('🔄 Click "New Game" to try a different path and learn from this outcome.', 'info');

            // Show restart option
            showRestartOption();
        };

        // --- TDD: Story Progression System ---

        const checkStoryProgression = () => {
            debugLog('STORY', 'Checking story progression', {
                phase: gameState.storyPhase,
                anomalyDiscovered: gameState.anomalyDiscovered,
                trueLoreRevealed: gameState.trueLoreRevealed,
                consciousness: gameState.consciousness,
                control: gameState.control,
                wisdom: gameState.wisdom,
                insight: gameState.insight
            });

            // Mid-game reveal: Discover the anomaly (using balanced thresholds)
            if (!gameState.anomalyDiscovered && gameState.storyPhase === 'early') {
                const totalBuildings = Object.values(gameState.rulerBuildings).reduce((sum, count) => sum + count, 0) +
                                     Object.values(gameState.gardenerBuildings).reduce((sum, count) => sum + count, 0);

                const anomalyThresholds = gameConfig.balance.storyProgression.anomalyTrigger;

                debugLog('STORY', 'Checking anomaly trigger', {
                    totalBuildings: totalBuildings,
                    consciousnessControlSum: gameState.consciousness + gameState.control,
                    threshold: `buildings >= ${anomalyThresholds.minBuildings} OR consciousness+control >= ${anomalyThresholds.minResourceSum}`
                });

                if (totalBuildings >= anomalyThresholds.minBuildings ||
                    gameState.consciousness + gameState.control >= anomalyThresholds.minResourceSum) {
                    debugLog('STORY', 'Anomaly trigger conditions met!');
                    triggerAnomalyDiscovery();
                }
            }

            // True lore reveal after anomaly investigation (using balanced thresholds)
            if (gameState.anomalyDiscovered && !gameState.trueLoreRevealed && gameState.storyPhase === 'midgame_reveal') {
                const loreThresholds = gameConfig.balance.storyProgression.loreReveal;

                debugLog('STORY', 'Checking lore reveal trigger', {
                    wisdom: gameState.wisdom,
                    insight: gameState.insight,
                    threshold: `wisdom >= ${loreThresholds.minWisdom} AND insight >= ${loreThresholds.minInsight}`
                });

                if (gameState.wisdom >= loreThresholds.minWisdom && gameState.insight >= loreThresholds.minInsight) {
                    debugLog('STORY', 'Lore reveal conditions met!');
                    revealTrueLore();
                }
            }

            // Update dominant path
            updateDominantPath();
        };

        const triggerAnomalyDiscovery = () => {
            debugLog('STORY', 'Triggering anomaly discovery', {
                consciousness: gameState.consciousness,
                control: gameState.control,
                totalBuildings: Object.values(gameState.rulerBuildings).reduce((sum, count) => sum + count, 0) +
                               Object.values(gameState.gardenerBuildings).reduce((sum, count) => sum + count, 0)
            });

            gameState.anomalyDiscovered = true;
            gameState.storyPhase = 'midgame_reveal';

            log('🌟 DISCOVERY: An ancient monolith has been unearthed!', 'success');
            log('📜 Strange symbols pulse with otherworldly energy. This artifact predates known civilization.', 'info');
            log('🔍 Research this anomaly to uncover the truth about your world\'s history.', 'warning');
            log('💡 Hint: Accumulate Wisdom and Insight to decode the monolith\'s secrets.', 'info');

            // Add research bonus
            gameState.wisdomPerSecond += 0.1;
            gameState.insightPerSecond += 0.1;

            debugLog('STORY', 'Anomaly discovery complete', {
                newPhase: gameState.storyPhase,
                wisdomRate: gameState.wisdomPerSecond,
                insightRate: gameState.insightPerSecond
            });
        };

        const revealTrueLore = () => {
            gameState.trueLoreRevealed = true;
            gameState.storyPhase = 'endgame';

            log('🌟 THE TRUTH REVEALED! 🌟', 'success');
            log('📜 The monolith speaks: "Two paths diverged in the cosmic wood..."', 'grok');
            log('🏛️ THE RULERS: Ancient galactic empire builders who seek dominion through control.', 'warning');
            log('🌱 THE GARDENERS: Consciousness cultivators who nurture awakening and harmony.', 'success');
            log('⚡ Your choices have aligned you with one of these ancient factions.', 'info');
            log('🎯 Choose your final destiny: Escape via Exodus Ark or achieve The Great Ascension.', 'warning');

            // Unlock victory buildings
            log('🔓 Ultimate technologies now available in the Paths tab!', 'info');
        };

        const updateDominantPath = () => {
            const rulerChoices = gameState.statistics.rulerPathChoices || 0;
            const gardenerChoices = gameState.statistics.gardenerPathChoices || 0;
            const totalChoices = rulerChoices + gardenerChoices;

            if (totalChoices === 0) {
                gameState.dominantPath = 'none';
            } else {
                const rulerRatio = rulerChoices / totalChoices;
                if (rulerRatio > 0.6) {
                    gameState.dominantPath = 'ruler';
                } else if (rulerRatio < 0.4) {
                    gameState.dominantPath = 'gardener';
                } else {
                    gameState.dominantPath = 'balanced';
                }
            }
        };

        const createRulerVictoryCinematic = () => {
            // TODO: Add dark, industrial visual effects
            log('🔥 The sky burns red as the Exodus Ark departs...', 'error');
            log('🏭 Smokestacks pierce the polluted horizon...', 'warning');
            log('👁️ The surveillance towers stand eternal, watching over the enslaved masses...', 'error');
        };

        const createGardenerVictoryCinematic = () => {
            // TODO: Add beautiful, natural visual effects
            log('🌸 Flowers bloom across the awakened landscape...', 'success');
            log('🦋 Consciousness flows like light through every living being...', 'success');
            log('🌈 The planet itself seems to sing with joy...', 'success');
        };

        // --- TDD: Four Horsemen Crisis System ---

        const fourHorsemenConfig = {
            war: {
                name: "War",
                description: "Conflict erupts across the land. Military forces clash, destroying harmony and consuming resources.",
                triggerLevel: 25,
                effects: {
                    harmony: -20,
                    energy: -15,
                    entropy: 10
                },
                duration: 30000, // 30 seconds
                icon: "⚔️",
                color: "red"
            },
            famine: {
                name: "Famine",
                description: "Crops fail and food becomes scarce. The population suffers as resources dwindle.",
                triggerLevel: 40,
                effects: {
                    energy: -25,
                    harmony: -15,
                    consciousness: -5
                },
                duration: 45000, // 45 seconds
                icon: "🌾",
                color: "orange"
            },
            pestilence: {
                name: "Pestilence",
                description: "Disease spreads through the population. Fear and suffering cloud the collective consciousness.",
                triggerLevel: 60,
                effects: {
                    consciousness: -20,
                    harmony: -10,
                    entropy: 15
                },
                duration: 40000, // 40 seconds
                icon: "🦠",
                color: "green"
            },
            death: {
                name: "Death",
                description: "The ultimate crisis. Despair grips the world as hope itself begins to fade.",
                triggerLevel: 80,
                effects: {
                    consciousness: -30,
                    harmony: -25,
                    planetaryConsciousness: -20,
                    entropy: 25
                },
                duration: 60000, // 60 seconds
                icon: "💀",
                color: "black"
            }
        };

        // --- TDD: Cosmic Threat System (External Enemies) ---

        const cosmicThreatConfig = {
            voidDevourers: {
                name: "Void Devourers",
                description: "Ancient entities from beyond reality consume consciousness itself. Only unified wisdom can repel them.",
                effects: { consciousness: -30, planetaryConsciousness: -25, harmony: -20 },
                duration: 300000, // 5 minutes
                triggerLevel: 70, // High integration needed to trigger
                icon: '🌑',
                color: '#000000',
                requiresAlliance: true
            },
            stellarTyrants: {
                name: "Stellar Tyrants",
                description: "Galactic empire seeks to enslave the sanctuary. Requires both wisdom and strength to resist.",
                effects: { control: -25, energy: -30, insight: -20 },
                duration: 360000, // 6 minutes
                triggerLevel: 80,
                icon: '👑',
                color: '#7C2D12',
                requiresAlliance: true
            },
            entropyStorm: {
                name: "Entropy Storm",
                description: "Cosmic chaos threatens to unravel reality. Perfect balance of order and consciousness needed.",
                effects: { entropy: 50, harmony: -40, planetaryConsciousness: -30 },
                duration: 420000, // 7 minutes
                triggerLevel: 90,
                icon: '🌪️',
                color: '#581C87',
                requiresAlliance: true
            }
        };

        // --- TDD: Alliance & Integration System ---

        const checkAllianceFormation = () => {
            if (gameState.allianceFormed) return;

            // Alliance forms when both player and AI have significant progress
            const playerGardenerProgress = Object.values(gameState.gardenerBuildings).reduce((sum, count) => sum + count, 0);
            const aiRulerProgress = Object.values(gameState.aiPlayer.buildings).reduce((sum, count) => sum + count, 0);

            // Use config thresholds for alliance formation
            const thresholds = gameConfig.balance.allianceFormationThreshold;
            if (playerGardenerProgress >= thresholds.playerBuildings &&
                aiRulerProgress >= thresholds.aiBuildings &&
                gameState.consciousness >= thresholds.playerConsciousness &&
                gameState.aiPlayer.resources.control >= thresholds.aiControl) {

                formAlliance();
            }
        };

        const formAlliance = () => {
            gameState.allianceFormed = true;
            gameState.integrationLevel = 25; // Start with basic integration

            log('🤝 THE GREAT ALLIANCE FORMS!', 'success');
            log('═══════════════════════════════════════', 'info');
            log('🏛️ The Rulers offer their strength and organization.', 'warning');
            log('🌱 The Gardeners share their wisdom and consciousness.', 'success');
            log('⚡ Together, you face the cosmic threats that no single path could overcome.', 'info');
            log('🌟 Integration Level: 25% - The alliance is fragile but growing.', 'grok');
            log('═══════════════════════════════════════', 'info');

            // Unlock cosmic threat monitoring
            gameState.cosmicThreatActive = true;

            // Enable alliance mode
            const allianceModeBtn = document.getElementById('alliance-mode-btn');
            if (allianceModeBtn) allianceModeBtn.style.display = 'inline-block';
        };

        // --- TDD: Shared Screen Multiplayer System ---

        const switchPlayer = (newPlayer) => {
            if (gameState.allianceFormed && newPlayer === 'alliance') {
                gameState.currentPlayer = 'alliance';
                updatePlayerUI();
                log('🤝 Alliance Mode: Both players can act simultaneously!', 'info');
                return;
            }

            if (newPlayer !== gameState.currentPlayer) {
                gameState.currentPlayer = newPlayer;
                updatePlayerUI();

                const playerName = newPlayer === 'gardener' ? 'Gardener' : 'Ruler';
                const icon = newPlayer === 'gardener' ? '🌱' : '🏛️';
                log(`${icon} ${playerName} player is now active`, 'info');
            }
        };

        const updatePlayerUI = () => {
            const gardenerBtn = document.getElementById('gardener-player-btn');
            const rulerBtn = document.getElementById('ruler-player-btn');
            const allianceBtn = document.getElementById('alliance-mode-btn');
            const indicator = document.getElementById('current-player-indicator');

            // Reset button styles
            if (gardenerBtn) {
                gardenerBtn.className = 'px-3 py-1 text-xs rounded transition-all bg-gray-700 text-gray-300 border border-gray-600 hover:bg-gray-600';
            }
            if (rulerBtn) {
                rulerBtn.className = 'px-3 py-1 text-xs rounded transition-all bg-gray-700 text-gray-300 border border-gray-600 hover:bg-gray-600';
            }
            if (allianceBtn) {
                allianceBtn.className = 'px-3 py-1 text-xs rounded transition-all bg-gray-700 text-gray-300 border border-gray-600 hover:bg-gray-600';
            }

            // Highlight active player
            if (gameState.currentPlayer === 'gardener' && gardenerBtn) {
                gardenerBtn.className = 'px-3 py-1 text-xs rounded transition-all bg-green-700 text-green-200 border border-green-600 hover:bg-green-600';
                if (indicator) indicator.innerHTML = '🌱 Gardener\'s Turn';
            } else if (gameState.currentPlayer === 'ruler' && rulerBtn) {
                rulerBtn.className = 'px-3 py-1 text-xs rounded transition-all bg-orange-700 text-orange-200 border border-orange-600 hover:bg-orange-600';
                if (indicator) indicator.innerHTML = '🏛️ Ruler\'s Turn';
            } else if (gameState.currentPlayer === 'alliance' && allianceBtn) {
                allianceBtn.className = 'px-3 py-1 text-xs rounded transition-all bg-purple-700 text-purple-200 border border-purple-600 hover:bg-purple-600';
                if (indicator) indicator.innerHTML = '🤝 Alliance Mode';
            }
        };

        const canPlayerAct = (actionType) => {
            // In alliance mode, both players can act
            if (gameState.currentPlayer === 'alliance') return true;

            // Check if action is appropriate for current player
            if (actionType === 'gardener' && gameState.currentPlayer === 'gardener') return true;
            if (actionType === 'ruler' && gameState.currentPlayer === 'ruler') return true;
            if (actionType === 'neutral') return true; // Neutral actions like moving units

            return false;
        };

        // --- TDD: AI Player System ---

        const trackUserActivity = () => {
            gameState.lastUserAction = Date.now();
        };

        const isUserInactive = () => {
            return (Date.now() - gameState.lastUserAction) > gameState.userInactiveThreshold;
        };

        const updateAIPlayer = () => {
            if (!gameState.aiEnabled || gameState.allianceFormed) return;

            const now = Date.now();
            const inactive = isUserInactive();

            // Adjust AI behavior based on user activity
            const currentCooldown = inactive ? gameState.aiPlayer.inactiveActionCooldown : gameState.aiPlayer.actionCooldown;
            if (now - gameState.aiPlayer.lastAction < currentCooldown) return;

            // Increase AI aggressiveness when user is inactive
            if (inactive) {
                gameState.aiPlayer.aggressiveness = Math.min(3.0, gameState.aiPlayer.aggressiveness + 0.1);

                // Send occasional messages to encourage user engagement
                if (now - gameState.aiPlayer.lastMessage > 30000) { // Every 30 seconds
                    sendAIMessage();
                    gameState.aiPlayer.lastMessage = now;
                }
            } else {
                gameState.aiPlayer.aggressiveness = Math.max(1.0, gameState.aiPlayer.aggressiveness - 0.05);
            }

            // AI resource generation (faster when user inactive, from config)
            const resourceMultiplier = inactive ? gameState.aiPlayer.aggressiveness : 1.0;
            gameState.aiPlayer.resources.energy += gameConfig.aiPlayer.resourceGenerationRate.energy * resourceMultiplier;
            gameState.aiPlayer.resources.insight += gameConfig.aiPlayer.resourceGenerationRate.insight * resourceMultiplier;
            gameState.aiPlayer.resources.control += gameConfig.aiPlayer.resourceGenerationRate.control * resourceMultiplier;

            // AI decision making
            makeAIDecision();
            gameState.aiPlayer.lastAction = now;
        };

        const makeAIDecision = () => {
            const ai = gameState.aiPlayer;

            // Prioritize based on current situation
            const decisions = [];

            // Check if AI can build ruler buildings
            for (const [key, building] of Object.entries(rulerPathBuildings)) {
                if (ai.resources[building.costResource] >= building.cost) {
                    if (!building.unlockCondition || building.unlockCondition()) {
                        decisions.push({
                            type: 'build',
                            building: key,
                            priority: calculateBuildingPriority(building, ai.strategy)
                        });
                    }
                }
            }

            // Check if AI should create units
            if (ai.resources.energy >= 20) {
                decisions.push({
                    type: 'unit',
                    unitType: 'dreamer',
                    priority: 3
                });
            }
            if (ai.resources.insight >= 20) {
                decisions.push({
                    type: 'unit',
                    unitType: 'weaver',
                    priority: 3
                });
            }

            // Execute highest priority decision
            if (decisions.length > 0) {
                decisions.sort((a, b) => b.priority - a.priority);
                executeAIDecision(decisions[0]);
            }
        };

        const calculateBuildingPriority = (building, strategy) => {
            let priority = 1;

            // Base priority on building tier
            if (building.tier) priority += building.tier;

            // Strategy modifiers
            if (strategy === 'aggressive') {
                if (building.effects.control) priority += 2;
                if (building.effects.energy) priority += 1;
            } else if (strategy === 'defensive') {
                if (building.effects.harmony) priority += 2;
                if (building.effects.consciousness) priority += 1;
            }

            // Crisis response
            if (gameState.activeCrises.length > 0) {
                priority += 3; // Prioritize building during crises
            }

            return priority;
        };

        const executeAIDecision = (decision) => {
            const ai = gameState.aiPlayer;

            if (decision.type === 'build') {
                const building = rulerPathBuildings[decision.building];
                if (ai.resources[building.costResource] >= building.cost) {
                    ai.resources[building.costResource] -= building.cost;

                    // Track AI buildings separately
                    if (!ai.buildings[decision.building]) ai.buildings[decision.building] = 0;
                    ai.buildings[decision.building]++;

                    // Apply effects to global state (AI affects the world)
                    applyBuildingEffects(building.effects);

                    // Update global ruler buildings for alliance calculation
                    gameState.rulerBuildings[decision.building] = (gameState.rulerBuildings[decision.building] || 0) + 1;

                    log(`🏛️ AI Ruler built ${building.name}! The path of control strengthens.`, 'warning');

                    // AI communication based on building type
                    if (building.tier >= 3) {
                        log(`🏛️ "Our empire grows stronger. Perhaps cooperation would benefit us both?" - AI Ruler`, 'grok');
                    }

                    // Check for alliance formation
                    checkAllianceFormation();
                }
            } else if (decision.type === 'unit') {
                if (decision.unitType === 'dreamer' && ai.resources.energy >= 20) {
                    ai.resources.energy -= 20;
                    createAIUnit('dreamer');
                } else if (decision.unitType === 'weaver' && ai.resources.insight >= 20) {
                    ai.resources.insight -= 20;
                    createAIUnit('weaver');
                }
            }
        };

        const createAIUnit = (type) => {
            // Create unit in a different area from player
            const aiZoneX = canvasState.width * 0.7 + Math.random() * 200;
            const aiZoneY = canvasState.height * 0.3 + Math.random() * 200;

            addSprite(type, 1, aiZoneX, aiZoneY);

            // Mark the last created unit as AI-owned
            const lastUnit = gameState.villageGrid[gameState.villageGrid.length - 1];
            if (lastUnit) {
                lastUnit.owner = 'ruler';
                lastUnit.isAI = true;
            }

            log(`🏛️ AI Ruler summoned a ${type}!`, 'warning');
        };

        const sendAIMessage = () => {
            const inactive = isUserInactive();
            const messages = {
                encouragement: [
                    "🏛️ \"The sanctuary grows quiet. Are you still there, Gardener?\"",
                    "🏛️ \"While you rest, I continue building our empire. Will you join me?\"",
                    "🏛️ \"The cosmic forces stir. Your guidance is needed.\"",
                    "🏛️ \"I sense your presence fading. The balance requires both our paths.\""
                ],
                progress: [
                    "🏛️ \"My industrial might grows. Soon we shall be ready for alliance.\"",
                    "🏛️ \"The foundations of order are laid. What of your consciousness path?\"",
                    "🏛️ \"Control systems online. The sanctuary awaits your wisdom.\"",
                    "🏛️ \"My surveillance networks detect cosmic disturbances. We must prepare.\""
                ],
                crisis: [
                    "🏛️ \"Crisis approaches! Your consciousness is needed to balance my control.\"",
                    "🏛️ \"The entropy rises. Only together can we face what comes.\"",
                    "🏛️ \"External threats gather. Will you stand with me, Gardener?\""
                ],
                alliance: [
                    "🏛️ \"The time for alliance draws near. Are you ready to unite our paths?\"",
                    "🏛️ \"Together we are stronger than apart. Consider my proposal.\"",
                    "🏛️ \"The cosmic threats require both order and consciousness. Join me.\""
                ]
            };

            let messageType = 'encouragement';

            if (gameState.crisisLevel > 50) {
                messageType = 'crisis';
            } else if (gameState.aiPlayer.resources.control > 40) {
                messageType = 'alliance';
            } else if (!inactive) {
                messageType = 'progress';
            }

            const messageArray = messages[messageType];
            const message = messageArray[Math.floor(Math.random() * messageArray.length)];

            log(message, 'grok');
        };

        const initializePlayerSwitching = () => {
            const gardenerBtn = document.getElementById('gardener-player-btn');
            const rulerBtn = document.getElementById('ruler-player-btn');
            const allianceBtn = document.getElementById('alliance-mode-btn');

            if (gardenerBtn) {
                gardenerBtn.addEventListener('click', () => switchPlayer('gardener'));
            }
            if (rulerBtn) {
                rulerBtn.addEventListener('click', () => switchPlayer('ruler'));
            }
            if (allianceBtn) {
                allianceBtn.addEventListener('click', () => switchPlayer('alliance'));
            }

            // Initialize UI
            updatePlayerUI();
        };

        const updateIntegrationLevel = () => {
            if (!gameState.allianceFormed) return;

            // Integration grows based on balanced development
            const rulerStrength = gameState.control + Object.values(gameState.rulerBuildings).reduce((sum, count) => sum + count, 0) * 5;
            const gardenerWisdom = gameState.consciousness + Object.values(gameState.gardenerBuildings).reduce((sum, count) => sum + count, 0) * 5;

            // Perfect balance increases integration faster
            const balance = 1 - Math.abs(rulerStrength - gardenerWisdom) / Math.max(rulerStrength, gardenerWisdom, 1);
            const integrationGrowth = balance * 0.1; // Up to 0.1% per update

            gameState.integrationLevel = Math.min(100, gameState.integrationLevel + integrationGrowth);

            // Milestones
            if (gameState.integrationLevel >= 50 && !gameState.integrationMilestone50) {
                gameState.integrationMilestone50 = true;
                log('🌟 Integration Level: 50% - The alliance strengthens! Cosmic defenses improve.', 'success');
            }
            if (gameState.integrationLevel >= 75 && !gameState.integrationMilestone75) {
                gameState.integrationMilestone75 = true;
                log('🌟 Integration Level: 75% - Near-perfect synthesis! Reality itself bends to your will.', 'success');
            }
        };

        const updateCrisisLevel = () => {
            // Calculate crisis level based on negative factors
            let crisisFactors = 0;

            // High entropy increases crisis
            crisisFactors += gameState.entropy * 0.5;

            // Low harmony increases crisis
            if (gameState.harmony < 50) {
                crisisFactors += (50 - gameState.harmony) * 0.3;
            }

            // Imbalanced paths increase crisis (but less if alliance formed)
            const pathImbalance = Math.abs(gameState.statistics.rulerPathChoices - gameState.statistics.gardenerPathChoices);
            const imbalancePenalty = gameState.allianceFormed ? pathImbalance * 0.2 : pathImbalance * 0.5;
            crisisFactors += imbalancePenalty;

            // Low consciousness increases crisis
            if (gameState.consciousness < 30) {
                crisisFactors += (30 - gameState.consciousness) * 0.2;
            }

            gameState.crisisLevel = Math.min(100, Math.max(0, crisisFactors));

            // Calculate external threat level (only if alliance formed)
            if (gameState.allianceFormed) {
                gameState.externalThreatLevel = Math.min(100, gameState.integrationLevel + gameState.crisisLevel * 0.5);
            }
        };

        const checkForNewCrises = () => {
            const now = Date.now();

            // Don't trigger crises too frequently
            if (now - gameState.lastCrisisTime < 60000) { // 1 minute cooldown
                return;
            }

            // Check cosmic threats first (if alliance formed)
            if (gameState.allianceFormed && gameState.cosmicThreatActive) {
                for (const [key, threat] of Object.entries(cosmicThreatConfig)) {
                    // Skip if already active or defeated
                    if (gameState.activeCrises.some(c => c.type === key) ||
                        gameState.horsemenDefeated.includes(key)) {
                        continue;
                    }

                    // Check if external threat level is high enough
                    if (gameState.externalThreatLevel >= threat.triggerLevel) {
                        // Lower chance for cosmic threats (10% per check)
                        if (Math.random() < 0.1) {
                            triggerCosmicThreat(key, threat);
                            gameState.lastCrisisTime = now;
                            return; // Only one crisis at a time
                        }
                    }
                }
            }

            // Check each horseman (regular crises)
            for (const [key, horseman] of Object.entries(fourHorsemenConfig)) {
                // Skip if already active or defeated
                if (gameState.activeCrises.some(c => c.type === key) ||
                    gameState.horsemenDefeated.includes(key)) {
                    continue;
                }

                // Check if crisis level is high enough
                if (gameState.crisisLevel >= horseman.triggerLevel) {
                    // Random chance to trigger (20% per check)
                    if (Math.random() < 0.2) {
                        triggerCrisis(key, horseman);
                        gameState.lastCrisisTime = now;
                        break; // Only one crisis at a time
                    }
                }
            }
        };

        const triggerCrisis = (type, config) => {
            const crisis = {
                type: type,
                name: config.name,
                description: config.description,
                effects: config.effects,
                startTime: Date.now(),
                duration: config.duration,
                icon: config.icon,
                color: config.color,
                resolved: false,
                isCosmicThreat: false
            };

            gameState.activeCrises.push(crisis);

            log(`${config.icon} CRISIS: ${config.name.toUpperCase()}!`, 'error');
            log(config.description, 'warning');
            log('🛡️ Build appropriate structures or make strategic choices to resolve this crisis!', 'info');

            // Apply immediate effects
            applyCrisisEffects(crisis.effects);

            // Start crisis resolution timer
            setTimeout(() => {
                if (!crisis.resolved) {
                    resolveCrisisAutomatically(crisis);
                }
            }, config.duration);
        };

        const triggerCosmicThreat = (type, config) => {
            const threat = {
                type: type,
                name: config.name,
                description: config.description,
                effects: config.effects,
                startTime: Date.now(),
                duration: config.duration,
                icon: config.icon,
                color: config.color,
                resolved: false,
                isCosmicThreat: true,
                requiresAlliance: config.requiresAlliance
            };

            gameState.activeCrises.push(threat);

            log(`${config.icon} COSMIC THREAT: ${config.name.toUpperCase()}!`, 'error');
            log('🌌 An external force threatens the sanctuary!', 'error');
            log(config.description, 'warning');
            log('⚡ Only the combined strength of Rulers and Gardeners can overcome this threat!', 'info');

            // Apply immediate effects (more severe than regular crises)
            applyCrisisEffects(threat.effects);

            // Cosmic threats last longer and are harder to resolve
            setTimeout(() => {
                if (!threat.resolved) {
                    resolveCosmicThreatAutomatically(threat);
                }
            }, config.duration);
        };

        const applyCrisisEffects = (effects) => {
            for (const [resource, amount] of Object.entries(effects)) {
                if (gameState[resource] !== undefined) {
                    gameState[resource] = Math.max(0, gameState[resource] + amount);
                }
            }
        };

        const resolveCrisisAutomatically = (crisis) => {
            // Remove from active crises
            gameState.activeCrises = gameState.activeCrises.filter(c => c !== crisis);

            log(`${crisis.icon} Crisis "${crisis.name}" has passed, but its effects linger...`, 'warning');

            // Apply lingering negative effects
            const lingeringEffects = {};
            for (const [resource, amount] of Object.entries(crisis.effects)) {
                lingeringEffects[resource] = amount * 0.3; // 30% of original effect
            }
            applyCrisisEffects(lingeringEffects);
        };

        const resolveCosmicThreatAutomatically = (threat) => {
            // Remove from active crises
            gameState.activeCrises = gameState.activeCrises.filter(c => c !== threat);

            log(`${threat.icon} Cosmic threat "${threat.name}" overwhelms the sanctuary...`, 'error');
            log('💔 The alliance was not strong enough. Reality itself suffers.', 'error');

            // Apply severe lingering effects
            const severeEffects = {};
            for (const [resource, amount] of Object.entries(threat.effects)) {
                severeEffects[resource] = amount * 0.8; // 80% of original effect lingers
            }
            applyCrisisEffects(severeEffects);

            // Damage integration level
            gameState.integrationLevel = Math.max(0, gameState.integrationLevel - 20);
        };

        const resolveCrisisManually = (crisisType) => {
            const crisis = gameState.activeCrises.find(c => c.type === crisisType);
            if (!crisis) return false;

            crisis.resolved = true;
            gameState.activeCrises = gameState.activeCrises.filter(c => c !== crisis);
            gameState.horsemenDefeated.push(crisisType);

            log(`${crisis.icon} Crisis "${crisis.name}" has been resolved through your actions!`, 'success');
            log('🏆 You have defeated one of the Four Horsemen!', 'success');

            // Reward for manual resolution
            gameState.wisdom += 10;
            gameState.consciousness += 5;
            gameState.harmony += 10;

            return true;
        };

        const checkCrisisResolution = () => {
            for (const crisis of gameState.activeCrises) {
                if (crisis.resolved) continue;

                let canResolve = false;

                if (crisis.isCosmicThreat) {
                    // Cosmic threats require alliance and high integration
                    switch (crisis.type) {
                        case 'voidDevourers':
                            canResolve = gameState.allianceFormed &&
                                       gameState.integrationLevel >= 60 &&
                                       gameState.consciousness > 80 &&
                                       gameState.gardenerBuildings.planetaryAwakening > 0;
                            break;
                        case 'stellarTyrants':
                            canResolve = gameState.allianceFormed &&
                                       gameState.integrationLevel >= 70 &&
                                       gameState.control > 70 &&
                                       gameState.rulerBuildings.totalitarianCore > 0 &&
                                       gameState.gardenerBuildings.wisdomSanctuary > 1;
                            break;
                        case 'entropyStorm':
                            canResolve = gameState.allianceFormed &&
                                       gameState.integrationLevel >= 90 &&
                                       gameState.harmony > 85 &&
                                       gameState.planetaryConsciousness > 90;
                            break;
                    }
                } else {
                    // Regular Four Horsemen crises
                    switch (crisis.type) {
                        case 'war':
                            // Can be resolved by either path, but alliance makes it easier
                            canResolve = gameState.harmony > 70 ||
                                       gameState.gardenerBuildings.communityCouncil > 0 ||
                                       (gameState.allianceFormed && gameState.integrationLevel >= 30);
                            break;
                        case 'famine':
                            // Resolve with sustainable agriculture from either path
                            canResolve = gameState.gardenerBuildings.permacultureGarden > 1 ||
                                       gameState.rulerBuildings.automatedAgriculture > 2 ||
                                       (gameState.allianceFormed && gameState.integrationLevel >= 40);
                            break;
                        case 'pestilence':
                            // Resolve with healing structures or high consciousness
                            canResolve = gameState.gardenerBuildings.healingGrove > 1 ||
                                       gameState.consciousness > 60 ||
                                       (gameState.allianceFormed && gameState.integrationLevel >= 35);
                            break;
                        case 'death':
                            // Resolve with high planetary consciousness or ascension buildings
                            canResolve = gameState.planetaryConsciousness > 80 ||
                                       gameState.gardenerBuildings.planetaryAwakening > 0 ||
                                       (gameState.allianceFormed && gameState.integrationLevel >= 50);
                            break;
                    }
                }

                if (canResolve) {
                    resolveCrisisManually(crisis.type);

                    // Successful crisis resolution improves integration
                    if (gameState.allianceFormed) {
                        const integrationBonus = crisis.isCosmicThreat ? 10 : 5;
                        gameState.integrationLevel = Math.min(100, gameState.integrationLevel + integrationBonus);
                        log(`🌟 Alliance strengthened! Integration Level: ${Math.round(gameState.integrationLevel)}%`, 'success');
                    }
                }
            }
        };

        const createVictoryCelebration = () => {
            // Add visual celebration effects to the canvas
            // TODO: Implement particle effects, color changes, etc.
            log('✨ The sanctuary glows with the light of awakened consciousness...', 'success');
        };

        const showRestartOption = () => {
            // Add a game ended overlay and restart button
            setTimeout(() => {
                // Create overlay
                const overlay = document.createElement('div');
                overlay.className = 'fixed top-0 left-0 w-full h-full bg-black bg-opacity-50 flex items-center justify-center z-50';
                overlay.innerHTML = `
                    <div class="bg-gray-800 border border-gray-600 rounded-lg p-6 max-w-md mx-4 text-center">
                        <h3 class="text-xl font-bold text-white mb-4">🎮 Game Complete</h3>
                        <p class="text-gray-300 mb-6">The Great Transition has concluded. Your choices have shaped humanity's destiny.</p>
                        <div class="space-y-3">
                            <button id="new-game-btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white py-2 px-4 rounded transition-colors">
                                🔄 Start New Game
                            </button>
                            <button id="continue-exploring-btn" class="w-full bg-gray-600 hover:bg-gray-700 text-white py-2 px-4 rounded transition-colors">
                                🔍 Continue Exploring
                            </button>
                        </div>
                    </div>
                `;

                // Add event listeners
                overlay.querySelector('#new-game-btn').onclick = () => {
                    if (confirm('Start a new game? This will reset all progress.')) {
                        startNewGame();
                    }
                };

                overlay.querySelector('#continue-exploring-btn').onclick = () => {
                    overlay.remove();
                };

                document.body.appendChild(overlay);
            }, 3000); // Show after 3 seconds
        };

        const startNewGame = () => {
            if (confirm('🔄 Start a completely new game?\n\nThis will:\n• Clear all saved progress\n• Reset all resources to starting values\n• Remove all buildings and units\n• Reset story progression\n\nThis cannot be undone!')) {

                // Clear all localStorage data
                localStorage.removeItem('terraflow_save_data');
                localStorage.removeItem('terraflow_save');
                localStorage.removeItem('terraflow_achievements');
                localStorage.removeItem('terraflow_goals');

                log('🔄 Clearing saved data and restarting...', 'info');

                // Reload the page to start completely fresh
                setTimeout(() => {
                    location.reload();
                }, 500);
            }
        };

        // --- TDD: Save/Load System ---

        const SAVE_KEY = 'terraflow_save_data';
        const CURRENT_SAVE_VERSION = "1.0.0";

        const saveGameState = () => {
            try {
                const saveData = {
                    version: CURRENT_SAVE_VERSION,
                    timestamp: Date.now(),
                    gameState: {
                        // Core resources
                        energy: gameState.energy,
                        insight: gameState.insight,
                        harmony: gameState.harmony,
                        inspiration: gameState.inspiration,
                        wisdom: gameState.wisdom,
                        control: gameState.control,
                        consciousness: gameState.consciousness,
                        planetaryConsciousness: gameState.planetaryConsciousness,
                        entropy: gameState.entropy,

                        // Per-second rates
                        energyPerSecond: gameState.energyPerSecond,
                        insightPerSecond: gameState.insightPerSecond,
                        inspirationPerSecond: gameState.inspirationPerSecond,
                        wisdomPerSecond: gameState.wisdomPerSecond,
                        controlPerSecond: gameState.controlPerSecond,
                        consciousnessPerSecond: gameState.consciousnessPerSecond,

                        // Units and buildings
                        units: { ...gameState.units },
                        nodes: { ...gameState.nodes },
                        nodeCosts: { ...gameState.nodeCosts },
                        rulerBuildings: { ...gameState.rulerBuildings },
                        gardenerBuildings: { ...gameState.gardenerBuildings },
                        techTreeUnlocked: gameState.techTreeUnlocked,
                        gameEnded: gameState.gameEnded,

                        // Story progression
                        storyPhase: gameState.storyPhase,
                        anomalyDiscovered: gameState.anomalyDiscovered,
                        trueLoreRevealed: gameState.trueLoreRevealed,
                        rulerPathProgress: gameState.rulerPathProgress,
                        gardenerPathProgress: gameState.gardenerPathProgress,
                        dominantPath: gameState.dominantPath,

                        // Crisis system
                        crisisLevel: gameState.crisisLevel,
                        activeCrises: gameState.activeCrises,
                        horsemenDefeated: gameState.horsemenDefeated,
                        lastCrisisTime: gameState.lastCrisisTime,

                        // Progress tracking
                        achievements: {
                            unlocked: [...gameState.achievements.unlocked],
                            progress: { ...gameState.achievements.progress },
                            definitions: gameState.achievements.definitions
                        },
                        goals: {
                            active: gameState.goals.active.map(goal => ({ ...goal })),
                            completed: [...gameState.goals.completed],
                            available: gameState.goals.available.map(goal => ({ ...goal })),
                            milestones: gameState.goals.milestones.map(milestone => ({ ...milestone }))
                        },
                        statistics: { ...gameState.statistics },
                        playerTitles: [...gameState.playerTitles],

                        // Game state
                        villageGrid: gameState.villageGrid.map(unit => ({ ...unit })),
                        intelligentCreatures: gameState.intelligentCreatures.map(creature => ({ ...creature })),
                        conversationalUnits: gameState.conversationalUnits.map(unit => ({ ...unit })),

                        // Settings
                        autoSaveEnabled: gameState.autoSaveEnabled
                    }
                };

                localStorage.setItem(SAVE_KEY, JSON.stringify(saveData));
                gameState.lastSaved = Date.now();

                log('💾 Game progress saved successfully!', 'success');
                return true;
            } catch (error) {
                console.error('Failed to save game:', error);
                log('❌ Failed to save game progress. Please try again.', 'error');
                return false;
            }
        };

        const loadGameState = () => {
            try {
                const savedData = localStorage.getItem(SAVE_KEY);
                if (!savedData) {
                    log('📁 No saved game found. Starting fresh!', 'info');
                    return false;
                }

                const saveData = JSON.parse(savedData);

                // Check save version compatibility
                if (!saveData.version || saveData.version !== CURRENT_SAVE_VERSION) {
                    log('⚠️ Save file from different version detected. Attempting migration...', 'warning');
                    return migrateSaveData(saveData);
                }

                // Restore game state
                const saved = saveData.gameState;

                // Core resources
                gameState.energy = saved.energy || 20;
                gameState.insight = saved.insight || 5;
                gameState.harmony = saved.harmony || 50;
                gameState.inspiration = saved.inspiration || 0;
                gameState.wisdom = saved.wisdom || 0;
                gameState.control = saved.control || 0;
                gameState.consciousness = saved.consciousness || 10;
                gameState.planetaryConsciousness = saved.planetaryConsciousness || 10;
                gameState.entropy = saved.entropy || 0;

                // Per-second rates
                gameState.energyPerSecond = saved.energyPerSecond || 0;
                gameState.insightPerSecond = saved.insightPerSecond || 0;
                gameState.inspirationPerSecond = saved.inspirationPerSecond || 0;
                gameState.wisdomPerSecond = saved.wisdomPerSecond || 0;
                gameState.controlPerSecond = saved.controlPerSecond || 0;
                gameState.consciousnessPerSecond = saved.consciousnessPerSecond || 0;

                // Units and buildings
                if (saved.units) Object.assign(gameState.units, saved.units);
                if (saved.nodes) Object.assign(gameState.nodes, saved.nodes);
                if (saved.nodeCosts) Object.assign(gameState.nodeCosts, saved.nodeCosts);
                if (saved.rulerBuildings) Object.assign(gameState.rulerBuildings, saved.rulerBuildings);
                if (saved.gardenerBuildings) Object.assign(gameState.gardenerBuildings, saved.gardenerBuildings);
                gameState.techTreeUnlocked = saved.techTreeUnlocked || false;
                gameState.gameEnded = saved.gameEnded || false;

                // Story progression
                gameState.storyPhase = saved.storyPhase || 'early';
                gameState.anomalyDiscovered = saved.anomalyDiscovered || false;
                gameState.trueLoreRevealed = saved.trueLoreRevealed || false;
                gameState.rulerPathProgress = saved.rulerPathProgress || 0;
                gameState.gardenerPathProgress = saved.gardenerPathProgress || 0;
                gameState.dominantPath = saved.dominantPath || 'none';

                // Crisis system
                gameState.crisisLevel = saved.crisisLevel || 0;
                gameState.activeCrises = saved.activeCrises || [];
                gameState.horsemenDefeated = saved.horsemenDefeated || [];
                gameState.lastCrisisTime = saved.lastCrisisTime || 0;

                // Progress tracking
                if (saved.achievements) {
                    gameState.achievements.unlocked = saved.achievements.unlocked || [];
                    gameState.achievements.progress = saved.achievements.progress || {};
                    if (saved.achievements.definitions) {
                        gameState.achievements.definitions = saved.achievements.definitions;
                    }
                }
                if (saved.goals) {
                    gameState.goals.active = saved.goals.active || [];
                    gameState.goals.completed = saved.goals.completed || [];
                    gameState.goals.available = saved.goals.available || [];
                    gameState.goals.milestones = saved.goals.milestones || [];
                }
                if (saved.statistics) Object.assign(gameState.statistics, saved.statistics);
                gameState.playerTitles = saved.playerTitles || [];

                // Game entities (restore with caution)
                if (saved.villageGrid && Array.isArray(saved.villageGrid)) {
                    gameState.villageGrid = saved.villageGrid;
                }
                if (saved.intelligentCreatures && Array.isArray(saved.intelligentCreatures)) {
                    gameState.intelligentCreatures = saved.intelligentCreatures;
                }
                if (saved.conversationalUnits && Array.isArray(saved.conversationalUnits)) {
                    gameState.conversationalUnits = saved.conversationalUnits;
                }

                // Settings
                gameState.autoSaveEnabled = saved.autoSaveEnabled !== undefined ? saved.autoSaveEnabled : true;

                const saveAge = Math.floor((Date.now() - saveData.timestamp) / 1000 / 60); // minutes
                log(`💾 Game progress loaded! (Saved ${saveAge} minutes ago)`, 'success');
                return true;
            } catch (error) {
                console.error('Failed to load game:', error);
                log('❌ Failed to load saved game. Starting fresh.', 'error');
                return false;
            }
        };

        const migrateSaveData = (saveData) => {
            try {
                log('🔄 Migrating save data to current version...', 'info');

                // Handle different save versions
                const oldVersion = saveData.version || "0.0.0";
                let migrated = false;

                // Migration from pre-1.0.0 saves
                if (!saveData.gameState) {
                    // Old format: data was directly in saveData
                    const newSaveData = {
                        version: CURRENT_SAVE_VERSION,
                        timestamp: saveData.timestamp || Date.now(),
                        gameState: {
                            // Migrate old format to new structure
                            energy: saveData.energy || 20,
                            insight: saveData.insight || 5,
                            harmony: saveData.harmony || 50,
                            inspiration: saveData.inspiration || 0,
                            wisdom: saveData.wisdom || 0,
                            control: saveData.control || 0,
                            consciousness: saveData.consciousness || 10,
                            planetaryConsciousness: saveData.planetaryConsciousness || 10,
                            entropy: saveData.entropy || 0,

                            energyPerSecond: saveData.energyPerSecond || 0,
                            insightPerSecond: saveData.insightPerSecond || 0,
                            inspirationPerSecond: saveData.inspirationPerSecond || 0,
                            wisdomPerSecond: saveData.wisdomPerSecond || 0,
                            controlPerSecond: saveData.controlPerSecond || 0,
                            consciousnessPerSecond: saveData.consciousnessPerSecond || 0,

                            units: saveData.units || {},
                            nodes: saveData.nodes || {},
                            nodeCosts: saveData.nodeCosts || {},
                            rulerBuildings: saveData.rulerBuildings || {},
                            gardenerBuildings: saveData.gardenerBuildings || {},
                            techTreeUnlocked: saveData.techTreeUnlocked || false,

                            achievements: saveData.achievements || { unlocked: [], progress: {}, definitions: {} },
                            goals: saveData.goals || { active: [], completed: [], available: [], milestones: [] },
                            statistics: saveData.statistics || {},
                            playerTitles: saveData.playerTitles || [],

                            villageGrid: saveData.villageGrid || [],
                            intelligentCreatures: saveData.intelligentCreatures || [],
                            conversationalUnits: saveData.conversationalUnits || [],

                            autoSaveEnabled: saveData.autoSaveEnabled !== undefined ? saveData.autoSaveEnabled : true
                        }
                    };

                    // Save migrated data
                    localStorage.setItem(SAVE_KEY, JSON.stringify(newSaveData));
                    saveData = newSaveData;
                    migrated = true;
                }

                // Apply the migrated save data
                if (migrated) {
                    log('✅ Save data migrated successfully!', 'success');
                    return loadGameState(); // Reload with migrated data
                } else {
                    log('⚠️ Save version not supported. Starting fresh.', 'warning');
                    return false;
                }
            } catch (error) {
                console.error('Migration failed:', error);
                log('❌ Save migration failed. Starting fresh.', 'error');
                return false;
            }
        };

        const exportSaveData = () => {
            try {
                const saveData = localStorage.getItem(SAVE_KEY);
                if (!saveData) {
                    log('❌ No save data to export.', 'error');
                    return;
                }

                const blob = new Blob([saveData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `terraflow_save_${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                log('📤 Save data exported successfully!', 'success');
            } catch (error) {
                console.error('Export failed:', error);
                log('❌ Failed to export save data.', 'error');
            }
        };

        const importSaveData = (fileInput) => {
            const file = fileInput.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const saveData = JSON.parse(e.target.result);
                    localStorage.setItem(SAVE_KEY, e.target.result);

                    if (loadGameState()) {
                        log('📥 Save data imported successfully!', 'success');
                        location.reload(); // Refresh to apply imported data
                    }
                } catch (error) {
                    console.error('Import failed:', error);
                    log('❌ Failed to import save data. Invalid file format.', 'error');
                }
            };
            reader.readAsText(file);
        };

        const deleteSaveData = () => {
            if (confirm('⚠️ Are you sure you want to delete all save data? This cannot be undone!')) {
                localStorage.removeItem(SAVE_KEY);
                log('🗑️ Save data deleted. Refresh the page to start fresh.', 'warning');
            }
        };

        // Auto-save system
        let autoSaveTimer = null;

        const startAutoSave = () => {
            if (autoSaveTimer) clearInterval(autoSaveTimer);

            if (gameState.autoSaveEnabled) {
                autoSaveTimer = setInterval(() => {
                    saveGameState();
                }, gameState.autoSaveInterval);
            }
        };

        const stopAutoSave = () => {
            if (autoSaveTimer) {
                clearInterval(autoSaveTimer);
                autoSaveTimer = null;
            }
        };

        const toggleAutoSave = () => {
            gameState.autoSaveEnabled = !gameState.autoSaveEnabled;

            if (gameState.autoSaveEnabled) {
                startAutoSave();
                log('✅ Auto-save enabled (every 30 seconds)', 'success');
            } else {
                stopAutoSave();
                log('⏸️ Auto-save disabled', 'info');
            }

            saveGameState(); // Save the setting change
        };

        const checkAchievementsAndGoals = () => {
            // Check achievements
            Object.values(gameState.achievements.definitions).forEach(achievement => {
                const result = checkAchievementProgress(achievement, gameState);
                if (result.shouldUnlock) {
                    unlockAchievement(achievement, gameState);
                }
            });

            // Check active goals
            gameState.goals.active.forEach(goal => {
                const result = updateGoalProgress(goal, gameState);
                if (result.shouldComplete) {
                    completeGoal(goal, gameState);
                }
            });
        };

        // Create notification container if it doesn't exist
        const getNotificationContainer = () => {
            let container = document.getElementById('notification-container');
            if (!container) {
                container = document.createElement('div');
                container.id = 'notification-container';
                container.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    bottom: 20px;
                    z-index: 1000;
                    display: flex;
                    flex-direction: column;
                    gap: 10px;
                    pointer-events: none;
                    max-height: calc(100vh - 40px);
                    overflow-y: auto;
                    overflow-x: hidden;
                    width: 320px;
                `;
                document.body.appendChild(container);
            }
            return container;
        };

        // Limit notifications to prevent screen overflow
        const MAX_NOTIFICATIONS = 5;

        const cleanupOldNotifications = (container) => {
            const notifications = container.children;
            while (notifications.length >= MAX_NOTIFICATIONS) {
                // Remove the oldest notification (first child)
                const oldest = notifications[0];
                oldest.style.animation = 'slideOutRight 0.3s ease-in';
                setTimeout(() => oldest.remove(), 300);
            }
        };

        const showAchievementNotification = (achievement) => {
            const container = getNotificationContainer();
            cleanupOldNotifications(container);

            const notification = document.createElement('div');
            notification.className = 'achievement-notification';

            notification.style.cssText = `
                background: linear-gradient(135deg, #FFD700, #FFA500);
                color: #000;
                padding: 15px 20px;
                border-radius: 10px;
                box-shadow: 0 4px 20px rgba(255, 215, 0, 0.4);
                font-family: 'Inter', sans-serif;
                max-width: 300px;
                animation: slideInRight 0.5s ease-out;
                pointer-events: auto;
            `;

            const rarityColors = {
                common: '#10B981',
                uncommon: '#3B82F6',
                rare: '#8B5CF6',
                legendary: '#F59E0B'
            };

            notification.innerHTML = `
                <div style="display: flex; align-items: center; margin-bottom: 8px;">
                    <span style="font-size: 24px; margin-right: 10px;">⭐</span>
                    <div>
                        <div style="font-weight: bold; font-size: 16px;">Achievement Unlocked!</div>
                        <div style="font-size: 12px; opacity: 0.8; color: ${rarityColors[achievement.rarity] || '#666'};">${achievement.rarity?.toUpperCase() || 'COMMON'}</div>
                    </div>
                </div>
                <div style="font-weight: bold; margin-bottom: 5px;">${achievement.name}</div>
                <div style="font-size: 14px; margin-bottom: 10px;">${achievement.description}</div>
                ${achievement.rewards ? `<div style="font-size: 12px; opacity: 0.9;">Rewards: ${formatRewards(achievement.rewards)}</div>` : ''}
            `;

            container.appendChild(notification);

            // Auto-remove after 5 seconds
            setTimeout(() => {
                notification.style.animation = 'slideOutRight 0.5s ease-in';
                setTimeout(() => {
                    notification.remove();
                }, 500);
            }, 5000);
        };

        const showGoalNotification = (goal) => {
            const container = getNotificationContainer();
            cleanupOldNotifications(container);

            const notification = document.createElement('div');
            notification.className = 'goal-notification';

            notification.style.cssText = `
                background: linear-gradient(135deg, #10B981, #059669);
                color: white;
                padding: 15px 20px;
                border-radius: 10px;
                box-shadow: 0 4px 20px rgba(16, 185, 129, 0.4);
                font-family: 'Inter', sans-serif;
                max-width: 300px;
                animation: slideInRight 0.5s ease-out;
                pointer-events: auto;
            `;

            notification.innerHTML = `
                <div style="display: flex; align-items: center; margin-bottom: 8px;">
                    <span style="font-size: 24px; margin-right: 10px;">🎯</span>
                    <div>
                        <div style="font-weight: bold; font-size: 16px;">Goal Completed!</div>
                        <div style="font-size: 12px; opacity: 0.8;">${goal.category?.toUpperCase() || 'MAIN'}</div>
                    </div>
                </div>
                <div style="font-weight: bold; margin-bottom: 5px;">${goal.title}</div>
                <div style="font-size: 14px; margin-bottom: 10px;">${goal.description}</div>
                ${goal.rewards ? `<div style="font-size: 12px; opacity: 0.9;">Rewards: ${formatRewards(goal.rewards)}</div>` : ''}
            `;

            container.appendChild(notification);

            // Auto-remove after 4 seconds
            setTimeout(() => {
                notification.style.animation = 'slideOutRight 0.5s ease-in';
                setTimeout(() => {
                    notification.remove();
                }, 500);
            }, 4000);
        };

        const formatRewards = (rewards) => {
            return Object.entries(rewards).map(([type, amount]) => {
                if (type === 'title') return `"${amount}"`;
                return `+${amount} ${type.charAt(0).toUpperCase() + type.slice(1)}`;
            }).join(', ');
        };

        // Add CSS animations and scrollbar styling
        const style = document.createElement('style');
        style.textContent = `
            @keyframes slideInRight {
                from { transform: translateX(100%); opacity: 0; }
                to { transform: translateX(0); opacity: 1; }
            }
            @keyframes slideOutRight {
                from { transform: translateX(0); opacity: 1; }
                to { transform: translateX(100%); opacity: 0; }
            }

            /* Custom scrollbar for notification container */
            #notification-container::-webkit-scrollbar {
                width: 6px;
            }
            #notification-container::-webkit-scrollbar-track {
                background: rgba(0, 0, 0, 0.1);
                border-radius: 3px;
            }
            #notification-container::-webkit-scrollbar-thumb {
                background: rgba(255, 255, 255, 0.3);
                border-radius: 3px;
            }
            #notification-container::-webkit-scrollbar-thumb:hover {
                background: rgba(255, 255, 255, 0.5);
            }
        `;
        document.head.appendChild(style);

        const updateProgressUI = () => {
            // Update achievement count
            const achievementCount = gameState.achievements.unlocked.length;
            const achievementCountEl = document.getElementById('achievement-count');
            if (achievementCountEl) achievementCountEl.textContent = achievementCount;

            // Update goals completed count
            const goalsCompletedCount = gameState.goals.completed.length;
            const goalsCompletedCountEl = document.getElementById('goals-completed-count');
            if (goalsCompletedCountEl) goalsCompletedCountEl.textContent = goalsCompletedCount;

            // Update play time
            const playTimeMinutes = Math.floor(gameState.statistics.playTime / 60000);
            const playTimeEl = document.getElementById('play-time');
            if (playTimeEl) playTimeEl.textContent = `${playTimeMinutes}m`;

            // Update active goals
            updateActiveGoalsUI();

            // Update recent achievements
            updateRecentAchievementsUI();
        };

        const updateActiveGoalsUI = () => {
            const container = document.getElementById('active-goals');
            if (!container) return;

            container.innerHTML = '';

            gameState.goals.active.slice(0, 3).forEach(goal => {
                const progressPercent = Math.min(100, (goal.progress / goal.target) * 100);

                const goalEl = document.createElement('div');
                goalEl.className = 'p-2 bg-indigo-900/20 rounded text-xs';
                goalEl.innerHTML = `
                    <div class="font-medium text-white">${goal.title}</div>
                    <div class="text-indigo-300 mb-1">${goal.description}</div>
                    <div class="w-full bg-gray-700 rounded-full h-1.5 mb-1">
                        <div class="bg-indigo-500 h-1.5 rounded-full transition-all duration-300" style="width: ${progressPercent}%"></div>
                    </div>
                    <div class="text-indigo-400">${goal.progress}/${goal.target} (${progressPercent.toFixed(0)}%)</div>
                `;
                container.appendChild(goalEl);
            });

            if (gameState.goals.active.length === 0) {
                container.innerHTML = '<div class="text-gray-400 text-xs">No active goals</div>';
            }
        };

        const updateRecentAchievementsUI = () => {
            const container = document.getElementById('recent-achievements');
            if (!container) return;

            container.innerHTML = '';

            const recentAchievements = gameState.achievements.unlocked
                .map(id => gameState.achievements.definitions[id])
                .filter(a => a && a.unlocked)
                .sort((a, b) => (b.unlockedAt || 0) - (a.unlockedAt || 0))
                .slice(0, 3);

            recentAchievements.forEach(achievement => {
                const rarityColors = {
                    common: '#10B981',
                    uncommon: '#3B82F6',
                    rare: '#8B5CF6',
                    legendary: '#F59E0B'
                };

                const achievementEl = document.createElement('div');
                achievementEl.className = 'p-2 bg-yellow-900/20 rounded text-xs';
                achievementEl.innerHTML = `
                    <div class="flex items-center">
                        <span class="mr-2">🏆</span>
                        <div class="flex-1">
                            <div class="font-medium text-white">${achievement.name}</div>
                            <div class="text-yellow-300">${achievement.description}</div>
                            <div class="text-xs" style="color: ${rarityColors[achievement.rarity] || '#10B981'}">${achievement.rarity?.toUpperCase() || 'COMMON'}</div>
                        </div>
                    </div>
                `;
                container.appendChild(achievementEl);
            });

            if (recentAchievements.length === 0) {
                container.innerHTML = '<div class="text-gray-400 text-xs">No achievements yet</div>';
            }
        };

        // --- Grok API Integration with Popup ---
        async function callGrok(prompt, button, systemPrompt = "") {
            if (button) {
                button.disabled = true;
                button.classList.add('loading');
                button.innerHTML = 'AI is thinking...';
            }

            try {
                const apiKey = getApiKey();
                if (!apiKey) {
                    showApiKeyPopup();
                    throw new Error("API key required - popup shown");
                }

                const apiUrl = "https://api.x.ai/v1/chat/completions";
                const messages = [];

                if (systemPrompt) {
                    messages.push({ role: "system", content: systemPrompt });
                }
                messages.push({ role: "user", content: prompt });

                const payload = {
                    messages: messages,
                    model: "grok-beta",
                    stream: false,
                    temperature: 0.8
                };

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    throw new Error(`Grok API call failed: ${response.status} ${response.statusText}`);
                }

                const result = await response.json();
                return result.choices?.[0]?.message?.content || "The cosmic winds carry no clear message...";

            } catch (error) {
                console.error("Grok API Error:", error);
                if (error.message.includes("API key")) {
                    return "The Grok API key must be configured to access cosmic wisdom. Set your API key in the code.";
                }
                return "The aetheric connection is disrupted. The cosmic network seems unreachable.";
            } finally {
                if (button) {
                    button.disabled = false;
                    button.classList.remove('loading');
                    if(button.id === 'seasonal-vision-btn') button.innerHTML = '✨ Get Resonant Vision';
                    if(button.id === 'advisor-btn') button.innerHTML = '📜 Ask Advisor';
                }
            }
        }
        async function getSeasonalVision() {
            const systemPrompt = "You are a mystical storyteller for TerraFlow: Roots of Transition, a cosmic incremental game. Create poetic, ethereal visions about the sanctuary's future or cosmic events. Use mystical language and keep responses to 2-3 sentences.";

            const prompt = `Current sanctuary state: Energy production ${gameState.energyPerSecond.toFixed(1)}/s, Insight production ${gameState.insightPerSecond.toFixed(1)}/s. The sanctuary houses ${gameState.units.dreamers} dreamers and ${gameState.units.weavers} weavers, with ${gameState.harmony.toFixed(1)}% harmony. Provide a mystical seasonal vision or cosmic forecast.`;

            const story = await callGrok(prompt, seasonalVisionBtn, systemPrompt);
            log(`✨ ${story}`, 'grok');
        }

        async function getAdvisorInsight() {
            const systemPrompt = "You are the Cosmic Advisor for TerraFlow: Roots of Transition. Provide brief, mystical advice using cosmic language. Always start responses with 'The sanctuary whispers...' and keep under 30 words. Focus on actionable game advice.";

            const prompt = `Current stats: Energy: ${formatNumber(gameState.energy)}, Insight: ${formatNumber(gameState.insight)}, Energy/s: ${formatNumber(gameState.energyPerSecond)}, Insight/s: ${formatNumber(gameState.insightPerSecond)}, Harmony: ${gameState.harmony.toFixed(1)}%. What should the player focus on next?`;

            const advice = await callGrok(prompt, advisorBtn, systemPrompt);
            log(`📜 ${advice}`, 'grok');
        }

        // --- TDD: Intelligent Creatures Global Functions ---
        window.spawnIntelligentCreature = (type) => {
            const creature = spawnIntelligentCreature(type);
            updateCreatureCount();
            return creature;
        };

        const updateCreatureCount = () => {
            const countElement = document.getElementById('creature-count');
            if (countElement) {
                countElement.textContent = gameState.intelligentCreatures.length;
            }
        };

        // --- TDD: Conversational AI Global Functions ---
        window.spawnConversationalUnit = (type) => {
            const unit = spawnConversationalUnit(type);
            updateConversationalCount();
            return unit;
        };

        // --- TDD: Improved UI Functions ---
        window.switchTab = (tabName) => {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.add('hidden');
            });

            // Remove active class from all tabs
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });

            // Show selected tab content
            document.getElementById(`content-${tabName}`).classList.remove('hidden');

            // Add active class to selected tab
            document.getElementById(`tab-${tabName}`).classList.add('active');
        };

        // --- TDD: Keyboard Shortcuts ---
        document.addEventListener('keydown', (e) => {
            // Only handle shortcuts if not typing in an input
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

            switch(e.key) {
                case '1':
                    switchTab('units');
                    break;
                case '2':
                    switchTab('upgrades');
                    break;
                case '3':
                    switchTab('beings');
                    break;
                case '4':
                    switchTab('ai');
                    break;
                case '5':
                    switchTab('progress');
                    break;
                case '6':
                    switchTab('paths');
                    break;
                case 'd':
                case 'D':
                    if (gameState.energy >= gameState.unitCosts.dreamers) {
                        createUnit('dreamers');
                    }
                    break;
                case 'w':
                case 'W':
                    if (gameState.insight >= gameState.unitCosts.weavers) {
                        createUnit('weavers');
                    }
                    break;
                case 's':
                case 'S':
                    spawnIntelligentCreature('cosmicSage');
                    break;
                case 'e':
                case 'E':
                    spawnIntelligentCreature('voidExplorer');
                    break;
                case 'h':
                case 'H':
                    spawnIntelligentCreature('harmonyKeeper');
                    break;
                case 'Escape':
                    closeConversationDialog();
                    break;
            }
        });

        const updateConversationalCount = () => {
            const countElement = document.getElementById('conversational-count');
            if (countElement) {
                countElement.textContent = gameState.conversationalUnits.length;
            }
        };

        window.closeConversationDialog = () => {
            if (conversationDialog) {
                conversationDialog.remove();
                conversationDialog = null;
                selectedConversationalUnit = null;
            }
        };

        window.sendMessage = async () => {
            const input = document.getElementById('player-input');
            const content = document.getElementById('conversation-content');

            if (!input.value.trim() || !selectedConversationalUnit) return;

            const playerMessage = input.value.trim();
            input.value = '';

            // Add player message to conversation
            const playerDiv = document.createElement('div');
            playerDiv.style.cssText = 'background: rgba(16, 185, 129, 0.2); padding: 10px; border-radius: 8px; margin-bottom: 10px;';
            playerDiv.innerHTML = `
                <div style="font-size: 12px; color: #34D399; margin-bottom: 5px;">You:</div>
                <div>${playerMessage}</div>
            `;
            content.appendChild(playerDiv);

            // Generate unit response
            const response = await generateLLMDialogue(selectedConversationalUnit, playerMessage);

            // Add unit response
            const unitDiv = document.createElement('div');
            unitDiv.style.cssText = 'background: rgba(139, 92, 246, 0.2); padding: 10px; border-radius: 8px; margin-bottom: 10px;';
            unitDiv.innerHTML = `
                <div style="font-size: 12px; color: #A78BFA; margin-bottom: 5px;">${selectedConversationalUnit.type}:</div>
                <div>${response}</div>
            `;
            content.appendChild(unitDiv);

            // Improve relationship
            selectedConversationalUnit.playerRelationship = Math.min(1.0, selectedConversationalUnit.playerRelationship + 0.05);

            // Scroll to bottom
            content.scrollTop = content.scrollHeight;
        };

        // --- Game Logic ---
        window.createUnit = (key) => {
            trackUserActivity(); // Track user engagement

            const unitConf = unitsConfig[key];
            const cost = gameState.unitCosts[key];

            if (gameState[unitConf.costResource] >= cost) {
                gameState[unitConf.costResource] -= cost;
                gameState.units[key]++;

                // Swarm Simulator-style exponential cost increase
                gameState.unitCosts[key] = Math.floor(gameState.unitBaseCosts[key] * Math.pow(gameState.costMultiplier, gameState.units[key]));

                if (key === 'dreamers') addSprite('crystal_tree');
                if (key === 'weavers') addSprite('dome');
                log(`A new ${unitConf.name} joins the sanctuary. Next one costs ${gameState.unitCosts[key]} ${unitConf.costResource}.`, 'success');

                // TDD Task 1: Add movable sprite for the new unit
                addSprite(key, 1);

                // TDD: Track statistics for achievements
                updateStatistics('unit_created');

                // TDD: Save progress after important actions
                if (Math.random() < 0.3) { // 30% chance to save on unit creation
                    saveGameState();
                }

                // TDD Fix: Don't immediately re-render UI, let game loop handle it
            } else {
                log(`Not enough ${unitConf.costResource}. Need ${cost}, have ${Math.floor(gameState[unitConf.costResource])}.`, 'warning');
            }
        };

        window.upgradeNode = (key) => {
            const nodeConf = nodesConfig[key];
            const cost = gameState.nodeCosts[key];
            if (gameState[nodeConf.costResource] >= cost) {
                gameState[nodeConf.costResource] -= cost;
                gameState.nodes[key]++;
                gameState.nodeCosts[key] *= 2.5;
                if (nodeConf.harmony) {
                    gameState.harmony = Math.min(100, gameState.harmony + nodeConf.harmony);
                }
                if (key === 'sustenance') addSprite('garden');
                log(`Attuned the ${nodeConf.name}. Its resonance grows stronger.`, 'success');
                // TDD Fix: Don't immediately re-render UI, let game loop handle it
            }
        };
        
        const updateGameState = (delta) => {
            // Calculate production per second
            let energyPerSecond = gameState.units.weavers * unitsConfig.weavers.baseEnergy;
            let insightPerSecond = gameState.units.dreamers * unitsConfig.dreamers.baseInsight;

            // Apply node bonuses
            let costMultiplier = 1;
            energyPerSecond *= Math.pow(nodesConfig.energy.multiplier, gameState.nodes.energy);
            insightPerSecond *= Math.pow(nodesConfig.sustenance.multiplier, gameState.nodes.sustenance);
            const cohesionBonus = Math.pow(nodesConfig.cohesion.multiplier, gameState.nodes.cohesion);
            energyPerSecond *= cohesionBonus;
            insightPerSecond *= cohesionBonus;
            costMultiplier *= Math.pow(nodesConfig.cycling.multiplier, gameState.nodes.cycling);

            // Update unit costs based on multiplier (visual only, actual cost is in gameState)
            // This is a simplification; a more robust model would adjust the base cost.

            gameState.energyPerSecond = energyPerSecond;
            gameState.insightPerSecond = insightPerSecond;

            // Add resources with caps (Swarm Simulator style)
            const energyGained = energyPerSecond * delta;
            const insightGained = insightPerSecond * delta;

            gameState.energy = Math.min(gameState.energyCap, gameState.energy + energyGained);
            gameState.insight = Math.min(gameState.insightCap, gameState.insight + insightGained);

            // Show cap warning if resources are maxed
            if (gameState.energy >= gameState.energyCap && energyGained > 0) {
                if (Math.random() < 0.01) { // Occasional warning
                    log('⚡ Energy storage full! Build storage upgrades to increase capacity.', 'warning');
                }
            }
            if (gameState.insight >= gameState.insightCap && insightGained > 0) {
                if (Math.random() < 0.01) {
                    log('🔮 Insight storage full! Expand your consciousness to hold more.', 'warning');
                }
            }

            // TDD: Track statistics for achievements
            if (energyGained > 0) {
                updateStatistics('energy_generated', { amount: energyGained });
            }
            if (insightGained > 0) {
                updateStatistics('insight_generated', { amount: insightGained });
            }
            if (gameState.harmony !== gameState.statistics.maxHarmony) {
                updateStatistics('harmony_changed');
            }
        };

        let lastUIUpdate = 0;
        let gameLoopCount = 0;
        let lastPerformanceLog = 0;

        const gameLoop = () => {
            // Stop the game loop if the game has ended
            if (gameState.gameEnded) {
                debugLog('SYSTEM', 'Game loop stopped - game ended', { gameEnded: gameState.gameEnded });
                return;
            }

            const now = Date.now();
            const delta = (now - gameState.lastUpdate) / 1000; // Time in seconds
            gameLoopCount++;

            // Performance monitoring - log every 10 seconds
            if (now - lastPerformanceLog > 10000) {
                debugLog('PERFORMANCE', 'Game loop performance', {
                    fps: Math.round(gameLoopCount / 10),
                    delta: delta.toFixed(3),
                    villageGridSize: gameState.villageGrid?.length || 0,
                    activeCrises: gameState.activeCrises?.length || 0,
                    storyPhase: gameState.storyPhase,
                    consciousness: gameState.consciousness,
                    energy: gameState.energy
                });
                gameLoopCount = 0;
                lastPerformanceLog = now;
            }

            try {
                updateGameState(delta);

                // TDD Fix: Update UI less frequently to prevent button blinking
                if (now - lastUIUpdate > 500) { // Increased from 100ms to 500ms
                    renderUI();
                    updateProgressUI(); // TDD: Update achievements and goals UI
                    lastUIUpdate = now;
                }
                drawSanctuary();

                gameState.lastUpdate = now;
                requestAnimationFrame(gameLoop);
            } catch (error) {
                debugLog('ERROR', 'Game loop error', {
                    error: error.message,
                    stack: error.stack,
                    gameState: {
                        energy: gameState.energy,
                        consciousness: gameState.consciousness,
                        storyPhase: gameState.storyPhase
                    }
                });
                console.error('Game loop error:', error);

                // Try to continue the game loop after logging the error
                setTimeout(() => requestAnimationFrame(gameLoop), 1000);
            }
        };

        // --- TDD Test Suite for Game Balance & Story Integration ---
        const runTests = () => {
            console.log("🧪 === TDD TEST SUITE: Game Balance & Story Integration ===");

            // Test 1: Initial State Validation
            testInitialGameState();

            // Test 2: Victory Condition Balance
            testVictoryConditions();

            // Test 3: Story Progression Logic
            testStoryProgression();

            // Test 4: Resource Balance
            testResourceBalance();

            // Test 5: AI Player Behavior
            testAIPlayerBehavior();

            console.log("🧪 === TDD TEST SUITE COMPLETE ===");
        };

        const testInitialGameState = () => {
            console.log("🧪 Test 1: Initial Game State");

            // Test initial resources match config
            console.assert(gameState.energy === gameConfig.initialResources.energy,
                `❌ Initial energy should be ${gameConfig.initialResources.energy}, got ${gameState.energy}`);
            console.assert(gameState.insight === gameConfig.initialResources.insight,
                `❌ Initial insight should be ${gameConfig.initialResources.insight}, got ${gameState.insight}`);
            console.assert(gameState.harmony === gameConfig.initialResources.harmony,
                `❌ Initial harmony should be ${gameConfig.initialResources.harmony}, got ${gameState.harmony}`);

            // Test initial units
            console.assert(gameState.units.dreamers === gameConfig.initialUnits.dreamers,
                `❌ Should start with ${gameConfig.initialUnits.dreamers} dreamers, got ${gameState.units.dreamers}`);
            console.assert(gameState.units.weavers === gameConfig.initialUnits.weavers,
                `❌ Should start with ${gameConfig.initialUnits.weavers} weavers, got ${gameState.units.weavers}`);

            console.log("✅ Initial state tests passed");
        };

        const testVictoryConditions = () => {
            console.log("🧪 Test 2: Victory Condition Balance");

            // Test if victory is too easy to achieve
            const totalBuildings = Object.values(gameState.gardenerBuildings).reduce((sum, count) => sum + count, 0) +
                                 Object.values(gameState.rulerBuildings).reduce((sum, count) => sum + count, 0);

            // Victory should require significant progress
            const minBuildingsForVictory = 5;
            const minConsciousnessForVictory = 80;

            console.log(`📊 Current buildings: ${totalBuildings}, Consciousness: ${gameState.consciousness}`);
            console.log(`📊 Victory thresholds: ${minBuildingsForVictory} buildings, ${minConsciousnessForVictory} consciousness`);

            if (totalBuildings < minBuildingsForVictory && gameState.consciousness >= minConsciousnessForVictory) {
                console.warn("⚠️ BALANCE ISSUE: Victory may be too easy - high consciousness with few buildings");
            }

            console.log("✅ Victory condition tests completed");
        };

        const testStoryProgression = () => {
            console.log("🧪 Test 3: Story Progression Logic");

            // Test story phase transitions
            console.log(`📖 Current story phase: ${gameState.storyPhase}`);
            console.log(`📖 Anomaly discovered: ${gameState.anomalyDiscovered}`);
            console.log(`📖 True lore revealed: ${gameState.trueLoreRevealed}`);

            // Check if story progression conditions are clear
            const storyConditions = {
                anomalyTrigger: gameState.consciousness >= 30 || gameState.control >= 30,
                loreTrigger: gameState.anomalyDiscovered && (gameState.consciousness >= 50 || gameState.control >= 50),
                endgameTrigger: gameState.trueLoreRevealed && (gameState.consciousness >= 80 || gameState.control >= 80)
            };

            console.log("📖 Story progression conditions:", storyConditions);
            console.log("✅ Story progression tests completed");
        };

        const testResourceBalance = () => {
            console.log("🧪 Test 4: Resource Balance");

            // Test resource generation rates
            const energyRate = gameState.energyPerSecond;
            const insightRate = gameState.insightPerSecond;

            console.log(`⚡ Energy rate: ${energyRate}/s (cap: ${gameState.energyCap})`);
            console.log(`🔮 Insight rate: ${insightRate}/s (cap: ${gameState.insightCap})`);

            // Test unit costs vs generation
            const dreamerCost = gameState.unitCosts.dreamers;
            const weaverCost = gameState.unitCosts.weavers;

            console.log(`💰 Dreamer cost: ${dreamerCost} energy`);
            console.log(`💰 Weaver cost: ${weaverCost} insight`);

            // Calculate time to afford next unit
            const timeToAffordDreamer = energyRate > 0 ? (dreamerCost - gameState.energy) / energyRate : Infinity;
            const timeToAffordWeaver = insightRate > 0 ? (weaverCost - gameState.insight) / insightRate : Infinity;

            console.log(`⏱️ Time to afford next Dreamer: ${timeToAffordDreamer.toFixed(1)}s`);
            console.log(`⏱️ Time to afford next Weaver: ${timeToAffordWeaver.toFixed(1)}s`);

            if (timeToAffordDreamer < 10 || timeToAffordWeaver < 10) {
                console.warn("⚠️ BALANCE ISSUE: Units may be too cheap - can afford in <10 seconds");
            }

            console.log("✅ Resource balance tests completed");
        };

        const testAIPlayerBehavior = () => {
            console.log("🧪 Test 5: AI Player Behavior");

            // TDD FIX: Add safety checks for aiPlayer
            if (!gameState.aiPlayer) {
                console.log("⚠️ aiPlayer not initialized, skipping AI tests");
                return;
            }

            console.log(`🤖 AI enabled: ${gameState.aiEnabled}`);
            console.log(`🤖 AI resources:`, gameState.aiPlayer.resources);
            console.log(`🤖 AI buildings:`, Object.keys(gameState.aiPlayer.buildings).length);
            console.log(`🤖 User inactive: ${isUserInactive()}`);
            console.log(`🤖 AI aggressiveness: ${gameState.aiPlayer.aggressiveness}`);

            console.log("✅ AI behavior tests completed");
        };

        // --- TDD: IndexedDB Debug Logging System ---
        let debugDB = null;

        const initDebugDB = async () => {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('TerraFlowDebugDB', 1);

                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    debugDB = request.result;
                    resolve(debugDB);
                };

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains('logs')) {
                        const store = db.createObjectStore('logs', { keyPath: 'id', autoIncrement: true });
                        store.createIndex('timestamp', 'timestamp', { unique: false });
                        store.createIndex('category', 'category', { unique: false });
                    }
                };
            });
        };

        const saveDebugLog = async (category, message, data = null) => {
            if (!debugDB) {
                try {
                    await initDebugDB();
                } catch (error) {
                    console.error('Failed to init debug DB:', error);
                    return;
                }
            }

            const logEntry = {
                timestamp: new Date().toISOString(),
                category: category,
                message: message,
                data: data ? JSON.stringify(data) : null,
                gameState: {
                    energy: gameState?.energy || 0,
                    consciousness: gameState?.consciousness || 0,
                    storyPhase: gameState?.storyPhase || 'unknown',
                    gameEnded: gameState?.gameEnded || false
                }
            };

            try {
                const transaction = debugDB.transaction(['logs'], 'readwrite');
                const store = transaction.objectStore('logs');
                await store.add(logEntry);

                // Keep only last 1000 logs to prevent storage bloat
                const countRequest = store.count();
                countRequest.onsuccess = () => {
                    if (countRequest.result > 1000) {
                        const deleteTransaction = debugDB.transaction(['logs'], 'readwrite');
                        const deleteStore = deleteTransaction.objectStore('logs');
                        const range = IDBKeyRange.upperBound(countRequest.result - 1000);
                        deleteStore.delete(range);
                    }
                };
            } catch (error) {
                console.error('Failed to save debug log:', error);
            }
        };

        const debugLog = (category, message, data = null) => {
            const timestamp = new Date().toLocaleTimeString();

            // Always save to IndexedDB
            saveDebugLog(category, message, data);

            // Console log if debug mode enabled (but NOT to game log)
            if (window.location.search.includes('debug') || localStorage.getItem('debug_mode') === 'true') {
                console.log(`🐛 [${timestamp}] ${category}: ${message}`, data || '');
                // TDD FIX: Removed log() call - debug logs should only appear in debug panel, not aetheric log
            }
        };

        const enableDebugMode = () => {
            localStorage.setItem('debug_mode', 'true');
            log('🐛 Debug mode enabled! Debug logs will appear in console and debug panel only.', 'success');
        };

        const disableDebugMode = () => {
            localStorage.setItem('debug_mode', 'false');
            log('🐛 Debug mode disabled. Debug logs will only be saved to debug panel.', 'info');
        };

        const showDebugViewer = async () => {
            if (!debugDB) {
                try {
                    await initDebugDB();
                } catch (error) {
                    log('❌ Failed to open debug database', 'error');
                    return;
                }
            }

            // Create debug viewer modal
            const modal = document.createElement('div');
            modal.id = 'debug-viewer-modal';
            modal.className = 'fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50';
            modal.innerHTML = `
                <div class="bg-gray-900 border border-gray-600 rounded-lg w-11/12 h-5/6 flex flex-col">
                    <div class="flex items-center justify-between p-4 border-b border-gray-600">
                        <h2 class="text-xl font-bold text-white">🐛 Debug Log Viewer</h2>
                        <div class="flex space-x-2">
                            <button id="debug-clear-btn" class="px-3 py-1 bg-red-600 text-white rounded hover:bg-red-700">
                                Clear Logs
                            </button>
                            <button id="debug-export-btn" class="px-3 py-1 bg-blue-600 text-white rounded hover:bg-blue-700">
                                Export
                            </button>
                            <button id="debug-close-btn" class="px-3 py-1 bg-gray-600 text-white rounded hover:bg-gray-700">
                                Close
                            </button>
                        </div>
                    </div>
                    <div class="flex-1 overflow-hidden flex">
                        <div class="w-1/4 border-r border-gray-600 p-2">
                            <h3 class="text-sm font-bold text-gray-300 mb-2">Categories</h3>
                            <div id="debug-categories" class="space-y-1"></div>
                        </div>
                        <div class="flex-1 flex flex-col">
                            <div class="p-2 border-b border-gray-600">
                                <input id="debug-search" type="text" placeholder="Search logs..."
                                       class="w-full px-3 py-1 bg-gray-800 text-white rounded border border-gray-600">
                            </div>
                            <div id="debug-logs" class="flex-1 overflow-y-auto p-2 text-xs font-mono"></div>
                        </div>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);

            // Load and display logs
            await loadDebugLogs();

            // Event listeners
            document.getElementById('debug-close-btn').onclick = () => {
                document.body.removeChild(modal);
            };

            document.getElementById('debug-clear-btn').onclick = async () => {
                if (confirm('Clear all debug logs?')) {
                    await clearDebugLogs();
                    await loadDebugLogs();
                }
            };

            document.getElementById('debug-export-btn').onclick = () => {
                exportDebugLogs();
            };

            document.getElementById('debug-search').oninput = (e) => {
                filterDebugLogs(e.target.value);
            };
        };

        const loadDebugLogs = async () => {
            try {
                const transaction = debugDB.transaction(['logs'], 'readonly');
                const store = transaction.objectStore('logs');
                const request = store.getAll();

                request.onsuccess = () => {
                    const logs = request.result.reverse(); // Most recent first
                    displayDebugLogs(logs);
                    updateCategoryFilter(logs);
                };
            } catch (error) {
                console.error('Failed to load debug logs:', error);
            }
        };

        const displayDebugLogs = (logs) => {
            const container = document.getElementById('debug-logs');
            if (!container) return;

            container.innerHTML = logs.map(log => {
                const time = new Date(log.timestamp).toLocaleTimeString();
                const dataStr = log.data ? `\n${log.data}` : '';
                const gameStateStr = log.gameState ?
                    `\n[Game: E:${log.gameState.energy} C:${log.gameState.consciousness} Phase:${log.gameState.storyPhase}]` : '';

                return `
                    <div class="debug-log-entry mb-2 p-2 bg-gray-800 rounded border-l-4 border-${getCategoryColor(log.category)}-500"
                         data-category="${log.category}">
                        <div class="flex justify-between items-start">
                            <span class="text-${getCategoryColor(log.category)}-400 font-bold">[${log.category}]</span>
                            <span class="text-gray-500 text-xs">${time}</span>
                        </div>
                        <div class="text-gray-200 mt-1">${log.message}</div>
                        ${dataStr ? `<pre class="text-gray-400 text-xs mt-1 overflow-x-auto">${dataStr}</pre>` : ''}
                        ${gameStateStr ? `<div class="text-gray-500 text-xs mt-1">${gameStateStr}</div>` : ''}
                    </div>
                `;
            }).join('');
        };

        const updateCategoryFilter = (logs) => {
            const categories = [...new Set(logs.map(log => log.category))];
            const container = document.getElementById('debug-categories');
            if (!container) return;

            container.innerHTML = categories.map(category => {
                const count = logs.filter(log => log.category === category).length;
                return `
                    <button class="debug-category-btn w-full text-left px-2 py-1 rounded text-sm hover:bg-gray-700 text-${getCategoryColor(category)}-400"
                            data-category="${category}">
                        ${category} (${count})
                    </button>
                `;
            }).join('');

            // Add click handlers
            container.querySelectorAll('.debug-category-btn').forEach(btn => {
                btn.onclick = () => {
                    const category = btn.dataset.category;
                    filterDebugLogsByCategory(category);
                };
            });
        };

        const getCategoryColor = (category) => {
            const colors = {
                'STORY': 'blue',
                'VICTORY': 'green',
                'BALANCE': 'yellow',
                'ERROR': 'red',
                'DEFEAT': 'red',
                'AI': 'purple',
                'RESOURCE': 'cyan'
            };
            return colors[category] || 'gray';
        };

        const filterDebugLogs = (searchTerm) => {
            const entries = document.querySelectorAll('.debug-log-entry');
            entries.forEach(entry => {
                const text = entry.textContent.toLowerCase();
                const matches = text.includes(searchTerm.toLowerCase());
                entry.style.display = matches ? 'block' : 'none';
            });
        };

        const filterDebugLogsByCategory = (category) => {
            const entries = document.querySelectorAll('.debug-log-entry');
            entries.forEach(entry => {
                const matches = entry.dataset.category === category;
                entry.style.display = matches ? 'block' : 'none';
            });
        };

        const clearDebugLogs = async () => {
            try {
                const transaction = debugDB.transaction(['logs'], 'readwrite');
                const store = transaction.objectStore('logs');
                await store.clear();
                log('🐛 Debug logs cleared', 'info');
            } catch (error) {
                console.error('Failed to clear debug logs:', error);
            }
        };

        const exportDebugLogs = async () => {
            try {
                const transaction = debugDB.transaction(['logs'], 'readonly');
                const store = transaction.objectStore('logs');
                const request = store.getAll();

                request.onsuccess = () => {
                    const logs = request.result;
                    const dataStr = JSON.stringify(logs, null, 2);
                    const blob = new Blob([dataStr], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);

                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `terraflow-debug-${new Date().toISOString().slice(0, 10)}.json`;
                    a.click();

                    URL.revokeObjectURL(url);
                    log('🐛 Debug logs exported', 'success');
                };
            } catch (error) {
                console.error('Failed to export debug logs:', error);
            }
        };

        // Add debug commands to window for console access
        window.debugCommands = {
            enable: enableDebugMode,
            disable: disableDebugMode,
            viewer: showDebugViewer,
            state: () => console.log('Current Game State:', gameState),
            story: () => debugStoryProgression(),
            victory: () => debugVictoryConditions(),
            balance: () => debugResourceBalance(),
            ai: () => debugAIBehavior(),
            test: runTests,
            clear: clearDebugLogs,
            export: exportDebugLogs
        };

        const debugStoryProgression = () => {
            console.log("📖 === STORY PROGRESSION DEBUG ===");
            console.log(`Story Phase: ${gameState.storyPhase}`);
            console.log(`Anomaly Discovered: ${gameState.anomalyDiscovered}`);
            console.log(`True Lore Revealed: ${gameState.trueLoreRevealed}`);
            console.log(`Tech Tree Unlocked: ${gameState.techTreeUnlocked}`);

            // Check story trigger conditions
            const anomalyCondition = gameState.consciousness >= 30 || gameState.control >= 30;
            const loreCondition = gameState.anomalyDiscovered && (gameState.consciousness >= 50 || gameState.control >= 50);
            const endgameCondition = gameState.trueLoreRevealed && (gameState.consciousness >= 80 || gameState.control >= 80);

            console.log("Story Trigger Conditions:");
            console.log(`  Anomaly (30 consciousness/control): ${anomalyCondition} (C:${gameState.consciousness}, Ctrl:${gameState.control})`);
            console.log(`  Lore (50 + anomaly): ${loreCondition}`);
            console.log(`  Endgame (80 + lore): ${endgameCondition}`);
        };

        const debugVictoryConditions = () => {
            console.log("🏆 === VICTORY CONDITIONS DEBUG ===");

            // Gardener victory conditions
            const gardenerVictory = gameState.planetaryConsciousness >= 100;
            const gardenerProgress = gameState.planetaryConsciousness;

            // Ruler victory conditions
            const rulerVictory = gameState.control >= 100 && gameState.rulerBuildings.exodusArk > 0;
            const rulerProgress = gameState.control;

            // Alliance victory conditions
            const allianceVictory = gameState.allianceFormed && gameState.integrationLevel >= 100;

            console.log("Victory Paths:");
            console.log(`  🌱 Gardener: ${gardenerVictory} (${gardenerProgress}/100 planetary consciousness)`);
            console.log(`  🏛️ Ruler: ${rulerVictory} (${rulerProgress}/100 control + exodus ark)`);
            console.log(`  🤝 Alliance: ${allianceVictory} (${gameState.integrationLevel}/100 integration)`);

            // Check for balance issues
            if (gardenerProgress > 50 && Object.values(gameState.gardenerBuildings).reduce((sum, count) => sum + count, 0) < 3) {
                console.warn("⚠️ BALANCE ISSUE: High consciousness with few buildings - victory may be too easy");
            }
        };

        const debugResourceBalance = () => {
            console.log("⚖️ === RESOURCE BALANCE DEBUG ===");

            // Current resources vs caps
            Object.keys(gameConfig.initialResources).forEach(resource => {
                if (resource.endsWith('Cap')) return;
                const current = gameState[resource];
                const cap = gameState[resource + 'Cap'];
                const rate = gameState[resource + 'PerSecond'] || 0;

                console.log(`${resource}: ${current.toFixed(1)}/${cap} (+${rate.toFixed(2)}/s)`);

                if (current >= cap * 0.9) {
                    console.warn(`⚠️ ${resource} near cap - may need storage upgrades`);
                }
            });

            // Unit cost progression
            console.log("Unit Costs:");
            Object.keys(gameConfig.unitBaseCosts).forEach(unit => {
                const baseCost = gameConfig.unitBaseCosts[unit];
                const currentCost = gameState.unitCosts[unit];
                const count = gameState.units[unit];
                console.log(`  ${unit}: ${currentCost} (base: ${baseCost}, owned: ${count})`);
            });
        };

        const debugAIBehavior = () => {
            console.log("🤖 === AI BEHAVIOR DEBUG ===");
            console.log(`AI Enabled: ${gameState.aiEnabled}`);
            console.log(`User Inactive: ${isUserInactive()}`);
            console.log(`AI Aggressiveness: ${gameState.aiPlayer.aggressiveness}`);
            console.log(`AI Resources:`, gameState.aiPlayer.resources);
            console.log(`AI Buildings:`, gameState.aiPlayer.buildings);
            console.log(`Alliance Formed: ${gameState.allianceFormed}`);
            console.log(`Integration Level: ${gameState.integrationLevel}%`);
        };

        // --- Initialization ---
        const init = () => {
            // Try to load saved game first
            const loadedSave = loadGameState();

            if (!loadedSave) {
                log("🌟 Welcome to The Great Transition. Humanity stands at a crossroads between Control and Consciousness.", "success");
                log("🎯 Your goal: Reach 100 Planetary Consciousness to achieve humanity's awakening.", "info");
                log("⚠️ Beware: High Control suppresses Consciousness. High imbalance creates Entropy.", "warning");
            } else {
                log("🌟 Welcome back to The Great Transition. Your journey continues...", "success");
            }

            log("🔑 Grok API integration ready - key will be requested when needed", "info");

            // TDD: Initialize Achievement & Goals System
            initializeAchievements();
            initializeGoals();

            // Initialize canvas controls
            initializeCanvasControls();

            // Initialize debug database
            initDebugDB().then(() => {
                debugLog('SYSTEM', 'Game initialized', {
                    version: '1.0.0',
                    timestamp: new Date().toISOString(),
                    initialState: {
                        energy: gameState.energy,
                        consciousness: gameState.consciousness,
                        storyPhase: gameState.storyPhase
                    }
                });
            }).catch(error => {
                console.error('Failed to initialize debug DB:', error);
            });

            // Initialize minimap navigation
            initializeMinimapNavigation();

            // Initialize player switching
            initializePlayerSwitching();

            // Initialize stats toggle
            initializeStatsToggle();

            // TDD FIX: Initialize UI rendering with error checking
            debugLog('SYSTEM', 'Initializing UI rendering');
            if (unitsPanel && modulesPanel) {
                renderUI(); // Render units, upgrades, and stats panels
                debugLog('SYSTEM', 'UI rendering complete');
            } else {
                debugLog('ERROR', 'DOM elements not found', {
                    unitsPanel: !!unitsPanel,
                    modulesPanel: !!modulesPanel
                });
            }

            // Add some initial units for testing if none exist
            if (gameState.villageGrid.length === 0) {
                addSprite('dreamer', 2);
                addSprite('weaver', 2);
                addSprite('dome', 1);
                log('🎮 Added initial test units to the sanctuary', 'info');
            }
            log("⭐ Achievement & Goals system initialized", "info");

            // Initialize sprites (only if not loaded from save)
            if (!loadedSave) {
                addSprite('dome', 1);
                addSprite('crystal_tree', 1);
            }

            // Initialize event listeners
            advisorBtn.addEventListener('click', getAdvisorInsight);
            seasonalVisionBtn.addEventListener('click', getSeasonalVision);

            // Save/Load system event listeners
            const saveBtn = document.getElementById('save-btn');
            const loadBtn = document.getElementById('load-btn');
            const exportBtn = document.getElementById('export-btn');
            const importBtn = document.getElementById('import-btn');
            const autosaveToggle = document.getElementById('autosave-toggle');
            const importFile = document.getElementById('import-file');

            saveBtn.addEventListener('click', () => {
                saveGameState();
            });

            loadBtn.addEventListener('click', () => {
                if (loadGameState()) {
                    location.reload(); // Refresh to apply loaded data
                }
            });

            exportBtn.addEventListener('click', exportSaveData);

            importBtn.addEventListener('click', () => {
                importFile.click();
            });

            importFile.addEventListener('change', (e) => {
                importSaveData(e.target);
                e.target.value = ''; // Reset file input
            });

            autosaveToggle.addEventListener('click', () => {
                toggleAutoSave();
                updateAutoSaveButton();
            });

            // Update auto-save button text
            const updateAutoSaveButton = () => {
                autosaveToggle.textContent = `🔄 Auto-save: ${gameState.autoSaveEnabled ? 'ON' : 'OFF'}`;
            };
            updateAutoSaveButton();

            // Start auto-save system
            startAutoSave();

            // Save on page unload to prevent data loss
            window.addEventListener('beforeunload', (e) => {
                saveGameState();
                // Don't show confirmation dialog for normal saves
            });

            // Save when page becomes hidden (mobile/tab switching)
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    saveGameState();
                }
            });

            // TDD API Key Popup Event Listeners
            const saveKeyBtn = document.getElementById('save-api-key');
            const cancelKeyBtn = document.getElementById('cancel-api-key');
            const apiKeyInput = document.getElementById('api-key-input');

            saveKeyBtn.addEventListener('click', () => {
                const key = apiKeyInput.value.trim();

                if (!key) {
                    showApiKeyError('Please enter an API key');
                    return;
                }

                if (key.length < 10) {
                    showApiKeyError('API key seems too short. Please check your key.');
                    return;
                }

                if (key.includes(' ')) {
                    showApiKeyError('API key should not contain spaces');
                    return;
                }

                if (saveApiKey(key)) {
                    hideApiKeyPopup();
                    log('🔑 Grok API key saved successfully! You can now access cosmic wisdom.', 'success');
                } else {
                    showApiKeyError('Failed to save API key. Please try again.');
                }
            });

            cancelKeyBtn.addEventListener('click', () => {
                hideApiKeyPopup();
            });

            // Handle Enter key in API key input
            apiKeyInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    saveKeyBtn.click();
                }
            });

            // Handle Escape key to close popups
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    const popup = document.getElementById('api-key-popup');
                    const unitInfoPanel = document.getElementById('unit-info-panel');

                    if (!popup.classList.contains('hidden')) {
                        hideApiKeyPopup();
                    } else if (!unitInfoPanel.classList.contains('hidden')) {
                        hideUnitInfo();
                    }
                }
            });

            // TDD: Enhanced Mouse event listeners for drag-and-drop
            canvas.addEventListener('mousedown', (e) => {
                const coords = getCanvasCoordinates(e);
                const result = getDraggableUnitAtPosition(coords.x, coords.y);

                if (result && result.unit) {
                    const unit = result.unit;

                    // Initialize drag state
                    dragState.isDragging = true;
                    dragState.draggedUnit = unit;
                    dragState.dragOffsetX = coords.x - unit.x;
                    dragState.dragOffsetY = coords.y - unit.y;
                    dragState.originalPosition = { x: unit.x, y: unit.y };
                    dragState.dragStartTime = Date.now();
                    dragState.totalDragDistance = 0;

                    // Visual feedback
                    unit.isDragging = true;

                    // Stop auto-wandering while dragging (for village units)
                    if (unit.wanderCenter) {
                        unit.wanderCenter = { x: unit.x, y: unit.y };
                    }

                    canvas.style.cursor = 'grabbing';
                    log(`Started dragging ${unit.type}`, 'info');
                }
            });

            canvas.addEventListener('mousemove', (e) => {
                const coords = getCanvasCoordinates(e);

                if (dragState.isDragging && dragState.draggedUnit) {
                    const unit = dragState.draggedUnit;
                    const oldX = unit.x;
                    const oldY = unit.y;

                    // Calculate new position
                    const newX = coords.x - dragState.dragOffsetX;
                    const newY = coords.y - dragState.dragOffsetY;

                    // Apply canvas boundaries
                    const constrainedX = Math.max(unit.size, Math.min(canvas.width - unit.size, newX));
                    const constrainedY = Math.max(unit.size, Math.min(canvas.height - unit.size, newY));

                    // Update unit position
                    unit.x = constrainedX;
                    unit.y = constrainedY;

                    // For village units, also update targetX/targetY
                    if (unit.targetX !== undefined) {
                        unit.targetX = constrainedX;
                        unit.targetY = constrainedY;
                    }

                    // Calculate drag distance
                    const deltaX = constrainedX - oldX;
                    const deltaY = constrainedY - oldY;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    dragState.totalDragDistance += distance;

                    // Validate placement and calculate effects
                    dragState.isValidPlacement = validateUnitPlacement(unit, { width: canvas.width, height: canvas.height });
                    dragState.placementEffects = calculatePlacementEffects(unit);

                    // Calculate proximity indicators
                    dragState.proximityIndicators = getProximityIndicators(unit);

                } else {
                    // Update hover state
                    const result = getDraggableUnitAtPosition(coords.x, coords.y);
                    dragState.hoveredUnit = result ? result.unit : null;

                    if (result && result.unit) {
                        canvas.style.cursor = 'grab';
                    } else {
                        // Check for conversational units for chat
                        const conversationalUnit = getConversationalUnitAtPosition(coords.x, coords.y);
                        canvas.style.cursor = conversationalUnit ? 'pointer' : 'default';
                    }
                }
            });

            canvas.addEventListener('mouseup', (e) => {
                if (dragState.isDragging && dragState.draggedUnit) {
                    const unit = dragState.draggedUnit;
                    const dragDuration = Date.now() - dragState.dragStartTime;

                    // Validate final placement
                    if (dragState.isValidPlacement) {
                        // Successful placement
                        if (unit.wanderCenter) {
                            unit.wanderCenter = { x: unit.x, y: unit.y };
                        }

                        // Apply placement effects
                        if (dragState.placementEffects.length > 0) {
                            dragState.placementEffects.forEach(effect => {
                                if (effect.type === 'proximity_bonus') {
                                    log(`${unit.type} gains proximity bonus from ${effect.nearbyUnits.length} nearby units!`, 'success');
                                } else if (effect.type === 'strategic_position') {
                                    log(`${unit.type} positioned strategically for enhanced performance!`, 'success');
                                }
                            });
                        }

                        log(`Moved ${unit.type} to new location (${dragState.totalDragDistance.toFixed(0)}px in ${(dragDuration/1000).toFixed(1)}s)`, 'info');
                    } else {
                        // Invalid placement - revert to original position
                        unit.x = dragState.originalPosition.x;
                        unit.y = dragState.originalPosition.y;
                        if (unit.targetX !== undefined) {
                            unit.targetX = unit.x;
                            unit.targetY = unit.y;
                        }
                        if (unit.wanderCenter) {
                            unit.wanderCenter = { x: unit.x, y: unit.y };
                        }
                        log(`Invalid placement! ${unit.type} returned to original position.`, 'warning');
                    }

                    // Clean up drag state
                    unit.isDragging = false;
                } else {
                    // Check for unit clicks (only if not dragging)
                    const coords = getCanvasCoordinates(e);

                    // First check for conversational units
                    const conversationalUnit = getConversationalUnitAtPosition(coords.x, coords.y);
                    if (conversationalUnit && !conversationalUnit.isDragging) {
                        selectedConversationalUnit = conversationalUnit;
                        createConversationDialog(conversationalUnit);
                        log(`Started conversation with ${conversationalUnit.type}`, 'info');
                        updateStatistics('conversation_started');
                        return;
                    }

                    // Then check for regular units to show info
                    const regularUnit = getUnitAtPosition(coords.x, coords.y);
                    if (regularUnit && !regularUnit.isDragging) {
                        showUnitInfo(regularUnit);
                        log(`Viewing info for ${regularUnit.type}`, 'info');
                        return;
                    }

                    // If clicking on empty space, hide unit info
                    hideUnitInfo();
                }

                // Reset drag state
                dragState.isDragging = false;
                dragState.draggedUnit = null;
                dragState.dragOffsetX = 0;
                dragState.dragOffsetY = 0;
                dragState.originalPosition = null;
                dragState.totalDragDistance = 0;
                dragState.placementEffects = [];
                dragState.proximityIndicators = [];
                canvas.style.cursor = 'default';
            });

            canvas.addEventListener('mouseleave', (e) => {
                dragState.hoveredUnit = null;
                canvas.style.cursor = 'default';
            });

            runTests(); // Run TDD tests on startup
            gameLoop();
        };

        // TDD FIX: init() is now called in DOMContentLoaded event listener
    </script>
</body>
</html>
