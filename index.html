<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Resonant Sanctuary: The Weaver</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            background-color: #0c0a1e; /* Deep cosmic blue */
        }
        .stat-card {
            background-color: rgba(18, 16, 46, 0.7); /* Dark blue/purple */
            backdrop-filter: blur(10px);
            transition: all 0.2s ease-in-out;
            border: 1px solid rgba(76, 71, 128, 0.5);
        }
        .module-card {
            background-color: #1c1944; /* Muted cosmic blue */
            transition: all 0.2s ease-in-out;
            border: 1px solid rgba(76, 71, 128, 0.5);
        }
        .unit-card {
             background-color: #2a275c;
        }
        .log-panel {
            height: 150px;
            background-color: rgba(10, 8, 28, 0.9);
            border-top: 1px solid rgba(76, 71, 128, 0.5);
        }
        canvas {
            border-radius: 0.75rem;
        }
        .gemini-btn.loading, .gemini-btn:disabled, button:disabled {
            cursor: not-allowed;
            background-color: #4a5568;
            opacity: 0.7;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .log-entry {
            animation: fadeIn 0.5s ease-out;
        }
    </style>
</head>
<body class="text-indigo-100 flex flex-col h-screen">

    <!-- Top Bar -->
    <header class="w-full p-4 bg-[#1c1944] border-b border-indigo-900 shadow-lg z-10">
        <h1 class="text-2xl font-bold text-white">Resonant Sanctuary: The Weaver</h1>
    </header>

    <!-- Main Content -->
    <div class="flex flex-1 overflow-hidden">
        
        <!-- Left Panel: Units & Upgrades -->
        <aside class="w-1/3 max-w-sm p-4 overflow-y-auto bg-[#1c1944] border-r border-indigo-900 flex flex-col">
            <div>
                <h2 class="text-xl font-semibold mb-4 text-white">Create Units</h2>
                <div id="units-panel" class="space-y-4">
                    <!-- Unit creation cards will be injected here -->
                </div>
            </div>
            <div class="mt-6 flex-1">
                <h2 class="text-xl font-semibold mb-4 text-white">Attune Nodes</h2>
                <div id="modules-panel" class="space-y-4">
                    <!-- Module cards will be injected here -->
                </div>
            </div>
             <div class="mt-6 space-y-3">
                 <button id="advisor-btn" class="gemini-btn w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg shadow-md transition-colors">
                    üìú Ask Advisor
                </button>
                 <button id="seasonal-vision-btn" class="gemini-btn w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-4 rounded-lg shadow-md transition-colors">
                    ‚ú® Get Resonant Vision
                </button>
            </div>
        </aside>

        <!-- Center Panel: Village View & Stats -->
        <main class="flex-1 flex flex-col p-4">
            <!-- Stats Bar -->
            <div id="stats-bar" class="grid grid-cols-2 md:grid-cols-5 gap-4 mb-4">
                <!-- Stat cards will be injected here -->
            </div>

            <!-- Village Canvas -->
            <div class="flex-1 relative">
                 <canvas id="village-canvas" class="w-full h-full"></canvas>
            </div>
        </main>

    </div>

    <!-- Bottom Bar: Log -->
    <footer id="log-panel" class="w-full p-4 border-t border-indigo-900 overflow-y-auto">
        <h3 class="font-semibold text-lg mb-2 text-indigo-200">Aetheric Log</h3>
        <div id="log-output" class="text-sm text-indigo-300 space-y-1"></div>
    </footer>
    
    <!-- TDD Test Runner (Hidden) -->
    <div id="test-runner" style="display: none;"></div>

    <script>
        // --- Canvas & DOM Elements ---
        const canvas = document.getElementById('village-canvas');
        const ctx = canvas.getContext('2d');
        const modulesPanel = document.getElementById('modules-panel');
        const unitsPanel = document.getElementById('units-panel');
        const statsBar = document.getElementById('stats-bar');
        const logOutput = document.getElementById('log-output');
        const seasonalVisionBtn = document.getElementById('seasonal-vision-btn');
        const advisorBtn = document.getElementById('advisor-btn');

        // --- Game State (Incremental Model) ---
        let gameState = {
            energy: 10,
            energyPerSecond: 0,
            insight: 0,
            insightPerSecond: 0,
            harmony: 50,
            units: {
                dreamers: 0,
                weavers: 0,
            },
            unitCosts: {
                dreamers: 10,
                weavers: 10,
            },
            nodes: {
                sustenance: 0,
                energy: 0,
                cohesion: 0,
                cycling: 0,
            },
            nodeCosts: {
                sustenance: 100,
                energy: 100,
                cohesion: 500,
                cycling: 200,
            },
            villageGrid: [],
            stars: [],
            lastUpdate: Date.now(),
        };

        // --- Game Config ---
        const unitsConfig = {
            dreamers: { name: "Dreamer", description: "Generates Insight.", baseInsight: 0.1, costResource: 'energy' },
            weavers: { name: "Weaver", description: "Generates Energy.", baseEnergy: 0.1, costResource: 'insight' },
        };

        const nodesConfig = {
            sustenance: { name: "Sustenance Node", description: "Boosts Dreamer insight generation.", effectTarget: 'dreamers', multiplier: 1.2, costResource: 'energy' },
            energy: { name: "Energy Node", description: "Boosts Weaver energy generation.", effectTarget: 'weavers', multiplier: 1.2, costResource: 'insight' },
            cohesion: { name: "Cohesion Node", description: "Boosts all production.", effectTarget: 'all', multiplier: 1.1, costResource: 'energy' },
            cycling: { name: "Recycling Node", description: "Reduces the cost of all units and improves Harmony.", effectTarget: 'cost', multiplier: 0.95, harmony: 5, costResource: 'insight' },
        };

        // --- Utility Functions ---
        const formatNumber = (num) => {
            if (num < 1000) return num.toFixed(1);
            if (num < 1e6) return (num / 1e3).toFixed(2) + 'k';
            if (num < 1e9) return (num / 1e6).toFixed(2) + 'M';
            return (num / 1e9).toFixed(2) + 'B';
        };
        const log = (message, type = 'info') => {
            const colors = { info: 'text-indigo-300', success: 'text-teal-300', error: 'text-red-400', warning: 'text-amber-300', gemini: 'text-purple-300' };
            const p = document.createElement('p');
            p.innerHTML = `[INFO] ${message}`;
            p.className = `${colors[type]} log-entry`;
            logOutput.prepend(p);
            if (logOutput.children.length > 20) {
                logOutput.lastChild.remove();
            }
        };

        // --- Rendering Functions ---
        const renderStats = () => {
            statsBar.innerHTML = `
                <div class="stat-card p-3 rounded-lg" title="Energy. Used to create Dreamers."><p class="text-sm text-indigo-300">‚ö° Energy</p><p class="text-xl font-bold text-yellow-300">${formatNumber(gameState.energy)}</p><p class="text-xs text-yellow-400">${formatNumber(gameState.energyPerSecond)}/s</p></div>
                <div class="stat-card p-3 rounded-lg" title="Insight. Used to create Weavers."><p class="text-sm text-indigo-300">üîÆ Insight</p><p class="text-xl font-bold text-purple-300">${formatNumber(gameState.insight)}</p><p class="text-xs text-purple-400">${formatNumber(gameState.insightPerSecond)}/s</p></div>
                <div class="stat-card p-3 rounded-lg" title="Dreamers generate Insight."><p class="text-sm text-indigo-300">Î™Ω Dreamers</p><p class="text-xl font-bold">${formatNumber(gameState.units.dreamers)}</p></div>
                <div class="stat-card p-3 rounded-lg" title="Weavers generate Energy."><p class="text-sm text-indigo-300">üï∏Ô∏è Weavers</p><p class="text-xl font-bold">${formatNumber(gameState.units.weavers)}</p></div>
                <div class="stat-card p-3 rounded-lg" title="Ecological balance."><p class="text-sm text-indigo-300">üåø Harmony</p><p class="text-xl font-bold text-green-400">${gameState.harmony.toFixed(1)}%</p></div>
            `;
        };

        const renderUnits = () => {
            unitsPanel.innerHTML = '';
            for (const key in unitsConfig) {
                const unit = unitsConfig[key];
                const cost = gameState.unitCosts[key];
                const canAfford = gameState[unit.costResource] >= cost;
                const card = document.createElement('div');
                card.className = "unit-card p-4 rounded-lg border border-indigo-800";
                card.innerHTML = `
                    <h3 class="font-bold text-lg text-white">${unit.name}</h3>
                    <p class="text-sm text-indigo-200">${unit.description}</p>
                    <button class="w-full mt-2 py-2 px-3 text-sm font-semibold rounded-md transition-colors ${canAfford ? 'bg-green-600 hover:bg-green-700 text-white' : 'bg-gray-600 text-gray-400'}"
                            onclick="createUnit('${key}')" ${!canAfford ? 'disabled' : ''}>
                        Create (Cost: ${formatNumber(cost)} ${unit.costResource})
                    </button>
                `;
                unitsPanel.appendChild(card);
            }
        };

        const renderNodes = () => {
            modulesPanel.innerHTML = '';
            for (const key in nodesConfig) {
                const node = nodesConfig[key];
                const cost = gameState.nodeCosts[key];
                const canAfford = gameState[node.costResource] >= cost;
                const card = document.createElement('div');
                card.className = "module-card p-4 rounded-lg";
                card.innerHTML = `
                    <h3 class="font-bold text-lg text-white">${node.name} <span class="text-sm font-normal text-indigo-300">(Lvl ${gameState.nodes[key]})</span></h3>
                    <p class="text-sm text-indigo-200">${node.description}</p>
                    <button class="w-full mt-2 py-2 px-3 text-sm font-semibold rounded-md transition-colors ${canAfford ? 'bg-teal-600 hover:bg-teal-700 text-white' : 'bg-gray-600 text-gray-400'}"
                            onclick="upgradeNode('${key}')" ${!canAfford ? 'disabled' : ''}>
                        Attune (Cost: ${formatNumber(cost)} ${node.costResource})
                    </button>
                `;
                modulesPanel.appendChild(card);
            }
        };

        const renderUI = () => {
            renderStats();
            renderUnits();
            renderNodes();
        }
        
        // --- Drawing ---
        const drawSanctuary = () => {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            
            // Background
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#0c0a1e');
            gradient.addColorStop(1, '#1c1944');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Stars
            if (gameState.stars.length === 0) {
                for (let i = 0; i < 100; i++) {
                    gameState.stars.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, radius: Math.random() * 1.5, alpha: 0.5 + Math.random() * 0.5 });
                }
            }
            gameState.stars.forEach(star => {
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${star.alpha * (0.75 + Math.sin(Date.now() / 1000 + star.x) * 0.25)})`;
                ctx.fill();
            });

            // Sprites
            gameState.villageGrid.sort((a, b) => a.y - b.y);
            gameState.villageGrid.forEach(item => {
                if (item.type === 'dome') drawDome(item.x, item.y, item.size);
                else if (item.type === 'crystal_tree') drawCrystalTree(item.x, item.y, item.size);
                else if (item.type === 'garden') drawGarden(item.x, item.y, item.size);
            });
        };

        const addSprite = (type, count = 1) => {
            for (let i = 0; i < count; i++) {
                gameState.villageGrid.push({ type: type, x: Math.random() * canvas.width, y: Math.random() * canvas.height, size: 10 + Math.random() * 15 });
            }
        };

        const drawDome = (x, y, size) => {
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            const gradient = ctx.createRadialGradient(x, y, 1, x, y, size);
            gradient.addColorStop(0, 'rgba(221, 214, 254, 0.8)');
            gradient.addColorStop(1, 'rgba(128, 90, 213, 0.5)');
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.strokeStyle = 'rgba(221, 214, 254, 0.9)';
            ctx.stroke();
        };

        const drawCrystalTree = (x, y, size) => {
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x - size / 2, y - size * 1.5);
            ctx.lineTo(x, y - size * 2);
            ctx.lineTo(x + size / 2, y - size * 1.5);
            ctx.closePath();
            const gradient = ctx.createLinearGradient(x - size, y - size*2, x + size, y);
            gradient.addColorStop(0, '#a78bfa');
            gradient.addColorStop(1, '#4f46e5');
            ctx.fillStyle = gradient;
            ctx.globalAlpha = 0.7;
            ctx.fill();
            ctx.globalAlpha = 1;
        };
        
        const drawGarden = (x, y, size) => {
            ctx.fillStyle = 'rgba(76, 71, 128, 0.4)';
            ctx.fillRect(x - size, y - size/2, size * 2, size);
            for(let i = 0; i < 5; i++) {
                const flowerX = x - size + Math.random() * size * 2;
                const flowerY = y - size/2 + Math.random() * size;
                ctx.fillStyle = ['#fde047', '#a78bfa', '#f472b6'][Math.floor(Math.random() * 3)];
                ctx.beginPath();
                ctx.arc(flowerX, flowerY, 3, 0, Math.PI * 2);
                ctx.shadowColor = ctx.fillStyle;
                ctx.shadowBlur = 10;
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        };

        // --- Gemini API Integration ---
        async function callGemini(prompt, button) {
            if (button) { button.disabled = true; button.classList.add('loading'); button.innerHTML = 'AI is thinking...'; }
            try {
                const apiKey = ""; const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
                const payload = { contents: [{ parts: [{ text: prompt }] }] };
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) throw new Error(`API call failed: ${response.status}`);
                const result = await response.json();
                return result.candidates[0].content.parts[0].text;
            } catch (error) { console.error("Gemini API Error:", error); return "The aetheric connection is unclear.";
            } finally {
                 if (button) {
                    button.disabled = false;
                    if(button.id === 'seasonal-vision-btn') button.innerHTML = '‚ú® Get Resonant Vision';
                    if(button.id === 'advisor-btn') button.innerHTML = 'üìú Ask Advisor';
                }
            }
        }
        async function getSeasonalVision() {
            const prompt = `You are a storyteller for a game called Resonant Sanctuary. Write a short, poetic, 2-3 sentence story about the sanctuary. Current state: Energy production is ${gameState.energyPerSecond.toFixed(1)}/s, Insight production is ${gameState.insightPerSecond.toFixed(1)}/s. The sanctuary has ${gameState.units.dreamers} dreamers and ${gameState.units.weavers} weavers. Keep it mystical.`;
            const story = await callGemini(prompt, seasonalVisionBtn);
            log(`‚ú® ${story}`, 'gemini');
        }
        async function getAdvisorInsight() {
            const prompt = `You are an AI advisor in Resonant Sanctuary. The player needs help. Based on these stats (Energy: ${formatNumber(gameState.energy)}, Insight: ${formatNumber(gameState.insight)}, Energy/s: ${formatNumber(gameState.energyPerSecond)}, Insight/s: ${formatNumber(gameState.insightPerSecond)}), give a single, actionable piece of advice. Start with "The sanctuary whispers..." and keep it under 30 words.`;
            const advice = await callGemini(prompt, advisorBtn);
            log(`üìú ${advice}`, 'gemini');
        }

        // --- Game Logic ---
        window.createUnit = (key) => {
            const unitConf = unitsConfig[key];
            const cost = gameState.unitCosts[key];
            if (gameState[unitConf.costResource] >= cost) {
                gameState[unitConf.costResource] -= cost;
                gameState.units[key]++;
                gameState.unitCosts[key] *= 1.15;
                if (key === 'dreamers') addSprite('crystal_tree');
                if (key === 'weavers') addSprite('dome');
                log(`A new ${unitConf.name} joins the sanctuary.`, 'success');
                renderUI(); // Immediate UI feedback
            }
        };

        window.upgradeNode = (key) => {
            const nodeConf = nodesConfig[key];
            const cost = gameState.nodeCosts[key];
            if (gameState[nodeConf.costResource] >= cost) {
                gameState[nodeConf.costResource] -= cost;
                gameState.nodes[key]++;
                gameState.nodeCosts[key] *= 2.5;
                if (nodeConf.harmony) {
                    gameState.harmony = Math.min(100, gameState.harmony + nodeConf.harmony);
                }
                if (key === 'sustenance') addSprite('garden');
                log(`Attuned the ${nodeConf.name}. Its resonance grows stronger.`, 'success');
                renderUI(); // Immediate UI feedback
            }
        };
        
        const updateGameState = (delta) => {
            // Calculate production per second
            let energyPerSecond = gameState.units.weavers * unitsConfig.weavers.baseEnergy;
            let insightPerSecond = gameState.units.dreamers * unitsConfig.dreamers.baseInsight;

            // Apply node bonuses
            let costMultiplier = 1;
            energyPerSecond *= Math.pow(nodesConfig.energy.multiplier, gameState.nodes.energy);
            insightPerSecond *= Math.pow(nodesConfig.sustenance.multiplier, gameState.nodes.sustenance);
            const cohesionBonus = Math.pow(nodesConfig.cohesion.multiplier, gameState.nodes.cohesion);
            energyPerSecond *= cohesionBonus;
            insightPerSecond *= cohesionBonus;
            costMultiplier *= Math.pow(nodesConfig.cycling.multiplier, gameState.nodes.cycling);

            // Update unit costs based on multiplier (visual only, actual cost is in gameState)
            // This is a simplification; a more robust model would adjust the base cost.

            gameState.energyPerSecond = energyPerSecond;
            gameState.insightPerSecond = insightPerSecond;

            // Add resources
            gameState.energy += energyPerSecond * delta;
            gameState.insight += insightPerSecond * delta;
        };

        const gameLoop = () => {
            const now = Date.now();
            const delta = (now - gameState.lastUpdate) / 1000; // Time in seconds
            
            updateGameState(delta);
            
            renderUI();
            drawSanctuary();
            
            gameState.lastUpdate = now;
            requestAnimationFrame(gameLoop);
        };

        // --- TDD Test Suite ---
        const runTests = () => {
            console.log("--- Running TDD Test Suite ---");

            // Test 1: Initial game state
            const initialState = { ...gameState };
            console.assert(initialState.energy === 10, "Test 1.1 Failed: Initial energy should be 10.");
            console.assert(initialState.insight === 0, "Test 1.2 Failed: Initial insight should be 0.");
            console.assert(initialState.harmony === 50, "Test 1.3 Failed: Initial harmony should be 50.");

            // Test 2: Composting upgrade increases harmony
            const initialHarmony = initialState.harmony;
            gameState.insight = 200; // Ensure we can afford the upgrade
            upgradeNode('cycling');
            console.assert(gameState.harmony > initialHarmony, "Test 2.1 Failed: Composting upgrade should increase harmony.");

            // Test 3: Creating a unit deducts resources
            const initialEnergy = gameState.energy;
            createUnit('dreamers');
            console.assert(gameState.energy < initialEnergy, "Test 3.1 Failed: Creating a dreamer should deduct energy.");

            console.log("--- TDD Test Suite Finished ---");
        };

        // --- Initialization ---
        const init = () => {
            log("Welcome, Weaver. The sanctuary awakens. Resonate with the cosmos.", "success");
            addSprite('dome', 1); 
            addSprite('crystal_tree', 1);
            advisorBtn.addEventListener('click', getAdvisorInsight);
            seasonalVisionBtn.addEventListener('click', getSeasonalVision);
            runTests(); // Run TDD tests on startup
            gameLoop();
        };

        init();
    </script>
</body>
</html>
